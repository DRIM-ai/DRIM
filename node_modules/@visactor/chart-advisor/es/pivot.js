import { isNil, range, uniqArray } from '@visactor/vutils';
import { getDomainFromDataset } from './fieldUtils';
export const pivot = (dataset, colList, rowList, measureList, paginationInfo) => {
    const rowPathList = getPathList(rowList, dataset);
    const colPathList = getPathList(colList, dataset);
    const rowPathListPage = paginationDataset(rowPathList, paginationInfo);
    const rowGroups = groupByDims(dataset, rowList, rowPathListPage);
    const colGroups = rowGroups.map((row) => groupByDims(row, colList, colPathList));
    const groups = colGroups.map((pane) => pane.map((cell) => groupByMeas(cell, measureList)));
    const rowPivotTree = pivotTree(rowList, rowPathListPage);
    const colPivotTree = pivotTree(colList, colPathList);
    return {
        datasets: groups,
        colPivotTree,
        rowPivotTree,
        length: rowGroups.length
    };
};
export const pivotCombination = (dataset, colList, rowList) => {
    const metaLength = dataset.length;
    const datasetWithTag = dataset.map((dataList, index) => dataList.map((data) => addTag(data, index)));
    const flatDataset = datasetWithTag.flat();
    const rowPathList = getPathList(rowList, flatDataset);
    const colPathList = getPathList(colList, flatDataset);
    const rowGroups = groupByDims(flatDataset, rowList, rowPathList);
    const colGroups = rowGroups.map((row) => groupByDims(row, colList, colPathList));
    const groups = colGroups.map((pane) => pane.map((cell) => groupByMeta(cell, metaLength)));
    const rowPivotTree = pivotTree(rowList, rowPathList);
    const colPivotTree = pivotTree(colList, colPathList);
    return {
        datasets: groups,
        colPivotTree,
        rowPivotTree,
        length: rowGroups.length
    };
};
const getPathList = (keys, dataset, filterList = []) => {
    const pathList = [];
    if (keys.length > 0) {
        const key = keys[0];
        const valueList = getDomainFromDataset(dataset, key);
        valueList.forEach((value) => {
            if (keys.length > 1) {
                const _dataset = filterDataItem(dataset, [key], [value]);
                const _filterList = [...filterList, value];
                pathList.push(...getPathList(keys.slice(1), _dataset, _filterList));
            }
            else {
                pathList.push([...filterList, value]);
            }
        });
    }
    return pathList;
};
const groupByDims = (source, keys, pathList) => {
    if (pathList.length === 0) {
        return [source];
    }
    const groups = pathList.map((path) => filterDataItem(source, keys, path));
    return groups;
};
const groupByMeas = (source, measures) => {
    if (measures.length <= 1) {
        return [source];
    }
    return measures.map((measure) => source.filter((dataItem) => !isNil(dataItem[measure])));
};
const groupByMeta = (source, length) => {
    const group = range(length).map((index) => source.filter((data) => data[COMBINATION_INDEX] === index).map((data) => removeTag(data)));
    return group;
};
const paginationDataset = (pathList, paginationInfo) => {
    if (isNil(paginationInfo)) {
        return pathList;
    }
    const pageOffset = paginationInfo.offset;
    const pageSize = paginationInfo.size;
    return pathList.slice(pageOffset, pageOffset + pageSize);
};
const pivotTree = (keys, pathList, deep = 0) => {
    if (keys.length < deep + 1) {
        return null;
    }
    const getDomainFromPath = () => {
        const nodes = pathList.map((path) => path[deep]);
        return uniqArray(nodes);
    };
    const field = keys[deep];
    const domain = getDomainFromPath();
    return {
        field,
        values: domain.map((value) => ({
            value,
            child: pivotTree(keys, pathList.filter((path) => path[deep] === value), deep + 1)
        }))
    };
};
const filterDataItem = (sourceList, keyList, valueList) => sourceList.filter(dataItem => checkKeysValues(dataItem, keyList, valueList));
const checkKeysValues = (dataItem, keyList, valueList) => range(keyList.length)
    .map((idx) => String(dataItem[keyList[idx]]) === valueList[idx])
    .reduce((pre, cur) => pre && cur, true);
const COMBINATION_INDEX = '__combination_index__';
const addTag = (dataItem, i) => ({
    ...dataItem,
    [COMBINATION_INDEX]: i
});
const removeTag = (dataItem) => {
    const _dataItem = { ...dataItem };
    delete _dataItem[COMBINATION_INDEX];
    return _dataItem;
};
