import { cloneDeep } from '@visactor/vutils';
import * as dataUtils from './dataUtil';
import { productLength, legendProduct, getDomainFromDataset, retainDatasetField, getCartesianInfo, getFoldInfo, fold, removeDatasetField } from './fieldUtils';
import { FOLD_NAME, FOLD_VALUE, COLOR_FIELD, GROUP_FIELD, FOLD_VALUE_MAIN, FOLD_VALUE_SUB, X_MAX_COUNT, MAX_POINT_COUNT, LEGEND_MAX_COUNT, LEGEND_MAX_POINT_COUNT } from './constant';
export const assignPivotCharts = (originDataset, dimList, measureList, aliasMapOld, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const aliasMap = cloneDeep(aliasMapOld);
    let dataset = cloneDeep(originDataset);
    const cell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (dimList.length === 0 || measureList.length === 0) {
        return { cell, dataset };
    }
    let nowDimIndex = 0;
    while ((cell.row.length < MAX_PIVOT_ROW || cell.column.length < MAX_PIVOT_COLUMN) &&
        nowDimIndex + 1 < dimList.length) {
        if (cell.row.length <= cell.column.length) {
            cell.row.push(dimList[nowDimIndex]);
        }
        else {
            cell.column.push(dimList[nowDimIndex]);
        }
        nowDimIndex++;
    }
    cell.x.push(dimList[nowDimIndex]);
    nowDimIndex++;
    const colorFields = [];
    colorFields.push(...dimList.slice(nowDimIndex));
    const measuresListLength = measureList.length;
    let colorFieldsIncludeMeasure = false;
    if (measuresListLength > 1) {
        aliasMap[FOLD_NAME] = `指标名称`;
        aliasMap[FOLD_VALUE] = `指标值`;
        colorFields.push(FOLD_NAME);
        colorFieldsIncludeMeasure = true;
        cell.y.push(FOLD_VALUE);
    }
    else if (measuresListLength === 1) {
        cell.y.push(measureList[0]);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => getDomainFromDataset(dataset, uniqueId));
    const dimItemsLen = getDomainFromDataset(dataset, cell.x[0]).length;
    const colorItemsLen = productLength(colorFieldsValues);
    if (dimItemsLen > X_MAX_COUNT ||
        dataset.length > MAX_POINT_COUNT ||
        (colorItemsLen > LEGEND_MAX_COUNT && dataset.length > LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = legendProduct(colorFieldsValues, colorFieldsIncludeMeasure);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = getDomainFromDataset(dataset, COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[COLOR_FIELD] = `图例项`;
        cell.color.push(COLOR_FIELD);
        cell.cartesianInfo = getCartesianInfo(colorFields, COLOR_FIELD);
        if (measuresListLength > 1) {
            cell.foldInfo = getFoldInfo(measureList, FOLD_NAME, FOLD_VALUE, aliasMap);
        }
    }
    return { cell, dataset, colorItems, aliasMap };
};
export const processCombination = (originDataset, dimList, measureList, aliasMapOld, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const aliasMap = cloneDeep(aliasMapOld);
    const dataset = cloneDeep(originDataset);
    const metaDatas = [];
    measureList.forEach(measure => {
        const _allPillsIdList = [].concat(dimList, [measure]);
        const _dataset = retainDatasetField(dataset, _allPillsIdList);
        const metaData = assignPivotCharts(_dataset, dimList, [measure], aliasMap, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN);
        metaDatas.push(metaData);
    });
    return metaDatas;
};
export const assignScatterPlot = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = cloneDeep(aliasMapOld);
    let dataset = cloneDeep(originDataset);
    const scatterCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: [],
        group: [GROUP_FIELD]
    };
    let remainMeasure = measureList.length;
    if (dimList.length === 0 || measureList.length < 2) {
        return { scatterCell, dataset };
    }
    scatterCell.x.push(measureList[0]);
    scatterCell.y.push(measureList[1]);
    remainMeasure -= 2;
    if (measureList.length > 2) {
        scatterCell.size.push(measureList[2]);
    }
    remainMeasure -= 1;
    const groupDimensions = [];
    if (dimList.length > 1) {
        scatterCell.color.push(dimList[1]);
        groupDimensions.concat(dimList.slice(2));
    }
    else {
        groupDimensions.concat(dimList.slice(1));
        if (measureList.length > 3) {
            scatterCell.color.push(measureList[3]);
            remainMeasure -= 1;
        }
    }
    if (remainMeasure > 0) {
        const voidCell = {
            x: [],
            y: [],
            row: [],
            column: [],
            color: [],
            size: [],
            angle: []
        };
        return { scatterCell: voidCell, dataset };
    }
    const colorFieldsValues = scatterCell.color.map((uniqueId) => getDomainFromDataset(dataset, uniqueId));
    const colorItemsLen = productLength(colorFieldsValues);
    if (dataset.length > MAX_POINT_COUNT ||
        (colorItemsLen > LEGEND_MAX_COUNT && dataset.length > LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = legendProduct(colorFieldsValues, false);
    const colorItems = colorItemsList.map(d => d.join('-'));
    dataset = dataset.map((data) => {
        const groupItem = groupDimensions.map((field) => data[field]).join('-');
        return {
            ...data,
            [GROUP_FIELD]: groupItem
        };
    });
    aliasMap[GROUP_FIELD] = `细分`;
    return {
        scatterCell,
        dataset: [[[dataset]]],
        colorItems,
        aliasMap
    };
};
export const sortTimeDim = (dimList, MAX_PIVOT_ROW, MAX_PIVOT_COLUMN) => {
    const dimListLength = dimList.length;
    const firstTimeIndex = dimList.findIndex(dim => {
        const isDateType = dataUtils.isTemporal(dim.dataType);
        return isDateType;
    });
    let targetPosition;
    if (MAX_PIVOT_COLUMN + MAX_PIVOT_ROW > dimListLength - 1) {
        targetPosition = dimListLength - 1;
    }
    else {
        targetPosition = MAX_PIVOT_ROW + MAX_PIVOT_COLUMN;
    }
    const idList = dimList.map(dim => dim.uniqueID);
    const timeItem = idList[firstTimeIndex];
    idList.splice(firstTimeIndex, 1);
    idList.splice(targetPosition, 0, timeItem);
    return idList;
};
export const assignPieChart = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = cloneDeep(aliasMapOld);
    let dataset = cloneDeep(originDataset);
    const pieCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (!(dimList.length === 0 && measureList.length >= 3)) {
        return { pieCell, dataset };
    }
    const colorFields = [...dimList];
    let colorFieldsIncludeMeasure = false;
    const measuresListLength = measureList.length;
    if (measuresListLength > 1) {
        aliasMap[FOLD_NAME] = `指标名称`;
        aliasMap[FOLD_VALUE] = `指标值`;
        colorFields.push(FOLD_NAME);
        colorFieldsIncludeMeasure = true;
        pieCell.angle.push(FOLD_VALUE);
    }
    else if (measuresListLength === 1) {
        pieCell.angle.push(measureList[0]);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => getDomainFromDataset(dataset, uniqueId));
    const colorItemsLen = productLength(colorFieldsValues);
    if (dataset.length > MAX_POINT_COUNT ||
        (colorItemsLen > LEGEND_MAX_COUNT && dataset.length > LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = legendProduct(colorFieldsValues, colorFieldsIncludeMeasure);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = getDomainFromDataset(dataset, COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[COLOR_FIELD] = `图例项`;
        pieCell.color.push(COLOR_FIELD);
        pieCell.cartesianInfo = getCartesianInfo(colorFields, COLOR_FIELD);
        if (measuresListLength > 1) {
            pieCell.foldInfo = getFoldInfo(measureList, FOLD_NAME, FOLD_VALUE, aliasMap);
        }
    }
    return { pieCell, dataset, colorItems, aliasMap };
};
export const assignMeasureCard = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = cloneDeep(aliasMapOld);
    const dataset = cloneDeep(originDataset);
    const cardDataset = fold(dataset, measureList, FOLD_NAME, FOLD_VALUE, aliasMap);
    const cardCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [FOLD_NAME],
        size: [FOLD_VALUE],
        angle: [],
        value: [FOLD_VALUE],
        text: [FOLD_NAME]
    };
    return { cardCell, dataset: cardDataset };
};
export const assignFunnelChart = (originDataset, dimList, measureList, aliasMapOld) => {
    const aliasMap = cloneDeep(aliasMapOld);
    const dataset = cloneDeep(originDataset);
    const funnelCell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        size: [],
        angle: []
    };
    if (!((dimList.length === 1 && measureList.length === 1) || (dimList.length === 0 && measureList.length >= 2))) {
        return { funnelCell, dataset };
    }
    const measuresListLength = measureList.length;
    if (measuresListLength > 1) {
        aliasMap[FOLD_NAME] = `指标名称`;
        aliasMap[FOLD_VALUE] = `指标值`;
        funnelCell.size.push(FOLD_VALUE);
        funnelCell.foldInfo = getFoldInfo(measureList, FOLD_NAME, FOLD_VALUE, aliasMap);
    }
    else if (measuresListLength === 1) {
        funnelCell.size.push(measureList[0]);
    }
    const dimensionIdListLength = dimList.length;
    if (dimensionIdListLength > 0) {
        funnelCell.color.push(dimList[0]);
    }
    else if (dimensionIdListLength === 0 && measuresListLength > 1) {
        funnelCell.size.push(FOLD_NAME);
    }
    return { funnelCell, dataset };
};
export const assignDualAxis = (originDataset, dimList, measureList, subMeasureList, aliasMapOld) => {
    const aliasMap = cloneDeep(aliasMapOld);
    let dataset = cloneDeep(originDataset);
    const cell = {
        x: [],
        y: [],
        row: [],
        column: [],
        color: [],
        cartesianInfo: null,
        foldInfo: null
    };
    const singleSide = isMain => {
        let _measuresIdList;
        let removeIdList;
        let FOLD_VALUE_FIELD;
        let aliasFoldValue;
        if (isMain) {
            _measuresIdList = measureList;
            removeIdList = subMeasureList;
            FOLD_VALUE_FIELD = FOLD_VALUE_MAIN;
            aliasFoldValue = `指标值(主轴)`;
        }
        else {
            _measuresIdList = subMeasureList;
            removeIdList = measureList;
            FOLD_VALUE_FIELD = FOLD_VALUE_SUB;
            aliasFoldValue = `指标值(次轴)`;
        }
        if (_measuresIdList.length === 0) {
            return [];
        }
        let sideDataset = removeDatasetField(dataset, removeIdList);
        sideDataset = fold(sideDataset, _measuresIdList, FOLD_NAME, FOLD_VALUE_FIELD, aliasMap, false);
        aliasMap[FOLD_VALUE_FIELD] = aliasFoldValue;
        cell.y.push(FOLD_VALUE_FIELD);
        return sideDataset;
    };
    const datasetMain = singleSide(true);
    const datasetSub = singleSide(false);
    dataset = [].concat(datasetMain, datasetSub);
    const dimensionIdList = dimList;
    const measureIdList = measureList.concat(subMeasureList);
    const colorFields = [];
    if (dimensionIdList.length > 0) {
        cell.x.push(String(dimensionIdList[0]));
        colorFields.push(...dimensionIdList.slice(1));
    }
    const measuresListLength = measureIdList.length;
    if (measuresListLength > 0) {
        aliasMap[FOLD_NAME] = `指标名称`;
        colorFields.push(FOLD_NAME);
    }
    const colorFieldsValues = colorFields.map((uniqueId) => getDomainFromDataset(dataset, uniqueId));
    const dimItemsLen = getDomainFromDataset(dataset, cell.x[0]).length;
    const colorItemsLen = productLength(colorFieldsValues);
    if (dimItemsLen > X_MAX_COUNT ||
        dataset.length > MAX_POINT_COUNT ||
        (colorItemsLen > LEGEND_MAX_COUNT && dataset.length > LEGEND_MAX_POINT_COUNT)) {
        return {
            error: true,
            errorMsg: `数据量或图例项过多，请使用表格展示。`
        };
    }
    const colorItemsList = legendProduct(colorFieldsValues, true);
    let colorItems = colorItemsList.map(d => d.join('-'));
    if (colorFields.length > 0) {
        dataset = dataset.map((data) => {
            const colorItem = colorFields.map(field => data[field]).join('-');
            return {
                ...data,
                [COLOR_FIELD]: colorItem
            };
        });
        const _colorItems = getDomainFromDataset(dataset, COLOR_FIELD);
        colorItems = colorItems.filter((d) => _colorItems.includes(d));
        aliasMap[COLOR_FIELD] = `图例项`;
        cell.color.push(COLOR_FIELD);
        cell.cartesianInfo = getCartesianInfo(colorFields, COLOR_FIELD);
        cell.foldInfo = getFoldInfo(measureIdList, FOLD_NAME, [FOLD_VALUE_MAIN, FOLD_VALUE_SUB], aliasMap);
    }
    return {
        dataset,
        cell,
        colorItems,
        aliasMap
    };
};
