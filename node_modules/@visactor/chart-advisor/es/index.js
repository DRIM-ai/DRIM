import { ChartType, ScreenSize, UserPurpose } from './type';
import { scorer as defaultScorer } from './score';
import * as dataUtils from './dataUtil';
import { isNil } from '@visactor/vutils';
import { isNaN } from './dataUtil';
export { fold, omit } from './fieldUtils';
export { FOLD_NAME, FOLD_VALUE, COLOR_FIELD, FOLD_VALUE_MAIN, FOLD_VALUE_SUB, GROUP_FIELD } from './constant';
export function chartAdvisor(params) {
    var _a;
    const { originDataset, dimensionList, measureList, aliasMap = {}, maxPivotRow = 0, maxPivotColumn = 0, purpose = UserPurpose.NONE, screen = ScreenSize.LARGE, scorer = defaultScorer } = params;
    const measureDatasets = [];
    measureList.forEach(measure => {
        const uniqueID = measure.uniqueId;
        const measureSet = {
            data: []
        };
        measureSet.uniqueID = uniqueID;
        originDataset.forEach(row => {
            if (row.hasOwnProperty(uniqueID)) {
                measureSet.data.push(parseFloat(row[uniqueID]));
            }
        });
        const dataNotNull = measureSet.data.filter(each => !isNil(each) && !isNaN(each));
        measureSet.min = Math.min(...dataNotNull);
        measureSet.max = Math.max(...dataNotNull);
        measureSet.mean = dataUtils.calMean(measureSet);
        measureSet.standardDev = dataUtils.calStandardDeviation(measureSet);
        measureSet.coefficient = dataUtils.calCoefficient(measureSet);
        measureSet.Q1 = dataUtils.calQuantile(measureSet, 0.25);
        measureDatasets.push(measureSet);
    });
    const dimensionDatasets = [];
    dimensionList.forEach(dimension => {
        const uniqueID = dimension.uniqueId;
        const dimensionSet = {
            data: []
        };
        dimensionSet.uniqueID = uniqueID;
        originDataset.forEach(row => {
            dimensionSet.data.push(row[uniqueID]);
        });
        dimensionSet.dataType = dimension.type;
        dimensionSet.dimensionName = aliasMap[uniqueID];
        dimensionSet.cardinal = dataUtils.unique(dimensionSet.data).length;
        dimensionSet.ratio = dimensionSet.cardinal / dimensionSet.data.length;
        dimensionSet.isGeoField = !!dimension.isGeoField;
        dimensionDatasets.push(dimensionSet);
    });
    try {
        const scores = scorer({
            inputDataSet: originDataset,
            dimList: dimensionDatasets,
            measureList: measureDatasets,
            aliasMap,
            maxRowNum: maxPivotRow,
            maxColNum: maxPivotColumn,
            purpose,
            screen
        }).map(calculator => {
            const score = calculator();
            return score;
        });
        scores.sort((chart1, chart2) => chart2.score - chart1.score);
        if (scores[0].score === 0) {
            return {
                chartType: ChartType.TABLE,
                scores: []
            };
        }
        return {
            chartType: scores[0].chartType,
            scores
        };
    }
    catch (exception) {
        return {
            chartType: ChartType.TABLE,
            scores: [],
            error: (_a = exception.message) !== null && _a !== void 0 ? _a : exception
        };
    }
}
export { ChartType, dataUtils };
