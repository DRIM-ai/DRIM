{"version":3,"sources":["../src/core/llm.ts"],"names":[],"mappings":"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","file":"llm.js","sourcesContent":["import { isFunction, merge } from '@visactor/vutils';\nimport axios from 'axios';\nimport type { BaseContext } from '../types/atom';\nimport type { AtomName } from '../types/atom';\nimport type { LLMResponse, ToolMessage } from '../types/llm';\nimport { Model, type ILLMOptions, type LLMMessage } from '../types/llm';\nimport { matchJSONStr, parseLLMJson, revisedJSONStr } from '../utils/json';\n\n/** LLM Manager Class */\nexport class LLMManage {\n  options: ILLMOptions;\n\n  /** history chatId to support multi-turn conversation */\n  historys: Record<string, BaseContext[]>;\n\n  constructor(options: ILLMOptions) {\n    this.options = merge({}, this.getDefaultOptions(), options);\n    this.historys = {};\n  }\n\n  getDefaultOptions(): ILLMOptions {\n    return {\n      url: 'https://api.openai.com/v1/chat/completions',\n      headers: { 'Content-Type': 'application/json' },\n      method: 'POST',\n      model: Model.GPT_4o,\n      maxTokens: 2048,\n      temperature: 0,\n      frequencyPenalty: 0\n    };\n  }\n\n  updateOptions(options: ILLMOptions) {\n    this.options = merge({}, this.options, options);\n  }\n\n  async run(name: AtomName, messages: LLMMessage[], tools?: ToolMessage[]) {\n    const {\n      url = '',\n      headers,\n      method,\n      maxTokens,\n      temperature,\n      model,\n      frequencyPenalty: frequency_penalty,\n      topP: top_p,\n      customRequestFunc\n    } = this.options;\n    if (!this.historys[name]) {\n      this.historys[name] = [];\n    }\n    try {\n      const res: LLMResponse =\n        customRequestFunc?.[name] && isFunction(customRequestFunc[name])\n          ? await customRequestFunc[name](messages, tools, this.options)\n          : await axios(url, {\n              method,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              headers: headers as any,\n              data: {\n                model,\n                messages,\n                tools,\n                max_tokens: maxTokens,\n                temperature,\n                stream: false,\n                frequency_penalty,\n                top_p\n              }\n            }).then(response => response.data);\n\n      const { logId, id } = res;\n      this.historys[name].push({\n        logId,\n        id\n      });\n      if (res.error) {\n        return {\n          error: res.error\n        };\n      }\n      return res;\n    } catch (err: any) {\n      return {\n        error: err\n      };\n    }\n  }\n\n  parseTools(res: LLMResponse) {\n    const { choices = [], error } = res;\n    if (error) {\n      return {\n        error\n      };\n    }\n    if (!choices.length) {\n      return {\n        error: 'llm response is empty'\n      };\n    }\n    try {\n      const toolCalls = choices[0].message?.tool_calls || [];\n      return toolCalls.map((toolCall: any) => ({\n        ...toolCall,\n        function: {\n          ...toolCall.function,\n          arguments: parseLLMJson(toolCall.function.arguments)\n        }\n      }));\n    } catch (err: any) {\n      return {\n        error: err\n      };\n    }\n  }\n\n  parseJson(res: LLMResponse) {\n    const { choices = [], error } = res;\n    if (error) {\n      return {\n        error\n      };\n    }\n    if (!choices.length) {\n      return {\n        error: 'llm response is empty'\n      };\n    }\n    try {\n      const content = choices[0].message.content;\n      if (choices[0]?.finish_reason === 'tool_calls') {\n        return {};\n      }\n      const jsonStr = revisedJSONStr(matchJSONStr(content));\n\n      const resJson = parseLLMJson(jsonStr, '```');\n      return resJson;\n    } catch (err: any) {\n      return {\n        error: err\n      };\n    }\n  }\n}\n"]}