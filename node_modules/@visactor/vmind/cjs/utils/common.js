"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.findLastIndex = exports.getStrFromArray = exports.getIntersection = exports.average = exports.convertStringToDateValue = exports.validateDate = exports.isValidData = exports.uniqBy = exports.sampleSize = void 0;

const vutils_1 = require("@visactor/vutils"), dayjs_1 = __importDefault(require("dayjs")), customParseFormat_1 = __importDefault(require("dayjs/plugin/customParseFormat"));

dayjs_1.default.extend(customParseFormat_1.default);

const sampleSize = (array, n) => {
    const length = null === array ? 0 : array.length;
    if (!length || n < 1) return [];
    n = n > length ? length : n;
    const randIndexs = [];
    for (;randIndexs.length < n; ) {
        const rand = Math.floor(Math.random() * length);
        -1 === randIndexs.indexOf(rand) && randIndexs.push(rand);
    }
    return randIndexs.map((i => array[i]));
};

exports.sampleSize = sampleSize;

const uniqBy = (array, key) => {
    const seen = new Set;
    return array.filter((item => {
        const k = (0, vutils_1.isFunction)(key) ? key(item) : item[key];
        return void 0 !== k && (!seen.has(k) && (seen.add(k), !0));
    }));
};

exports.uniqBy = uniqBy;

const isValidData = data => null != data && "null" !== data && "" !== data;

exports.isValidData = isValidData;

const dateFormats = [ {
    key: "YYYY年MM月DD日",
    regex: /^(\d{4})年(\d{1,2})月(\d{1,2})日$/,
    format: (match, year, month, day) => `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`
}, {
    key: "MM月DD日YYYY年",
    regex: /^(\d{1,2})月(\d{1,2})日(\d{4})年$/,
    format: (match, month, day, year) => `${year}-${month.padStart(2, "0")}-${year.padStart(2, "0")}`
}, {
    key: "YYYY年MM月",
    regex: /^(\d{4})年(\d{1,2})月$/,
    format: (match, year, month) => `${year}-${month.padStart(2, "0")}`
}, {
    key: "YYYY年",
    regex: /^(\d{4})年$/,
    format: (match, year) => `${year}`
}, {
    key: "MM月",
    regex: /^(\d{1,2})月$/,
    format: (match, month) => `${month.padStart(2, "0")}`
}, {
    key: "MM月DD日",
    regex: /^(\d{1,2})月(\d{1,2})日$/,
    format: (match, month, day) => `${month.padStart(2, "0")}-${day.padStart(2, "0")}`
} ];

function isQuarterDate(date) {
    return [ /^\d{4}-Q[1-4]$/, /^\d{4}年第[一二三四]季度$/, /^Q[1-4]$/, /^\d{4}年-Q[1-4]$/ ].some((pattern => pattern.test(date)));
}

function validateDate(date) {
    const formaterDate = `${date}`.trim();
    return (0, dayjs_1.default)(formaterDate).isValid() || dateFormats.find((v => "Invalid Date" !== new Date(formaterDate.replace(v.regex, v.format)).toString())) || isQuarterDate(formaterDate);
}

function convertQuarterToMonth(quarter) {
    switch (quarter) {
      case "Q1":
      case "第一季度":
        return "01-01";

      case "Q2":
      case "第二季度":
        return "04-01";

      case "Q3":
      case "第三季度":
        return "07-01";

      case "Q4":
      case "第四季度":
        return "10-01";

      default:
        throw new Error("Invalid quarter");
    }
}

function convertStringToDateValue(stringDate) {
    const date = `${stringDate}`.trim();
    if ((0, dayjs_1.default)(date).isValid()) return date;
    const validFormat = dateFormats.find((v => "Invalid Date" !== new Date(date.replace(v.regex, v.format)).toString()));
    if (validFormat && validFormat.regex.test(date)) return date.replace(validFormat.regex, validFormat.format);
    const patterns = [ {
        regex: /^(\d{4})-Q([1-4])$/,
        format: match => `${match[1]}-${convertQuarterToMonth("Q" + match[2])}`
    }, {
        regex: /^(\d{4})年第([一二三四])季度$/,
        format: match => `${match[1]}-${convertQuarterToMonth(match[2] + "季度")}`
    }, {
        regex: /^Q([1-4])$/,
        format: match => `${convertQuarterToMonth("Q" + match[1])}`
    }, {
        regex: /^(\d{4})年-Q([1-4])$/,
        format: match => `${match[1]}-${convertQuarterToMonth("Q" + match[2])}`
    } ];
    for (const pattern of patterns) {
        const match = date.match(pattern.regex);
        if (match) return "function" == typeof pattern.format ? pattern.format(match) : date.replace(pattern.regex, pattern.format);
    }
    return date;
}

function average(data, field) {
    let sum = 0, count = 0;
    data.forEach((x => {
        const v = field ? +x[field] : +x;
        (0, vutils_1.isValidNumber)(v) && (sum += v, count++);
    }));
    return sum / count;
}

function getIntersection(array1, array2) {
    return array1.filter((value => array2.includes(value)));
}

exports.validateDate = validateDate, exports.convertStringToDateValue = convertStringToDateValue, 
exports.average = average, exports.getIntersection = getIntersection;

const KNOWLEDGE_START_INDEX = 1, getStrFromArray = array => array.map(((item, index) => `${index + 1}. ${item}`)).join("\n");

function findLastIndex(arr, predicate) {
    for (let i = arr.length - 1; i >= 0; i--) if (predicate(arr[i], i, arr)) return i;
    return -1;
}

exports.getStrFromArray = getStrFromArray, exports.findLastIndex = findLastIndex;
//# sourceMappingURL=common.js.map