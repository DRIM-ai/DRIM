"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getFieldIdInCell = exports.hasMeasureField = exports.getFieldInfoFromDataset = exports.getFieldInfo = exports.detectFieldType = exports.getFieldDomain = exports.getFieldsByDataType = exports.getFieldByDataType = exports.getFieldByRole = exports.getRemainedFields = exports.getDataListByField = exports.formatFieldInfo = exports.getRoleByFieldType = void 0;

const vutils_1 = require("@visactor/vutils"), types_1 = require("../types"), common_1 = require("./common"), calculator_1 = require("@visactor/calculator"), getRoleByFieldType = type => [ types_1.DataType.DATE, types_1.DataType.TIME, types_1.DataType.STRING, types_1.DataType.REGION ].includes(type) ? types_1.ROLE.DIMENSION : types_1.ROLE.MEASURE;

exports.getRoleByFieldType = getRoleByFieldType;

const formatFieldInfo = fieldInfo => (fieldInfo.forEach((info => {
    info.role = (0, exports.getRoleByFieldType)(info.type), info.location = (0, exports.getRoleByFieldType)(info.type), 
    info.ratioGranularity = (null == info ? void 0 : info.type) === types_1.DataType.RATIO ? (null == info ? void 0 : info.ratioGranularity) || "%" : null;
})), fieldInfo);

exports.formatFieldInfo = formatFieldInfo;

const getDataListByField = (dataset, fieldName) => (0, vutils_1.uniqArray)(dataset.map((d => d[fieldName])));

exports.getDataListByField = getDataListByField;

const getRemainedFields = (cell, fieldInfo) => {
    const usedFields = Object.values(cell).flat();
    return fieldInfo.filter((f => !usedFields.includes(f.fieldName)));
};

exports.getRemainedFields = getRemainedFields;

const getFieldByRole = (fields, role) => fields.find((f => f.role === role));

exports.getFieldByRole = getFieldByRole;

const getFieldByDataType = (fields, dataTypeList) => (fields || []).find((f => dataTypeList.includes(f.type)));

exports.getFieldByDataType = getFieldByDataType;

const getFieldsByDataType = (fields, dataTypeList) => fields.filter((f => dataTypeList.includes(f.type)));

exports.getFieldsByDataType = getFieldsByDataType;

const getFieldDomain = (dataset, column, role) => {
    const domain = dataset.map((d => role === types_1.ROLE.DIMENSION ? d[column] : Number(d[column])));
    return role === types_1.ROLE.DIMENSION ? (0, vutils_1.uniqArray)(domain).slice(0, 20) : [ Math.min(...domain), Math.max(...domain) ];
};

exports.getFieldDomain = getFieldDomain;

const detectFieldType = (dataset, column) => {
    let fieldType = [ "年份", "date" ].includes(column) ? types_1.DataType.DATE : void 0;
    dataset.every((data => {
        const value = data[column], numberValue = Number(value);
        return fieldType ? fieldType !== types_1.DataType.DATE || (0, common_1.validateDate)(value) ? fieldType === types_1.DataType.INT ? isNaN(numberValue) ? (fieldType = types_1.DataType.STRING, 
        !1) : ((0, calculator_1.isInteger)(numberValue) || (fieldType = types_1.DataType.FLOAT), 
        !0) : fieldType === types_1.DataType.FLOAT ? !isNaN(numberValue) || (fieldType = types_1.DataType.STRING, 
        !1) : fieldType !== types_1.DataType.STRING : (fieldType = types_1.DataType.STRING, 
        !1) : (fieldType = isNaN(numberValue) ? (0, common_1.validateDate)(value) ? types_1.DataType.DATE : types_1.DataType.STRING : (0, 
        calculator_1.isInteger)(numberValue) ? types_1.DataType.INT : types_1.DataType.FLOAT, 
        !0);
    }));
    const role = [ types_1.DataType.STRING, types_1.DataType.DATE ].includes(fieldType) ? types_1.ROLE.DIMENSION : types_1.ROLE.MEASURE, domain = (0, 
    exports.getFieldDomain)(dataset, column, role);
    return {
        fieldName: column,
        type: fieldType,
        role: role,
        domain: domain
    };
};

exports.detectFieldType = detectFieldType;

const getFieldInfo = (dataset, columns) => {
    let sampledDataset = dataset;
    return dataset.length > 1e3 && (sampledDataset = (0, common_1.sampleSize)(dataset, 1e3)), 
    columns.map((column => (0, exports.detectFieldType)(sampledDataset, column)));
};

exports.getFieldInfo = getFieldInfo;

const getFieldInfoFromDataset = dataset => {
    if (!dataset || !dataset.length) return [];
    const columns = new Set;
    return dataset.forEach((data => {
        Object.keys(data).forEach((column => {
            columns.has(column) || columns.add(column);
        }));
    })), (0, exports.getFieldInfo)(dataset, Array.from(columns));
};

exports.getFieldInfoFromDataset = getFieldInfoFromDataset;

const hasMeasureField = fieldInfo => fieldInfo.some((f => f.role === types_1.ROLE.MEASURE));

exports.hasMeasureField = hasMeasureField;

const getFieldIdInCell = cellField => (0, vutils_1.isArray)(cellField) ? cellField[0] : cellField;

exports.getFieldIdInCell = getFieldIdInCell;
//# sourceMappingURL=field.js.map