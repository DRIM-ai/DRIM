"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.transferMeasureInTable = exports.isValidDataTable = exports.foldDataTableByYField = exports.foldDatasetByYField = exports.parseCSVData = exports.convertNumberField = exports.getDataset = exports.parseCSVWithVChart = void 0;

const vdataset_1 = require("@visactor/vdataset"), field_1 = require("./field"), types_1 = require("../types"), vutils_1 = require("@visactor/vutils"), chart_advisor_1 = require("@visactor/chart-advisor"), types_2 = require("../types"), parseCSVWithVChart = csvString => {
    const dataSet = new vdataset_1.DataSet;
    dataSet.registerParser("csv", vdataset_1.csvParser), dataSet.registerTransform("fold", vdataset_1.fold);
    const dataView = new vdataset_1.DataView(dataSet, {
        name: "data"
    });
    return dataView.parse(csvString, {
        type: "csv"
    }), dataView;
};

exports.parseCSVWithVChart = parseCSVWithVChart;

const getDataset = csvString => {
    const _a = (0, exports.parseCSVWithVChart)(csvString).latestData, {columns: columns} = _a, dataColumns = __rest(_a, [ "columns" ]);
    return {
        dataset: Object.keys(dataColumns).map((key => dataColumns[key])),
        columns: columns
    };
};

exports.getDataset = getDataset;

const convertNumberField = (dataset, fieldInfo) => {
    const numberFields = fieldInfo.filter((field => [ types_1.DataType.INT, types_1.DataType.FLOAT ].includes(field.type))).map((field => field.fieldName));
    return dataset.forEach((d => {
        numberFields.forEach((numberField => {
            (0, vutils_1.isNil)(d[numberField]) || (d[numberField] = Number(d[numberField]));
        }));
    })), dataset;
};

exports.convertNumberField = convertNumberField;

const parseCSVData = csvString => {
    const {dataset: dataset, columns: columns} = (0, exports.getDataset)(csvString), fieldInfo = (0, 
    field_1.getFieldInfo)(dataset, columns);
    return (0, exports.convertNumberField)(dataset, fieldInfo), {
        fieldInfo: fieldInfo,
        dataset: dataset
    };
};

exports.parseCSVData = parseCSVData;

const foldDatasetByYField = (dataset, yFieldList, fieldInfo, foldName = chart_advisor_1.FOLD_NAME, foldValue = chart_advisor_1.FOLD_VALUE) => {
    const aliasMap = Object.fromEntries(fieldInfo.map((d => [ d.fieldName, d.fieldName ])));
    return (0, chart_advisor_1.fold)(dataset, yFieldList, foldName, foldValue, aliasMap, !1);
};

exports.foldDatasetByYField = foldDatasetByYField;

const foldDataTableByYField = (dataTable, yFieldList, fieldInfo, foldName = chart_advisor_1.FOLD_NAME, foldValue = chart_advisor_1.FOLD_VALUE) => {
    const aliasMap = Object.fromEntries(fieldInfo.map((d => [ d.fieldName, d.fieldName ])));
    return (0, chart_advisor_1.fold)(dataTable, yFieldList, foldName, foldValue, aliasMap, !1);
};

exports.foldDataTableByYField = foldDataTableByYField;

const isValidDataTable = dataTable => !(0, vutils_1.isNil)(dataTable) && (0, vutils_1.isArray)(dataTable) && dataTable.length > 0;

exports.isValidDataTable = isValidDataTable;

const transferMeasureInTable = (dataTable, fieldInfo) => {
    const newDataTable = [], measureFields = fieldInfo.filter((field => field.role === types_2.ROLE.MEASURE));
    return measureFields.length ? (dataTable.forEach((row => {
        const newRow = Object.assign({}, row);
        measureFields.forEach((field => {
            const value = Number(row[field.fieldName]);
            (0, vutils_1.isNumber)(value) && "" !== row[field.fieldName] && (newRow[field.fieldName] = value);
        })), newDataTable.push(newRow);
    })), newDataTable) : dataTable;
};

exports.transferMeasureInTable = transferMeasureInTable;
//# sourceMappingURL=dataTable.js.map