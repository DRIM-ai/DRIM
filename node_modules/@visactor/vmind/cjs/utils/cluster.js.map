{"version":3,"sources":["../src/utils/cluster.ts"],"names":[],"mappings":"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","file":"cluster.js","sourcesContent":["export interface ClusterDataItem {\n  id: string;\n  value: number[];\n}\n\nexport interface ClusterData {\n  id: number;\n  children: ClusterDataItem[];\n}\n\nexport function jaccardSimilarity(columnA: number[], columnB: number[]) {\n  if (columnA.length !== columnB.length) {\n    throw new Error('Columns must be of the same length');\n  }\n\n  let intersection = 0;\n  let union = 0;\n\n  for (let i = 0; i < columnA.length; i++) {\n    if (columnA[i] === 1 || columnB[i] === 1) {\n      union++;\n      if (columnA[i] === 1 && columnB[i] === 1) {\n        intersection++;\n      }\n    }\n  }\n\n  return intersection / union;\n}\n\nfunction calculateClusterDistance(clusterA: ClusterData, clusterB: ClusterData) {\n  let sumDistance = 0;\n\n  for (const itemA of clusterA.children) {\n    for (const itemB of clusterB.children) {\n      const distance = 1 - jaccardSimilarity(itemA.value, itemB.value);\n      sumDistance += distance;\n    }\n  }\n\n  return sumDistance / (clusterA.children.length * clusterB.children.length);\n}\n\nexport function calculateDistanceMatrix(data: ClusterData[]) {\n  const n = data.length;\n  const distanceMatrix = Array.from({ length: n }, () => Array(n).fill(0));\n  let minDistance = 1;\n  const distancePair = [0, 0];\n\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const distance = calculateClusterDistance(data[i], data[j]);\n      distanceMatrix[i][j] = distance;\n      distanceMatrix[j][i] = distance;\n      if (distance < minDistance) {\n        minDistance = distance;\n        distancePair[0] = i;\n        distancePair[1] = j;\n      }\n    }\n  }\n\n  return {\n    distanceMatrix,\n    minDistance,\n    distancePair\n  };\n}\n/**\n * Agglomerative Hierarchical Clustering, using jaccard similarity and average linkage\n * @param data\n */\nexport const agglomerativeHierarchicalClustering = (data: ClusterDataItem[], threshold: number = 0.4) => {\n  const clusters: ClusterData[] = data.map((v, i) => ({ id: i, children: [v] }));\n  const clusterMap: Map<string, number> = new Map();\n  let hasMerged = true;\n  while (hasMerged && clusters.length > 1) {\n    hasMerged = false;\n    // Initialize distances matrix and find min-distance pair\n    const { minDistance, distancePair } = calculateDistanceMatrix(clusters);\n    if (minDistance <= threshold) {\n      const mergedCluster: ClusterData = {\n        id: clusters.length,\n        children: [...clusters[distancePair[0]].children, ...clusters[distancePair[1]].children]\n      };\n      clusters.splice(distancePair[0], 1);\n      clusters.splice(distancePair[1] - 1, 1);\n      clusters.push(mergedCluster);\n      hasMerged = true;\n    }\n  }\n  clusters.forEach((v, i) => {\n    v.children.forEach(item => {\n      clusterMap.set(item.id, i);\n    });\n  });\n  return {\n    clusters,\n    clusterMap\n  };\n};\n"]}