"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getFinalQueryResult = exports.restoreDatasetAfterQuery = exports.executeDataQuery = exports.patchSQLBeforeQuery = void 0;

const alasql_1 = __importDefault(require("alasql")), utils_1 = require("./utils"), const_1 = require("./const"), patchSQLBeforeQuery = context => {
    const {sql: sql, dataTable: dataTable, fieldInfo: fieldInfo, llmFieldInfo: propsLLMFieldInfo} = context, fieldNames = fieldInfo.map((field => field.fieldName)), {validStr: validStr, sqlReplaceMap: sqlReplaceMap, columnReplaceMap: columnReplaceMap} = (0, 
    utils_1.replaceInvalidWords)(sql, fieldNames), validColumnDataset = (0, utils_1.replaceDataset)(dataTable, columnReplaceMap, !0), validDataset = (0, 
    utils_1.replaceDataset)(validColumnDataset, sqlReplaceMap, !1), replacedFieldNames = fieldNames.map((field => (0, 
    utils_1.replaceString)(field, columnReplaceMap))).map((field => (0, utils_1.replaceString)(field, sqlReplaceMap))), validSql = (0, 
    utils_1.replaceBlankSpace)(validStr, replacedFieldNames), llmFieldInfo = propsLLMFieldInfo.map((field => {
        const {fieldName: fieldName} = field, temp = (0, utils_1.replaceString)(fieldName, columnReplaceMap), validFieldName = (0, 
        utils_1.replaceString)(temp, sqlReplaceMap), matchedFieldName = replacedFieldNames.find((f => (0, 
        utils_1.matchColumnName)(validFieldName, f)));
        return Object.assign(Object.assign({}, field), {
            fieldName: null != matchedFieldName ? matchedFieldName : validFieldName
        });
    }));
    return {
        finalSql: (0, utils_1.sumAllMeasureFields)(validSql, fieldInfo, columnReplaceMap, sqlReplaceMap),
        validDataset: validDataset,
        columnReplaceMap: columnReplaceMap,
        sqlReplaceMap: sqlReplaceMap,
        llmFieldInfo: llmFieldInfo
    };
};

exports.patchSQLBeforeQuery = patchSQLBeforeQuery;

const executeDataQuery = context => {
    const {finalSql: finalSql, validDataset: validDataset} = context, sqlParts = (finalSql + " ").split(const_1.VMIND_DATA_SOURCE), sqlCount = sqlParts.length - 1, alasqlQuery = sqlParts.join("?");
    return {
        alasqlDataset: (0, alasql_1.default)(alasqlQuery, new Array(sqlCount).fill(validDataset))
    };
};

exports.executeDataQuery = executeDataQuery;

const restoreDatasetAfterQuery = context => {
    const {columnReplaceMap: columnReplaceMap, sqlReplaceMap: sqlReplaceMap, alasqlDataset: alasqlDataset, llmFieldInfo: propsLLMFieldInfo} = context, columnReversedMap = (0, 
    utils_1.swapMap)(columnReplaceMap), columnRestoredDataset = (0, utils_1.replaceDataset)(alasqlDataset, columnReversedMap, !0), sqlReversedMap = (0, 
    utils_1.swapMap)(sqlReplaceMap);
    return {
        datasetAfterQuery: (0, utils_1.replaceDataset)(columnRestoredDataset, sqlReversedMap, !1),
        llmFieldInfo: propsLLMFieldInfo.map((field => {
            const {fieldName: fieldName} = field, temp = (0, utils_1.replaceString)(fieldName, columnReversedMap), validFieldName = (0, 
            utils_1.replaceString)(temp, sqlReversedMap);
            return Object.assign(Object.assign({}, field), {
                fieldName: validFieldName
            });
        }))
    };
};

exports.restoreDatasetAfterQuery = restoreDatasetAfterQuery;

const getFinalQueryResult = context => {
    const {dataTable: sourceDataset, fieldInfo: fieldInfo, llmFieldInfo: responseFieldInfo, datasetAfterQuery: datasetAfterQuery} = context, fieldInfoNew = (0, 
    utils_1.parseRespondField)(responseFieldInfo, datasetAfterQuery);
    return 0 === datasetAfterQuery.length && console.warn("empty dataset after query!"), 
    {
        dataTable: 0 === datasetAfterQuery.length ? sourceDataset : datasetAfterQuery,
        fieldInfo: 0 === datasetAfterQuery.length ? fieldInfo : fieldInfoNew
    };
};

exports.getFinalQueryResult = getFinalQueryResult;
//# sourceMappingURL=executeQuery.js.map
