{"version":3,"sources":["../src/atom/dataQuery/executeQuery.ts"],"names":[],"mappings":"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","file":"executeQuery.js","sourcesContent":["import alasql from 'alasql';\nimport type { DataQueryCtx, DataTable, FieldInfo } from '../../types';\nimport {\n  matchColumnName,\n  parseRespondField,\n  replaceBlankSpace,\n  replaceDataset,\n  replaceInvalidWords,\n  replaceString,\n  sumAllMeasureFields,\n  swapMap\n} from './utils';\nimport { VMIND_DATA_SOURCE } from './const';\n\n/**\n * patch the errors in sql according to the feature of alasql:\n * 1. replace invalid characters such as operator, non-ascii characters and alasql keywords in sql and dataset before executing.\n * 2. sum all the non-aggregation measure columns\n * @param sourceDataset\n * @param context\n * @returns valid sql string and dataset, and the replace map\n */\ntype PatchSQLResult = {\n  finalSql: string;\n  validDataset: DataTable;\n  columnReplaceMap: Map<string, string>;\n  sqlReplaceMap: Map<string, string>;\n  llmFieldInfo: FieldInfo[];\n};\nexport const patchSQLBeforeQuery = (context: DataQueryCtx): PatchSQLResult => {\n  const { sql, dataTable, fieldInfo, llmFieldInfo: propsLLMFieldInfo } = context;\n  const fieldNames = fieldInfo.map(field => field.fieldName);\n\n  //remove invalid words in sql and get the replace map\n  const { validStr, sqlReplaceMap, columnReplaceMap } = replaceInvalidWords(sql, fieldNames);\n\n  //replace field names according to replaceMap\n  const validColumnDataset = replaceDataset(dataTable, columnReplaceMap, true);\n\n  //replace field names and data values according to replaceMap\n  const validDataset = replaceDataset(validColumnDataset, sqlReplaceMap, false);\n\n  const replacedFieldNames = fieldNames\n    .map(field => replaceString(field, columnReplaceMap))\n    .map(field => replaceString(field, sqlReplaceMap) as string);\n\n  //replace blank spaces in column name\n  const validSql = replaceBlankSpace(validStr, replacedFieldNames as string[]);\n\n  //also, replace field names in fieldInfo\n  const llmFieldInfo = propsLLMFieldInfo.map(field => {\n    const { fieldName } = field;\n    const temp = replaceString(fieldName, columnReplaceMap);\n    const validFieldName = replaceString(temp, sqlReplaceMap) as string;\n\n    const matchedFieldName = replacedFieldNames.find(f => matchColumnName(validFieldName as string, f as string));\n    return {\n      ...field,\n      fieldName: matchedFieldName ?? validFieldName\n    };\n  });\n  //sum all the non-aggregation measure columns\n  const finalSql = sumAllMeasureFields(validSql, fieldInfo, columnReplaceMap, sqlReplaceMap);\n\n  return {\n    finalSql,\n    validDataset,\n    columnReplaceMap,\n    sqlReplaceMap,\n    llmFieldInfo\n  };\n};\n\ntype QueryResult = { alasqlDataset: DataTable };\n/**\n * execute sql after patching using alasql\n * @param input\n * @param context\n * @returns dataset after executing sql query\n */\nexport const executeDataQuery = (context: PatchSQLResult) => {\n  const { finalSql, validDataset } = context;\n  //replace VMIND_DATA_SOURCE with placeholder \"?\"\n  const sqlParts = (finalSql + ' ').split(VMIND_DATA_SOURCE);\n  const sqlCount = sqlParts.length - 1;\n  const alasqlQuery = sqlParts.join('?');\n  //do the query\n  const alasqlDataset = alasql(alasqlQuery, new Array(sqlCount).fill(validDataset));\n\n  return {\n    //...context,\n    alasqlDataset\n  };\n};\n\ntype RestoreResult = {\n  datasetAfterQuery: DataTable;\n  llmFieldInfo: FieldInfo[];\n};\n/**\n * restore the dataset after query according to replace maps\n * @param input\n * @param context\n * @returns restored dataset\n */\nexport const restoreDatasetAfterQuery = (\n  context: { llmFieldInfo: FieldInfo[] } & QueryResult & PatchSQLResult\n): RestoreResult => {\n  const { columnReplaceMap, sqlReplaceMap, alasqlDataset, llmFieldInfo: propsLLMFieldInfo } = context;\n  //restore the dataset\n  const columnReversedMap = swapMap(columnReplaceMap);\n  const columnRestoredDataset = replaceDataset(alasqlDataset, columnReversedMap, true);\n  const sqlReversedMap = swapMap(sqlReplaceMap);\n  const sqlRestoredDataset = replaceDataset(columnRestoredDataset, sqlReversedMap, false);\n\n  //restore fieldMap\n  const llmFieldInfo = propsLLMFieldInfo.map(field => {\n    const { fieldName } = field;\n    const temp = replaceString(fieldName, columnReversedMap);\n    const validFieldName = replaceString(temp, sqlReversedMap) as string;\n\n    return {\n      ...field,\n      fieldName: validFieldName\n    };\n  });\n\n  return {\n    //...context,\n    datasetAfterQuery: sqlRestoredDataset,\n    llmFieldInfo\n  };\n};\n\nexport type ExecuteQueryCtx = DataQueryCtx & PatchSQLResult & QueryResult & RestoreResult;\nexport const getFinalQueryResult = (context: ExecuteQueryCtx) => {\n  const { dataTable: sourceDataset, fieldInfo, llmFieldInfo: responseFieldInfo, datasetAfterQuery } = context;\n  const fieldInfoNew = parseRespondField(responseFieldInfo, datasetAfterQuery);\n  if (datasetAfterQuery.length === 0) {\n    console.warn('empty dataset after query!');\n  }\n\n  return {\n    dataTable: datasetAfterQuery.length === 0 ? sourceDataset : datasetAfterQuery,\n    fieldInfo: datasetAfterQuery.length === 0 ? fieldInfo : fieldInfoNew\n  };\n};\n"]}