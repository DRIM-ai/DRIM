"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.extractDataFromContext = exports.extractAxesData = void 0;

const utils_1 = require("./utils"), types_1 = require("../../types"), vutils_1 = require("@visactor/vutils"), const_1 = require("./const"), field_1 = require("../../utils/field"), spec_1 = require("../../utils/spec"), utils_2 = require("../dataClean/utils"), dataTable_1 = require("../../utils/dataTable"), getDimensionDataInfo = context => {
    const {xField: xField, yField: yField, onlyOneSeries: onlyOneSeries, dataset: dataset} = context, dimensionDataMap = {}, dimensionValues = [];
    dataset.forEach(((dataItem, index) => {
        const groupBy = dataItem[xField];
        groupBy && (dimensionDataMap[groupBy] || (dimensionDataMap[groupBy] = [], dimensionValues.push(groupBy)), 
        dimensionDataMap[groupBy].push({
            index: index,
            dataItem: dataItem
        }));
    }));
    const dimensionStackSumMap = {}, dimensionSumMap = {};
    return yField.forEach((measureId => {
        dimensionStackSumMap[measureId] = [], dimensionSumMap[measureId] = dimensionValues.map((dimension => {
            const dimensionDataset = dimensionDataMap[dimension].map((d => d.dataItem));
            return dimensionStackSumMap[measureId].push((0, utils_1.sumDimensionValues)(dimensionDataset, measureId, (v => v))), 
            (0, utils_1.sumDimensionValues)(dimensionDataset, measureId, onlyOneSeries ? v => v : void 0);
        }));
    })), {
        dimensionDataMap: dimensionDataMap,
        dimensionValues: dimensionValues,
        dimensionSumMap: dimensionSumMap,
        dimensionStackSumMap: dimensionStackSumMap
    };
}, getDataBySeries = context => {
    var _a, _b;
    const {spec: spec, xField: xField, seriesField: seriesField, position: position, yField: yField} = context, {series: series = [], _vmindAxesDiffKey: _vmindAxesDiffKey = "_editor_axis_orient", data: data, axes: axes = []} = spec, currentAxis = axes.find((v => position.includes(v.orient))), axisTitle = null === (_a = null == currentAxis ? void 0 : currentAxis.title) || void 0 === _a ? void 0 : _a.text;
    let currentSeries = [], seriesIndex = null, seriesId = "";
    (null == currentAxis ? void 0 : currentAxis.seriesId) ? (seriesId = null == currentAxis ? void 0 : currentAxis.seriesId, 
    currentSeries = series.filter((s => currentAxis.seriesId.includes(s.id)))) : (null == currentAxis ? void 0 : currentAxis.seriesIndex) ? (seriesIndex = null == currentAxis ? void 0 : currentAxis.seriesIndex, 
    currentSeries = currentAxis.seriesIndex.map((v => series[v])).filter((s => !!s))) : (series.filter((s => position.includes(s[_vmindAxesDiffKey]))), 
    seriesId = (series || []).map((v => v.id)).filter((v => !!v)));
    const dataList = [];
    currentSeries.forEach((s => {
        var _a, _b, _c;
        (null === (_a = null == s ? void 0 : s.data) || void 0 === _a ? void 0 : _a.values) ? dataList.push(...s.data.values) : (null == s ? void 0 : s.dataId) ? dataList.push(...(null === (_b = data.find((subData => subData.id === s.dataId))) || void 0 === _b ? void 0 : _b.values) || []) : (0, 
        vutils_1.isValidNumber)(null == s ? void 0 : s.dataIndex) && dataList.push(...(null === (_c = null == data ? void 0 : data[s.dataIndex]) || void 0 === _c ? void 0 : _c.values) || []);
    }));
    const seriesNames = seriesField ? [ ...new Set(dataList.map((d => d[seriesField]))) ] : [];
    return Object.assign({
        dataset: dataList,
        series: currentSeries,
        seriesNames: seriesNames,
        axisTitle: axisTitle,
        seriesIndex: (0, vutils_1.isArray)(seriesIndex) ? seriesIndex[0] : seriesIndex,
        seriesId: (0, vutils_1.isArray)(seriesId) ? null == seriesId ? void 0 : seriesId[0] : seriesId,
        yField: null === (_b = null == currentSeries ? void 0 : currentSeries[0]) || void 0 === _b ? void 0 : _b.yField
    }, getDimensionDataInfo({
        xField: xField,
        yField: yField,
        onlyOneSeries: 1 === seriesNames.length,
        dataset: dataList
    }));
}, extractAxesData = context => {
    const {chartType: chartType} = context;
    return chartType !== types_1.ChartType.DualAxisChart ? {} : {
        leftAxesDataList: getDataBySeries(Object.assign(Object.assign({}, context), {
            position: [ "left" ]
        })),
        rightAxesDataList: getDataBySeries(Object.assign(Object.assign({}, context), {
            position: [ "right" ]
        }))
    };
};

exports.extractAxesData = extractAxesData;

const extractDataFromContext = context => {
    var _a;
    const {spec: spec, fieldInfo: inputFieldInfo, dataTable: dataTable, vChartType: vChartType} = context, chartType = (0, 
    spec_1.getChartTypeFromSpec)(spec, vChartType);
    if (!chartType) return console.error("unsupported spec type"), null;
    let dataset = dataTable;
    dataset && 0 !== (null == dataset ? void 0 : dataset.length) || (dataset = (0, spec_1.getDatasetFromSpec)(spec));
    const specFieldMapping = (0, spec_1.getFieldMappingFromSpec)(spec);
    let fieldInfo = inputFieldInfo;
    fieldInfo && 0 !== (null == fieldInfo ? void 0 : fieldInfo.length) || (fieldInfo = (0, 
    field_1.getFieldInfoFromDataset)(dataset)), fieldInfo = null === (_a = (0, utils_2.transferFieldInfo)({
        fieldInfo: fieldInfo
    }, specFieldMapping)) || void 0 === _a ? void 0 : _a.fieldInfo;
    const originDataset = dataset;
    dataset = (0, dataTable_1.transferMeasureInTable)(dataset, fieldInfo);
    const cell = (0, spec_1.revisedCell)((0, spec_1.getCellFromSpec)(spec, chartType), dataset), {color: color, x: cellx, y: celly} = cell, seriesField = (0, 
    vutils_1.isArray)(color) ? color[0] : color, seriesDataMap = {};
    seriesField && ![ types_1.ChartType.PieChart, types_1.ChartType.RoseChart ].includes(chartType) ? dataset.forEach(((dataItem, index) => {
        const groupBy = dataItem[seriesField];
        !groupBy || chartType === types_1.ChartType.WaterFallChart && "total" === groupBy || (seriesDataMap[groupBy] || (seriesDataMap[groupBy] = []), 
        seriesDataMap[groupBy].push({
            index: index,
            dataItem: dataItem
        }));
    })) : seriesDataMap[const_1.DEFAULT_SERIES_NAME] = dataset.map(((dataItem, index) => ({
        index: index,
        dataItem: dataItem
    })));
    const xField = (0, vutils_1.isArray)(cellx) ? cellx[0] : cellx, yField = (0, vutils_1.isArray)(celly) ? celly.flat() : [ celly ], onlyOneSeries = 1 === Object.keys(seriesDataMap).length;
    return Object.assign(Object.assign({
        dataset: dataset,
        originDataset: originDataset,
        fieldInfo: fieldInfo,
        chartType: chartType,
        seriesDataMap: seriesDataMap,
        cell: cell
    }, getDimensionDataInfo({
        xField: xField,
        yField: yField,
        onlyOneSeries: onlyOneSeries,
        dataset: dataset
    })), (0, exports.extractAxesData)({
        spec: spec,
        chartType: chartType,
        seriesField: seriesField,
        yField: yField,
        xField: xField
    }));
};

exports.extractDataFromContext = extractDataFromContext;
//# sourceMappingURL=dataProcess.js.map