"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getInsights = void 0;

const type_1 = require("../type"), abnormalTrend_1 = require("./abnormalTrend"), pearson_1 = require("./correlation/pearson"), spearman_1 = require("./correlation/spearman"), extremeValue_1 = require("./extremeValue"), majorityValue_1 = require("./majorityValue"), dbscan_1 = require("./outlier/dbscan"), lof_1 = require("./outlier/lof"), overallTrending_1 = require("./overallTrending"), turningPoint_1 = require("./turningPoint"), volatility_1 = require("./volatility"), statistics_1 = require("./outlier/statistics"), revised_1 = require("./revised"), difference_1 = require("./outlier/difference"), drift_1 = require("./drift"), template_1 = require("./template"), utils_1 = require("../utils"), baseStatistics_1 = require("./base/baseStatistics"), algorithmMapping = {
    [type_1.AlgorithmType.OverallTrending]: {
        info: overallTrending_1.OverallTrending,
        priority: 1
    },
    [type_1.AlgorithmType.AbnormalTrend]: {
        info: abnormalTrend_1.AbnormalTrend,
        priority: 2
    },
    [type_1.AlgorithmType.PearsonCorrelation]: {
        info: pearson_1.ScatterPlotCorrelation,
        priority: 3
    },
    [type_1.AlgorithmType.SpearmanCorrelation]: {
        info: spearman_1.LineChartCorrelation,
        priority: 4
    },
    [type_1.AlgorithmType.ExtremeValue]: {
        info: extremeValue_1.ExtremeValue,
        priority: 5
    },
    [type_1.AlgorithmType.MajorityValue]: {
        info: majorityValue_1.LineChartMajorityValue,
        priority: 6
    },
    [type_1.AlgorithmType.StatisticsAbnormal]: {
        info: statistics_1.StatisticsAlo,
        priority: 7
    },
    [type_1.AlgorithmType.LOFOutlier]: {
        info: lof_1.LOFOutlier,
        priority: 8
    },
    [type_1.AlgorithmType.DifferenceOutlier]: {
        info: difference_1.DifferenceAlg,
        priority: 9
    },
    [type_1.AlgorithmType.TurningPoint]: {
        info: turningPoint_1.TurningPoint,
        priority: 10
    },
    [type_1.AlgorithmType.PageHinkley]: {
        info: drift_1.PageHinkleyAlg,
        priority: 10
    },
    [type_1.AlgorithmType.DbscanOutlier]: {
        info: dbscan_1.DBSCANOutlier,
        priority: 11
    },
    [type_1.AlgorithmType.Volatility]: {
        info: volatility_1.Volatility,
        priority: 12
    },
    [type_1.AlgorithmType.StatisticsBase]: {
        info: baseStatistics_1.BaseStatistics,
        priority: 13
    }
}, InsightSortMapping = {
    [type_1.InsightType.Min]: 0,
    [type_1.InsightType.Max]: 0,
    [type_1.InsightType.Avg]: 0,
    [type_1.InsightType.Outlier]: 1,
    [type_1.InsightType.PairOutlier]: 2,
    [type_1.InsightType.AbnormalBand]: 10,
    [type_1.InsightType.ExtremeValue]: 1,
    [type_1.InsightType.TurningPoint]: 1,
    [type_1.InsightType.MajorityValue]: 1,
    [type_1.InsightType.AbnormalTrend]: 2,
    [type_1.InsightType.OverallTrend]: 2,
    [type_1.InsightType.Correlation]: 2,
    [type_1.InsightType.Volatility]: 2
}, revisedInsightByTypeMapping = {
    [type_1.InsightType.Outlier]: revised_1.mergePointInsight,
    [type_1.InsightType.PairOutlier]: null,
    [type_1.InsightType.AbnormalBand]: null,
    [type_1.InsightType.ExtremeValue]: revised_1.filterInsightByType,
    [type_1.InsightType.TurningPoint]: null,
    [type_1.InsightType.MajorityValue]: revised_1.filterInsightByType,
    [type_1.InsightType.AbnormalTrend]: revised_1.filterInsightByType,
    [type_1.InsightType.OverallTrend]: revised_1.filterInsightByType,
    [type_1.InsightType.Correlation]: revised_1.filterCorrelationInsight,
    [type_1.InsightType.Volatility]: revised_1.filterInsightByType,
    [type_1.InsightType.Min]: revised_1.filterInsightByType,
    [type_1.InsightType.Max]: revised_1.filterInsightByType,
    [type_1.InsightType.Avg]: revised_1.filterInsightByType
}, getInsights = (context, options) => {
    const {algorithms: algorithms, maxNum: maxNum, isLimitedbyChartType: isLimitedbyChartType, detailMaxNum: detailMaxNum = [], language: language} = options, {chartType: chartType, cell: cell, spec: spec, originDataset: originDataset} = context, insights = [], insightAlgorithmContext = Object.assign(Object.assign({}, context), {
        insights: insights
    }), isStack = (0, utils_1.isStackChart)(spec, chartType, cell), isPercent = (0, 
    utils_1.isPercentChart)(spec, chartType, cell);
    algorithms.sort(((a, b) => algorithmMapping[a].priority - algorithmMapping[b].priority)), 
    algorithms.forEach((key => {
        var _a;
        const algoInfo = algorithmMapping[key].info, {chartType: algoSupportedChartType, algorithmFunction: algorithmFunction, forceChartType: forceChartType, name: name, canRun: canRun, supportPercent: supportPercent, supportStack: supportStack} = algoInfo;
        if ((!forceChartType || forceChartType.includes(chartType)) && (!isLimitedbyChartType || !algoSupportedChartType || algoSupportedChartType.includes(chartType)) && (!canRun || canRun(insightAlgorithmContext)) && (isStack && !1 !== supportStack || !isStack) && (!isPercent || isPercent && !1 !== supportPercent)) {
            const res = algorithmFunction(insightAlgorithmContext, null === (_a = null == options ? void 0 : options.algorithmOptions) || void 0 === _a ? void 0 : _a[key]);
            insights.push(...res.map((v => {
                var _a;
                return Object.assign(Object.assign({}, v), {
                    data: (null === (_a = v.info) || void 0 === _a ? void 0 : _a.isAxesArea) ? v.data : (v.data || []).map((vv => ({
                        index: vv.index,
                        dataItem: originDataset[vv.index]
                    }))),
                    name: name
                });
            })));
        }
    }));
    let res = {
        insights: insights
    };
    Object.keys(revisedInsightByTypeMapping).forEach((type => {
        const revisedFunc = revisedInsightByTypeMapping[type];
        revisedFunc && (res = revisedFunc(res, type, context));
    }));
    const revisedInsights = [];
    Object.keys(revisedInsightByTypeMapping).forEach((type => {
        revisedInsights.push(...res[type]);
    })), revisedInsights.sort(((a, b) => {
        var _a, _b;
        const significant1 = null !== (_a = a.significant) && void 0 !== _a ? _a : -1, significant2 = null !== (_b = b.significant) && void 0 !== _b ? _b : -1;
        return InsightSortMapping[a.type] > InsightSortMapping[b.type] || InsightSortMapping[a.type] === InsightSortMapping[b.type] && significant2 - significant1 >= 0 ? -1 : 1;
    }));
    let afterLimitsInsights = [ ...revisedInsights ];
    detailMaxNum.forEach((item => {
        const {types: types, maxNum: maxNum} = item, filteredInsights = revisedInsights.filter((insight => types.includes(insight.type))).slice(maxNum);
        afterLimitsInsights = afterLimitsInsights.filter((insight => !filteredInsights.includes(insight)));
    }));
    return (0, template_1.generateInsightTemplate)(maxNum ? afterLimitsInsights.slice(0, maxNum) : afterLimitsInsights, context, language);
};

exports.getInsights = getInsights;
//# sourceMappingURL=index.js.map
