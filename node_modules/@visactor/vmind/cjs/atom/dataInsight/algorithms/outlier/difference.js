"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DifferenceAlg = void 0;

const vutils_1 = require("@visactor/vutils"), type_1 = require("../../type"), types_1 = require("../../../../types"), common_1 = require("../../../../utils/common"), statistics_1 = require("./statistics"), lof_1 = require("./lof"), utils_1 = require("../../utils");

function getDistanceList(dataList, isTimeSeries) {
    const res = [], n = dataList.length;
    let index = 0;
    if (isTimeSeries) for (let i = 0; i < n - 1; i++) res.push({
        index: index++,
        indexPair: [ i, i + 1 ],
        value: Math.abs(dataList[i].value - dataList[i + 1].value)
    }); else for (let i = 0; i < n - 1; i++) for (let j = i + 1; j < n; j++) {
        const distance = Math.abs(dataList[i].value - dataList[j].value);
        res.push({
            index: index++,
            indexPair: [ i, j ],
            value: distance
        });
    }
    return res;
}

const difference = (context, options) => {
    const result = [], {zScore: zScore = 3, lofThreshold: lofThreshold = 3} = options || {}, {seriesDataMap: seriesDataMap, cell: cell, fieldInfo: fieldInfo, spec: spec} = context, {y: celly, x: cellx} = cell, yField = (0, 
    vutils_1.isArray)(celly) ? celly.flat() : [ celly ], xField = (0, vutils_1.isArray)(cellx) ? cellx[0] : cellx, isTimeSeries = [ types_1.DataType.TIME, types_1.DataType.DATE ].includes(fieldInfo.find((info => info.fieldName === xField)).type);
    return Object.keys(seriesDataMap).forEach((group => {
        const dataset = seriesDataMap[group];
        yField.forEach((field => {
            const dataList = dataset.map(((d, index) => ({
                index: index,
                value: d.dataItem[field]
            })));
            if ((0, utils_1.isPercenSeries)(spec, field)) return;
            const distanceList = getDistanceList(dataList, isTimeSeries), zScoreResult = distanceList.length >= 30 ? (0, 
            statistics_1.getAbnormalByZScores)(distanceList, zScore) : null, iqrResult = distanceList.length >= 10 ? (0, 
            statistics_1.getAbnormalByIQR)(distanceList) : [], staticResult = zScoreResult ? (0, 
            common_1.getIntersection)(zScoreResult, iqrResult) : iqrResult, lofResult = (0, 
            lof_1.LOF)(distanceList.map((v => v.value)), lofThreshold).map((v => v.index));
            ((0, common_1.getIntersection)(staticResult, lofResult) || []).forEach((index => {
                const distanceItem = distanceList[index], lofInsight = {
                    type: type_1.InsightType.PairOutlier,
                    data: distanceItem.indexPair.map((v => dataset[dataList[v].index])),
                    fieldId: field,
                    value: distanceItem.value,
                    significant: 1,
                    seriesName: group
                };
                result.push(lofInsight);
            }));
        }));
    })), result;
};

exports.DifferenceAlg = {
    name: "difference",
    forceChartType: [ types_1.ChartType.DualAxisChart, types_1.ChartType.LineChart, types_1.ChartType.BarChart, types_1.ChartType.AreaChart, types_1.ChartType.WaterFallChart ],
    insightType: type_1.InsightType.PairOutlier,
    algorithmFunction: difference,
    supportPercent: !1,
    supportStack: !1
};
//# sourceMappingURL=difference.js.map
