{"version":3,"sources":["../src/atom/dataInsight/algorithms/outlier/lof.ts"],"names":[],"mappings":"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","file":"lof.js","sourcesContent":["import euclideanDistance from 'euclidean-distance';\n\nimport { isArray } from '@visactor/vutils';\nimport type { InsightAlgorithm } from '../../type';\nimport { InsightType, type DataInsightExtractContext, type Insight } from '../../type';\nimport { ChartType, type DataItem } from '../../../../types';\nimport { isPercenSeries } from '../../utils';\n\ntype knnItem = number[];\ntype KnnMap = knnItem[][];\ntype DistanceMap = number[][];\ntype LrdArray = number[];\n\n// k-Nearest Neighbors (naive)\nconst knn = (k: number, pIndex: number, distanceMap: number[][]) => {\n  const distanceArr = distanceMap[pIndex];\n  return (\n    distanceMap\n      // calculate the distance from selected index to the others\n      .map((data, index) => [index, distanceArr[index]])\n      // filter the self point\n      .filter(([index, distance]) => index !== pIndex)\n      // sort by nearest\n      .sort(([index1, distance1], [index2, distance2]) => distance1 - distance2)\n      // get the K-neighbor\n      .slice(0, k)\n  );\n};\n\n// distanceToKthNearestNeighbor\nconst kd = (knnMap: KnnMap, pIndex: number) => {\n  const kNeighbors = knnMap[pIndex];\n  const [index, distance] = kNeighbors.reduce((acc, dis) => (acc[1] > dis[1] ? acc : dis));\n  // returning the bigger distance in the neighbors\n  return distance;\n};\n\n// Reachability Distance of point p and point o (used by lrd only)\nconst rd = (knnMap: KnnMap, distanceMap: DistanceMap, pIndex: number, oIndex: number) => {\n  // getting the bigger between neighbors of current index and  distance between selected index and current index\n  return Math.max(kd(knnMap, oIndex), distanceMap[pIndex][oIndex]);\n};\n\nconst sigmaRdCalc = (nearestArray: knnItem[], knnMap: KnnMap, distanceMap: DistanceMap, pIndex: number) =>\n  nearestArray\n    // reachDistance: getting the max value between the Kth distance and the distance between selected index and current index for each item\n    .map(([oIndex, distance]) => rd(knnMap, distanceMap, pIndex, oIndex))\n    // getting the sum of reachDistances\n    .reduce((d1: number, d2: number) => d1 + d2);\n\n// Local Reachability Density of point p\nconst lrd = (pIndex: number, knnMap: KnnMap, distanceMap: DistanceMap) => {\n  // getting distances\n  const nearestArray = knnMap[pIndex];\n  const sigmaRd = sigmaRdCalc(nearestArray, knnMap, distanceMap, pIndex);\n  // was using the bigger distance in neighbors, instead I used length of pIndex neighbors (kNearestSetCount)\n  return sigmaRd - 0 <= Number.EPSILON ? 1 : nearestArray.length / sigmaRd;\n};\n\nconst onePointLOF = (dataIndex: number, knnMap: KnnMap, lrdArray: LrdArray) => {\n  //calculate the lof value of one point\n  const nearestArray = knnMap[dataIndex];\n  const sigmaLrdFraction = nearestArray\n    .map(([oIndex]) => lrdArray[oIndex] / lrdArray[dataIndex])\n    .reduce((d1, d2) => d1 + d2);\n  return sigmaLrdFraction / nearestArray.length;\n};\n\nconst autoK = (dataLength: number) => {\n  if (dataLength > 10) {\n    return 8;\n  } else if (dataLength > 4) {\n    return 4;\n  }\n  return 2;\n};\n\nexport const LOF = (dataList: number[], threshold = 3, propsK?: number) => {\n  const k = propsK || autoK(dataList.length);\n  if (k >= dataList.length) {\n    return [];\n  }\n  const distanceMap: number[][] = new Array(dataList.length).fill(0).map(d => [] as number[]);\n\n  for (let i = 0; i < dataList.length; i++) {\n    for (let j = i + 1; j < dataList.length; j++) {\n      const distance = euclideanDistance([dataList[i]], [dataList[j]]);\n      distanceMap[i][j] = distance;\n      distanceMap[j][i] = distance;\n    }\n  }\n  const knnMap = dataList.map((v, index) => {\n    const knnArr = knn(k, index, distanceMap);\n    return knnArr;\n  });\n  const lrdArr = dataList.map((v, index) => lrd(index, knnMap, distanceMap));\n  const lofArr = dataList.map((v, index) => {\n    const lof = onePointLOF(index, knnMap, lrdArr);\n    return lof;\n  });\n  return lofArr\n    .map((score, index) =>\n      score >= threshold\n        ? {\n            index,\n            score\n          }\n        : undefined\n    )\n    .filter(Boolean);\n};\n\nexport interface LOFOptions {\n  threshold?: number;\n  k?: number;\n}\n\nconst lofAlgoFunc = (context: DataInsightExtractContext, options: LOFOptions) => {\n  const result: Insight[] = [];\n  const { k, threshold = 3 } = options || {};\n  const { seriesDataMap, cell, spec } = context;\n  const { y: celly } = cell;\n  const yField: string[] = isArray(celly) ? celly.flat() : [celly];\n\n  Object.keys(seriesDataMap).forEach(group => {\n    const dataset: { index: number; dataItem: DataItem }[] = seriesDataMap[group];\n    yField.forEach(field => {\n      if (isPercenSeries(spec, field)) {\n        return;\n      }\n      const dataList = dataset.map(d => Number(d.dataItem[field]));\n      const lofArray = LOF(dataList, threshold, k);\n      lofArray.forEach(insight => {\n        const { score, index } = insight;\n        const insightDataItem = dataset[index];\n        const lofInsight: Insight = {\n          type: InsightType.Outlier,\n          data: [insightDataItem],\n          fieldId: field,\n          value: insightDataItem.dataItem[field],\n          significant: score / threshold,\n          seriesName: group\n        } as unknown as Insight;\n        result.push(lofInsight);\n      });\n    });\n  });\n  return result;\n};\n\nexport const LOFOutlier: InsightAlgorithm = {\n  name: 'lof',\n  forceChartType: [\n    ChartType.DualAxisChart,\n    ChartType.LineChart,\n    ChartType.BarChart,\n    ChartType.AreaChart,\n    ChartType.RadarChart,\n    ChartType.PieChart,\n    ChartType.RoseChart,\n    ChartType.WaterFallChart\n  ],\n  insightType: InsightType.Outlier,\n  algorithmFunction: lofAlgoFunc,\n  supportPercent: false\n};\n"]}