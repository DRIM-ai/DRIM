"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DBSCANOutlier = void 0;

const vutils_1 = require("@visactor/vutils"), density_clustering_1 = __importDefault(require("density-clustering")), array_normalize_1 = __importDefault(require("array-normalize")), type_1 = require("../../type"), types_1 = require("../../../../types"), isMeasureField = (field, fieldInfo) => {
    const fieldInfoItem = fieldInfo.find((v => v.fieldName === field));
    return fieldInfoItem && fieldInfoItem.role === types_1.ROLE.MEASURE;
}, dbscanAlgo = (context, options) => {
    const {seriesDataMap: seriesDataMap, cell: cell, fieldInfo: fieldInfo} = context, {eps: eps = .2, minPts: minPts = 5} = options || {}, {y: celly, x: cellx, color: color, size: size} = cell, yField = (0, 
    vutils_1.isArray)(celly) ? celly.flat() : [ celly ], xField = (0, vutils_1.isArray)(cellx) ? cellx[0] : cellx, allMeasureFields = [ (0, 
    vutils_1.isArray)(color) ? color[0] : color, (0, vutils_1.isArray)(size) ? size[0] : size ].filter((v => !!v && isMeasureField(v, fieldInfo))), result = [];
    return Object.keys(seriesDataMap).forEach((series => {
        const seriesDataset = seriesDataMap[series];
        if (seriesDataset.length <= minPts || seriesDataset.length < 5) return;
        const flatDataset = seriesDataset.reduce(((prev, cur) => {
            var _a, _b;
            return [ ...prev, null !== (_a = cur.dataItem[xField]) && void 0 !== _a ? _a : 0, null !== (_b = cur.dataItem[yField[0]]) && void 0 !== _b ? _b : 0, ...allMeasureFields.map((v => {
                var _a;
                return null !== (_a = cur.dataItem[v]) && void 0 !== _a ? _a : 0;
            })) ];
        }), []), dimensionCount = 2 + allMeasureFields.length, normalizedDataset = (0, array_normalize_1.default)(flatDataset, dimensionCount), clusterDataset = [];
        for (let index = 0; index < normalizedDataset.length; index += dimensionCount) {
            const item = normalizedDataset.slice(index, index + dimensionCount);
            clusterDataset.push(item);
        }
        const dbscan = new density_clustering_1.default.DBSCAN, insights = (dbscan.run(clusterDataset, eps, minPts), 
        dbscan.noise.map((noiseIndex => {
            const d = seriesDataset[noiseIndex];
            return {
                type: type_1.InsightType.Outlier,
                data: [ d ],
                fieldId: [ xField, yField[0] ],
                value: [ d.dataItem[xField], d.dataItem[yField[0]] ],
                significant: 1,
                seriesName: series
            };
        })));
        result.push(...insights);
    })), result;
};

exports.DBSCANOutlier = {
    name: "dbscan",
    chartType: [ types_1.ChartType.ScatterPlot ],
    forceChartType: [ types_1.ChartType.ScatterPlot ],
    insightType: type_1.InsightType.Outlier,
    algorithmFunction: dbscanAlgo
};
//# sourceMappingURL=dbscan.js.map
