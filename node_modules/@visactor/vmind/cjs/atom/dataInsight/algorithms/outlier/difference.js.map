{"version":3,"sources":["../src/atom/dataInsight/algorithms/outlier/difference.ts"],"names":[],"mappings":"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","file":"difference.js","sourcesContent":["/**\n * Using Z-score and IQR to detect abnormal value.\n */\nimport { isArray, uniqArray } from '@visactor/vutils';\nimport type { InsightAlgorithm } from '../../type';\nimport { InsightType, type DataInsightExtractContext, type Insight } from '../../type';\nimport { ChartType, DataType, type DataItem } from '../../../../types';\nimport { getIntersection } from '../../../../utils/common';\nimport { getAbnormalByIQR, getAbnormalByZScores, type DataPoint } from './statistics';\nimport { LOF } from './lof';\nimport { isPercenSeries } from '../../utils';\n\nfunction getDistanceList(dataList: DataPoint[], isTimeSeries: boolean) {\n  const res = [];\n  const n = dataList.length;\n  let index = 0;\n  if (!isTimeSeries) {\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = i + 1; j < n; j++) {\n        const distance = Math.abs(dataList[i].value - dataList[j].value);\n        res.push({\n          index: index++,\n          indexPair: [i, j],\n          value: distance\n        });\n      }\n    }\n  } else {\n    for (let i = 0; i < n - 1; i++) {\n      res.push({\n        index: index++,\n        indexPair: [i, i + 1],\n        value: Math.abs(dataList[i].value - dataList[i + 1].value)\n      });\n    }\n  }\n  return res;\n}\n\nexport interface DifferenceOptions {\n  zScore?: number;\n  lofThreshold?: number;\n}\n\nconst difference = (context: DataInsightExtractContext, options: DifferenceOptions) => {\n  const result: Insight[] = [];\n  const { zScore = 3, lofThreshold = 3 } = options || {};\n  const { seriesDataMap, cell, fieldInfo, spec } = context;\n  const { y: celly, x: cellx } = cell;\n  const yField: string[] = isArray(celly) ? celly.flat() : [celly];\n  const xField = isArray(cellx) ? cellx[0] : cellx;\n  const isTimeSeries = [DataType.TIME, DataType.DATE].includes(fieldInfo.find(info => info.fieldName === xField).type);\n\n  Object.keys(seriesDataMap).forEach(group => {\n    const dataset: { index: number; dataItem: DataItem }[] = seriesDataMap[group];\n    yField.forEach(field => {\n      const dataList = dataset.map((d, index) => ({\n        index: index,\n        value: d.dataItem[field] as number\n      }));\n      if (isPercenSeries(spec, field)) {\n        return;\n      }\n      const distanceList = getDistanceList(dataList, isTimeSeries);\n      const zScoreResult = distanceList.length >= 30 ? getAbnormalByZScores(distanceList, zScore) : null;\n      const iqrResult = distanceList.length >= 10 ? getAbnormalByIQR(distanceList) : [];\n      const staticResult = zScoreResult ? (getIntersection(zScoreResult, iqrResult) as number[]) : iqrResult;\n      const lofResult = LOF(\n        distanceList.map(v => v.value),\n        lofThreshold\n      ).map(v => v.index);\n      const finalRes = getIntersection(staticResult, lofResult) as number[];\n      (finalRes || []).forEach(index => {\n        const distanceItem = distanceList[index];\n        const lofInsight: Insight = {\n          type: InsightType.PairOutlier,\n          data: distanceItem.indexPair.map(v => dataset[dataList[v].index]),\n          fieldId: field,\n          value: distanceItem.value,\n          significant: 1,\n          seriesName: group\n        } as unknown as Insight;\n        result.push(lofInsight);\n      });\n    });\n  });\n  return result;\n};\n\nexport const DifferenceAlg: InsightAlgorithm = {\n  name: 'difference',\n  forceChartType: [\n    ChartType.DualAxisChart,\n    ChartType.LineChart,\n    ChartType.BarChart,\n    ChartType.AreaChart,\n    ChartType.WaterFallChart\n  ],\n  insightType: InsightType.PairOutlier,\n  algorithmFunction: difference,\n  supportPercent: false,\n  supportStack: false\n};\n"]}