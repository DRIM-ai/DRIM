{"version":3,"sources":["../src/atom/dataInsight/algorithms/drift/adwin.ts"],"names":[],"mappings":"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","file":"adwin.js","sourcesContent":["/**\n * transformer from https://github.com/blablahaha/concept-drift\n * Based on paper: Bifet and R. Gavalda. 2007. Learning from Time-Changing Data with Adaptive Windowing\n */\nimport { AdwinRowBucketList } from './bucket';\n\nexport class Adwin {\n  /** Confidence value */\n  delta: number;\n  /** Max number of buckets within one bucket row */\n  maxBuckets: number;\n  /** Min number of new data for starting to reduce window and detect change */\n  minClock: number;\n  /** Min window length for starting to reduce window and detect change */\n  minWinLen: number;\n  /** Min sub-window length, which is split from whole window */\n  minSubWinLen: number;\n\n  /** Time is used for comparison with min_clock parameter */\n  time: number;\n  /** current window length */\n  windowLen: number;\n  /** sum of all values in window */\n  windowSum: number;\n  /** Variance of all values in the window  */\n  windowVariance: number;\n\n  /** Count of bucket row within window */\n  bucketRowCount: number;\n  /** bucket list */\n  bucketRowList: AdwinRowBucketList;\n\n  constructor(delta = 0.002, maxBuckets = 5, minClock = 32, minWinLen = 10, minSubWinLen = 5) {\n    this.delta = delta;\n    this.maxBuckets = maxBuckets;\n    this.minClock = minClock;\n    this.minWinLen = minWinLen;\n    this.minSubWinLen = minSubWinLen;\n\n    this.time = 0;\n    this.windowLen = 0;\n    this.windowSum = 0;\n    this.windowVariance = 0;\n\n    this.bucketRowCount = 0;\n    this.bucketRowList = new AdwinRowBucketList(this.maxBuckets);\n  }\n\n  setInput(value: number) {\n    this.time++;\n    this.insertElement(value);\n    return this.reduceWindow();\n  }\n\n  /**\n   * Create a new bucket, and insert it into bucket row which is the head of bucket row list.\n   * Meanwhile, this bucket row maybe compressed if reaches the maximum number of buckets.\n   * @param value new stream data\n   */\n  private insertElement(value: number) {\n    this.bucketRowList.head.insertBucket(value, 0);\n    let incrementVariance = 0;\n    if (this.windowLen > 0) {\n      const mean = this.windowSum / this.windowLen;\n      incrementVariance = (this.windowLen * (value - mean) ** 2) / (this.windowLen + 1);\n    }\n    this.windowLen++;\n    this.windowVariance += incrementVariance;\n    this.windowSum += value;\n\n    this.compressBucketRow();\n  }\n\n  /** If reaches maximum number of buckets, then merge two buckets within one row into a next bucket row */\n  private compressBucketRow() {\n    let bucketRow = this.bucketRowList.head;\n    let bucketRowLevel = 0;\n\n    while (bucketRow !== null) {\n      if (bucketRow.bucketCount === this.maxBuckets + 1) {\n        let nextBucketRow = bucketRow.nextBucketRow;\n        if (nextBucketRow === null) {\n          this.bucketRowList.addToTail();\n          nextBucketRow = bucketRow.nextBucketRow;\n          this.bucketRowCount++;\n        }\n        const n1 = 2 ** bucketRowLevel;\n        const n2 = 2 ** bucketRowLevel;\n\n        const mean1 = bucketRow.bucketSum[0] / n1;\n        const mean2 = bucketRow.bucketSum[1] / n2;\n        const nextTotal = bucketRow.bucketSum[0] + bucketRow.bucketSum[1];\n        const externalVariance = (n1 * n2 * (mean1 - mean2) ** 2) / (n1 + n2);\n        const nextVariance = bucketRow.bucketVariance[0] + bucketRow.bucketVariance[1] + externalVariance;\n\n        nextBucketRow.insertBucket(nextTotal, nextVariance);\n        bucketRow.compressBucket(2);\n        if (nextBucketRow.bucketCount <= this.maxBuckets) {\n          break;\n        }\n      } else {\n        break;\n      }\n\n      bucketRow = bucketRow.nextBucketRow;\n      bucketRowLevel++;\n    }\n  }\n\n  /**  Detect a change from last of each bucket row, reduce the window if there is a concept drift. */\n  private reduceWindow() {\n    let isChanged = false;\n    if (this.time % this.minClock === 0 && this.windowLen >= this.minWinLen) {\n      let isReducedWidth = true;\n      while (isReducedWidth) {\n        isReducedWidth = false;\n        let isExit = false;\n        let n0 = 0;\n        let n1 = this.windowLen;\n        let sum0 = 0;\n        let sum1 = this.windowSum;\n\n        let bucketRow = this.bucketRowList.tail;\n        let i = this.bucketRowCount;\n        while (!isExit && !bucketRow) {\n          for (let bucketNum = 0; bucketNum < bucketRow.bucketCount; bucketNum++) {\n            if (i === 0 && bucketNum === bucketRow.bucketCount - 1) {\n              isExit = true;\n              break;\n            }\n\n            n0 += 2 ** i;\n            n1 -= 2 ** i;\n            sum0 = bucketRow.bucketSum[bucketNum];\n            sum1 -= bucketRow.bucketSum[bucketNum];\n            const diffValue = sum0 / n0 - (sum1 - n1);\n\n            if (n0 > this.minSubWinLen + 1 && n1 > this.minSubWinLen + 1) {\n              if (this.reduceExpression(n0, n1, diffValue)) {\n                isReducedWidth = true;\n                isChanged = true;\n                // eslint-disable-next-line max-depth\n                if (this.windowLen > 0) {\n                  n0 -= this.deleteElement();\n                  isExit = true;\n                  break;\n                }\n              }\n            }\n          }\n\n          bucketRow = bucketRow.previousBucketRow;\n          i--;\n        }\n      }\n    }\n    return isChanged;\n  }\n\n  private reduceExpression(n0: number, n1: number, diffValue: number) {\n    const m = 1 / (n0 - this.minSubWinLen + 1) + 1 / (n1 - this.minSubWinLen + 1);\n    const d = Math.log((2 * Math.log(this.windowLen)) / this.delta);\n    const varianceWindow = this.windowVariance / this.windowLen;\n    const epsilonCut = Math.sqrt(2 * m * varianceWindow * d) + (2 / 3) * m * d;\n    return Math.abs(diffValue) > epsilonCut;\n  }\n\n  private deleteElement() {\n    const bucketRow = this.bucketRowList.tail;\n    const deletedNumber = 2 ** this.bucketRowCount;\n    this.windowLen -= deletedNumber;\n    this.windowSum -= bucketRow.bucketSum[0];\n\n    const deletedBucketMean = bucketRow.bucketSum[0] / deletedNumber;\n    const incVariance =\n      bucketRow.bucketVariance[0] +\n      (deletedNumber * this.windowLen * Math.pow(deletedBucketMean - this.windowSum / this.windowLen, 2)) /\n        (deletedNumber + this.windowLen);\n\n    this.windowVariance -= incVariance;\n\n    bucketRow.compressBucket(1);\n    if (bucketRow.bucketCount === 0) {\n      this.bucketRowList.removeFromTail();\n      this.bucketRowCount -= 1;\n    }\n\n    return deletedNumber;\n  }\n}\n"]}