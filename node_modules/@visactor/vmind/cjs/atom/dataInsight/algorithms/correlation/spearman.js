"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LineChartCorrelation = void 0;

const vutils_1 = require("@visactor/vutils"), statistics_1 = require("../statistics"), type_1 = require("../../type"), types_1 = require("../../../../types"), spearmanAlgo = (context, options) => {
    const {seriesDataMap: seriesDataMap, cell: cell} = context, {threshold: threshold = .95} = options || {}, {y: celly} = cell, yField = (0, 
    vutils_1.isArray)(celly) ? celly.flat() : [ celly ], result = [], seriesNames = Object.keys(seriesDataMap);
    return yField.forEach((measureId => {
        for (let i = 0; i < seriesNames.length; i++) {
            const iMeasureset = seriesDataMap[seriesNames[i]].map((d => d.dataItem)).map((d => d[measureId]));
            for (let j = i + 1; j < seriesNames.length; j++) {
                const jMeasureset = seriesDataMap[seriesNames[j]].map((d => d.dataItem)).map((d => d[measureId]));
                if (iMeasureset.length !== jMeasureset.length) continue;
                const spearmanCoff = (0, statistics_1.spearmanCoefficient)(iMeasureset, jMeasureset);
                Math.abs(spearmanCoff) > threshold && result.push({
                    type: type_1.InsightType.Correlation,
                    fieldId: measureId,
                    seriesName: [ seriesNames[i], seriesNames[j] ],
                    significant: Math.abs(spearmanCoff),
                    info: {
                        correlationType: spearmanCoff > 0 ? "positive" : "negative"
                    }
                });
            }
        }
    })), result;
};

exports.LineChartCorrelation = {
    name: "spearman",
    chartType: [ types_1.ChartType.LineChart, types_1.ChartType.DualAxisChart ],
    insightType: type_1.InsightType.Correlation,
    algorithmFunction: spearmanAlgo
};
//# sourceMappingURL=spearman.js.map
