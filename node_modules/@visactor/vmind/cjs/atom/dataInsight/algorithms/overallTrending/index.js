"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.OverallTrending = exports.overallTrendingAlgo = void 0;

const vutils_1 = require("@visactor/vutils"), statistics_1 = require("../statistics"), type_1 = require("../../type"), types_1 = require("../../../../types"), utils_1 = require("../../utils"), common_1 = require("../../../../utils/common"), overallTrendingAlgo = (context, options) => {
    const {cell: cell, dimensionSumMap: dimensionSumMap, dimensionValues: dimensionValues} = context, {alpha: alpha = .05, calcScope: calcScope = !1} = options || {}, result = [], {y: celly, x: cellx} = cell, yField = (0, 
    vutils_1.isArray)(celly) ? celly.flat() : [ celly ], xField = (0, vutils_1.isArray)(cellx) ? cellx[0] : cellx;
    return yField.forEach((measureId => {
        const overallDataset = dimensionSumMap[measureId], {trend: trend, pValue: pValue, zScore: zScore, slope: slope, intercept: intercept} = (0, 
        statistics_1.originalMKTest)(overallDataset, alpha, calcScope);
        if (trend !== statistics_1.TrendType.NO_TREND) {
            const {length: length, start: start, end: end, maxTrend: maxTrend} = (0, statistics_1.longestTrendInterval)(overallDataset, trend), overallEndIndex = (0, 
            common_1.findLastIndex)(overallDataset, (v => (0, vutils_1.isValidNumber)(v))), onverallStartIndex = overallDataset.findIndex((v => (0, 
            vutils_1.isValidNumber)(v))), overallChange = 0 === overallDataset[onverallStartIndex] ? -overallDataset[overallEndIndex] : overallDataset[overallEndIndex] / overallDataset[onverallStartIndex] - 1;
            (trend === statistics_1.TrendType.INCREASING && overallChange > 0 || trend === statistics_1.TrendType.DECREASING && overallChange < 0) && result.push({
                type: type_1.InsightType.OverallTrend,
                fieldId: measureId,
                value: trend,
                significant: 1 - pValue,
                info: {
                    slope: slope,
                    intercept: intercept,
                    length: length,
                    overall: {
                        coordinates: [ {
                            [xField]: dimensionValues[onverallStartIndex],
                            [measureId]: overallDataset[onverallStartIndex]
                        }, {
                            [xField]: dimensionValues[overallEndIndex],
                            [measureId]: overallDataset[overallEndIndex]
                        } ],
                        start: onverallStartIndex,
                        end: overallEndIndex,
                        change: overallChange,
                        startValue: overallDataset[onverallStartIndex],
                        endValue: overallDataset[overallEndIndex],
                        startDimValue: dimensionValues[onverallStartIndex],
                        endDimValue: dimensionValues[overallEndIndex]
                    },
                    start: start,
                    end: end,
                    maxTrend: maxTrend,
                    change: 0 === overallDataset[start] ? -overallDataset[end] : overallDataset[end] / overallDataset[start] - 1,
                    startDimValue: dimensionValues[start],
                    endDimValue: dimensionValues[end],
                    startValue: overallDataset[start],
                    endValue: overallDataset[end]
                }
            });
        }
    })), result;
};

exports.overallTrendingAlgo = overallTrendingAlgo;

const canRun = context => {
    const {seriesDataMap: seriesDataMap, chartType: chartType, cell: cell, spec: spec} = context;
    return (0, utils_1.isStackChart)(spec, chartType, cell) && !(0, utils_1.isPercentChart)(spec, chartType, cell) || 1 === Object.keys(seriesDataMap).length;
};

exports.OverallTrending = {
    name: "overallTrending",
    forceChartType: [ types_1.ChartType.LineChart, types_1.ChartType.BarChart, types_1.ChartType.AreaChart ],
    insightType: type_1.InsightType.OverallTrend,
    canRun: canRun,
    algorithmFunction: exports.overallTrendingAlgo
};
//# sourceMappingURL=index.js.map
