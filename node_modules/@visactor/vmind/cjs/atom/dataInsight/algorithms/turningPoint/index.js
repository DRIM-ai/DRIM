"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TurningPoint = void 0;

const vutils_1 = require("@visactor/vutils"), bayesian_changepoint_1 = __importDefault(require("bayesian-changepoint")), type_1 = require("../../type"), types_1 = require("../../../../types"), utils_1 = require("../../utils"), breakpointVerifier = (next, prev) => Math.abs(next.data - prev.data) >= 1, bayesianDetection = (dataset, measureId) => {
    const measureSet = dataset.map((d => Number(d[measureId]))), detection = new bayesian_changepoint_1.default({
        breakpointVerifier: breakpointVerifier,
        chunkSize: measureSet.length,
        iteratee: d => d
    });
    detection.exec(measureSet);
    return detection.breakPoints();
}, turningPointAlgo = context => {
    const result = [], {seriesDataMap: seriesDataMap, cell: cell, spec: spec} = context, {y: celly} = cell, yField = (0, 
    vutils_1.isArray)(celly) ? celly.flat() : [ celly ];
    return Object.keys(seriesDataMap).forEach((series => {
        const seriesDataset = seriesDataMap[series];
        yField.forEach((measureId => {
            if ((0, utils_1.isPercenSeries)(spec, measureId)) return;
            bayesianDetection(seriesDataset.map((d => d.dataItem)), measureId).forEach((res => {
                const {index: index} = res, d = seriesDataset[index];
                result.push({
                    type: type_1.InsightType.TurningPoint,
                    data: [ d ],
                    fieldId: measureId,
                    seriesName: series,
                    value: d.dataItem[measureId]
                });
            }));
        }));
    })), result;
};

exports.TurningPoint = {
    name: "turningPoint",
    forceChartType: [ types_1.ChartType.DualAxisChart, types_1.ChartType.LineChart, types_1.ChartType.BarChart, types_1.ChartType.AreaChart, types_1.ChartType.WaterFallChart ],
    insightType: type_1.InsightType.TurningPoint,
    algorithmFunction: turningPointAlgo,
    supportPercent: !1
};
//# sourceMappingURL=index.js.map
