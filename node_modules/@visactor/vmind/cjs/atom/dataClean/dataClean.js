"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerDataCleanAtom = exports.DataCleanAtom = exports.pipelines = void 0;

const atom_1 = require("../../types/atom"), base_1 = require("../base"), vutils_1 = require("@visactor/vutils"), utils_1 = require("./utils"), factory_1 = require("../../core/factory");

exports.pipelines = [ {
    key: "revisedUnMatchedInfo",
    func: utils_1.revisedUnMatchedFieldInfo
}, {
    key: "rangeValueTransfer",
    func: utils_1.getCtxByRangeValueTranser
}, {
    key: "measureAutoTransfer",
    func: utils_1.getCtxBymeasureAutoTransfer
}, {
    key: "filterRowWithEmptyValues",
    func: utils_1.getCtxByFilterRowWithNonEmptyValues
}, {
    key: "filterSameDataItem",
    func: utils_1.getCtxByfilterSameDataItem
}, {
    key: "filterSameValueColumn",
    func: utils_1.getCtxByfilterSameValueColumn
}, {
    key: "needNumericalFields",
    func: utils_1.getCtxByneedNumericalFields
}, {
    key: "sortByDate",
    func: utils_1.sortDataTableByDate
} ];

class DataCleanAtom extends base_1.BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = atom_1.AtomName.DATA_CLEAN;
    }
    buildDefaultContext(context) {
        return (0, vutils_1.merge)({}, {
            dataTable: [],
            fieldInfo: []
        }, context);
    }
    buildDefaultOptions() {
        return {
            filterSameValueColumn: !0,
            needNumericalFields: !0,
            measureAutoTransfer: !0,
            filterSameDataItem: !0,
            filterRowWithEmptyValues: !0,
            rangeValueTransfer: "avg",
            hierarchicalClustering: !0
        };
    }
    updateContext(context) {
        return this.context = (0, utils_1.transferFieldInfo)(super.updateContext(context)), 
        this.context;
    }
    shouldRunByContextUpdate(context) {
        return context.dataTable !== this.context.dataTable;
    }
    _runWithOutLLM() {
        let newContext = Object.assign({}, this.context);
        return exports.pipelines.forEach((({key: key, func: func}) => {
            const currentOption = this.options[key];
            !1 !== currentOption && (newContext = func(newContext, currentOption));
        })), this.setNewContext(newContext), this.options.hierarchicalClustering && this.setNewContext((0, 
        utils_1.getSplitDataViewOfDataTable)(newContext, this.options.clusterThreshold)), 
        this.context;
    }
}

exports.DataCleanAtom = DataCleanAtom;

const registerDataCleanAtom = () => {
    factory_1.Factory.registerAtom(atom_1.AtomName.DATA_CLEAN, DataCleanAtom);
};

exports.registerDataCleanAtom = registerDataCleanAtom;
//# sourceMappingURL=dataClean.js.map