{"version":3,"sources":["../src/atom/dataClean/dataClean.ts"],"names":[],"mappings":";;;AACA,2CAA4C;AAC5C,kCAAmC;AACnC,6CAAyC;AACzC,mCAWiB;AACjB,gDAA6C;AAIhC,QAAA,SAAS,GAAiF;IAErG;QACE,GAAG,EAAE,sBAAsB;QAC3B,IAAI,EAAE,iCAAyB;KAChC;IAED;QACE,GAAG,EAAE,oBAAoB;QACzB,IAAI,EAAE,iCAAyB;KAChC;IAED;QACE,GAAG,EAAE,qBAAqB;QAC1B,IAAI,EAAE,mCAA2B;KAClC;IAED;QACE,GAAG,EAAE,0BAA0B;QAC/B,IAAI,EAAE,2CAAmC;KAC1C;IAED;QACE,GAAG,EAAE,oBAAoB;QACzB,IAAI,EAAE,kCAA0B;KACjC;IAED;QACE,GAAG,EAAE,uBAAuB;QAC5B,IAAI,EAAE,qCAA6B;KACpC;IAED;QACE,GAAG,EAAE,qBAAqB;QAC1B,IAAI,EAAE,mCAA2B;KAClC;IACD;QACE,GAAG,EAAE,YAAY;QACjB,IAAI,EAAE,2BAAmB;KAC1B;CACF,CAAC;AAEF,MAAa,aAAc,SAAQ,eAAwC;IAGzE,YAAY,OAAqB,EAAE,MAAwB;QACzD,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QAHzB,SAAI,GAAG,eAAQ,CAAC,UAAU,CAAC;IAI3B,CAAC;IAED,mBAAmB,CAAC,OAAqB;QACvC,OAAO,IAAA,cAAK,EACV,EAAE,EACF;YACE,SAAS,EAAE,EAAE;YACb,SAAS,EAAE,EAAE;SACd,EACD,OAAO,CACR,CAAC;IACJ,CAAC;IAED,mBAAmB;QACjB,OAAO;YACL,qBAAqB,EAAE,IAAI;YAC3B,mBAAmB,EAAE,IAAI;YACzB,mBAAmB,EAAE,IAAI;YACzB,kBAAkB,EAAE,IAAI;YACxB,wBAAwB,EAAE,IAAI;YAC9B,kBAAkB,EAAE,KAAK;YACzB,sBAAsB,EAAE,IAAI;SAC7B,CAAC;IACJ,CAAC;IAED,aAAa,CAAC,OAAqB;QACjC,IAAI,CAAC,OAAO,GAAG,IAAA,yBAAiB,EAAC,KAAK,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;QAC/D,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,wBAAwB,CAAC,OAAqB;QAC5C,OAAO,OAAO,CAAC,SAAS,KAAK,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC;IACtD,CAAC;IAED,cAAc;QACZ,IAAI,UAAU,qBAAQ,IAAI,CAAC,OAAO,CAAE,CAAC;QACrC,iBAAS,CAAC,OAAO,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE;YAElC,MAAM,aAAa,GAAI,IAAI,CAAC,OAAe,CAAC,GAAG,CAAC,CAAC;YACjD,IAAI,aAAa,KAAK,KAAK,EAAE;gBAC3B,UAAU,GAAG,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;aAC9C;QACH,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC/B,IAAI,IAAI,CAAC,OAAO,CAAC,sBAAsB,EAAE;YACvC,IAAI,CAAC,aAAa,CAAC,IAAA,mCAA2B,EAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC;SAC5F;QACD,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;CACF;AAtDD,sCAsDC;AAEM,MAAM,qBAAqB,GAAG,GAAG,EAAE;IACxC,iBAAO,CAAC,YAAY,CAClB,eAAQ,CAAC,UAAU,EACnB,aAA+E,CAChF,CAAC;AACJ,CAAC,CAAC;AALW,QAAA,qBAAqB,yBAKhC","file":"dataClean.js","sourcesContent":["import type { DataCleanCtx, DataCleanOptions } from '../../types';\nimport { AtomName } from '../../types/atom';\nimport { BaseAtom } from '../base';\nimport { merge } from '@visactor/vutils';\nimport {\n  getCtxByfilterSameValueColumn,\n  getCtxByneedNumericalFields,\n  getCtxBymeasureAutoTransfer,\n  getCtxByfilterSameDataItem,\n  getCtxByFilterRowWithNonEmptyValues,\n  getCtxByRangeValueTranser,\n  getSplitDataViewOfDataTable,\n  transferFieldInfo,\n  revisedUnMatchedFieldInfo,\n  sortDataTableByDate\n} from './utils';\nimport { Factory } from '../../core/factory';\nimport type { BaseAtomConstructor } from '../../types';\n/** The order of pipeline is meaningful   */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const pipelines: { key: string; func: (ctx: DataCleanCtx, ...args: any[]) => DataCleanCtx }[] = [\n  /** revised unmatched problem */\n  {\n    key: 'revisedUnMatchedInfo',\n    func: revisedUnMatchedFieldInfo\n  },\n  /** convert the interval data */\n  {\n    key: 'rangeValueTransfer',\n    func: getCtxByRangeValueTranser\n  },\n  /** Correct the measurement fields. */\n  {\n    key: 'measureAutoTransfer',\n    func: getCtxBymeasureAutoTransfer\n  },\n  /** Filter out the Row where all measurements are null. */\n  {\n    key: 'filterRowWithEmptyValues',\n    func: getCtxByFilterRowWithNonEmptyValues\n  },\n  /** Filter out completely identical rows. */\n  {\n    key: 'filterSameDataItem',\n    func: getCtxByfilterSameDataItem\n  },\n  /** Remove the fields where all dimension values are the same. */\n  {\n    key: 'filterSameValueColumn',\n    func: getCtxByfilterSameValueColumn\n  },\n  /** Need at least one valid measure field */\n  {\n    key: 'needNumericalFields',\n    func: getCtxByneedNumericalFields\n  },\n  {\n    key: 'sortByDate',\n    func: sortDataTableByDate\n  }\n];\n\nexport class DataCleanAtom extends BaseAtom<DataCleanCtx, DataCleanOptions> {\n  name = AtomName.DATA_CLEAN;\n\n  constructor(context: DataCleanCtx, option: DataCleanOptions) {\n    super(context, option);\n  }\n\n  buildDefaultContext(context: DataCleanCtx): DataCleanCtx {\n    return merge(\n      {},\n      {\n        dataTable: [],\n        fieldInfo: []\n      },\n      context\n    );\n  }\n\n  buildDefaultOptions(): DataCleanOptions {\n    return {\n      filterSameValueColumn: true,\n      needNumericalFields: true,\n      measureAutoTransfer: true,\n      filterSameDataItem: true,\n      filterRowWithEmptyValues: true,\n      rangeValueTransfer: 'avg',\n      hierarchicalClustering: true\n    };\n  }\n\n  updateContext(context: DataCleanCtx): DataCleanCtx {\n    this.context = transferFieldInfo(super.updateContext(context));\n    return this.context;\n  }\n\n  shouldRunByContextUpdate(context: DataCleanCtx): boolean {\n    return context.dataTable !== this.context.dataTable;\n  }\n\n  _runWithOutLLM(): DataCleanCtx {\n    let newContext = { ...this.context };\n    pipelines.forEach(({ key, func }) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const currentOption = (this.options as any)[key];\n      if (currentOption !== false) {\n        newContext = func(newContext, currentOption);\n      }\n    });\n    this.setNewContext(newContext);\n    if (this.options.hierarchicalClustering) {\n      this.setNewContext(getSplitDataViewOfDataTable(newContext, this.options.clusterThreshold));\n    }\n    return this.context;\n  }\n}\n\nexport const registerDataCleanAtom = () => {\n  Factory.registerAtom(\n    AtomName.DATA_CLEAN,\n    DataCleanAtom as unknown as BaseAtomConstructor<DataCleanCtx, DataCleanOptions>\n  );\n};\n"]}