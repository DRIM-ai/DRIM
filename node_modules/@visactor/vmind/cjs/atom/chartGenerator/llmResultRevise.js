"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.patchBasicHeatMapChart = exports.patchLinearProgressChart = exports.patchRangeColumnChart = exports.patchNeedSize = exports.patchNeedColor = exports.patchCartesianXField = exports.patchDynamicBarChart = exports.patchWordCloud = exports.patchPieChart = exports.patchDualAxis = exports.patchBoxPlot = exports.patchYField = exports.patchLabelField = exports.patchColorField = exports.patchAxisField = exports.patchTransposeField = exports.patchChartType = exports.getContextAfterRevised = void 0;

const chart_advisor_1 = require("@visactor/chart-advisor"), vutils_1 = require("@visactor/vutils"), field_1 = require("../../utils/field"), dataTable_1 = require("../../utils/dataTable"), text_1 = require("../../utils/text"), types_1 = require("../../types"), const_1 = require("./const"), common_1 = require("../../utils/common"), getContextAfterRevised = context => {
    const revisedFuncList = [ exports.patchChartType, exports.patchTransposeField, exports.patchAxisField, exports.patchColorField, exports.patchLabelField, exports.patchYField, exports.patchNeedColor, exports.patchNeedSize, exports.patchBoxPlot, exports.patchDualAxis, exports.patchPieChart, exports.patchWordCloud, exports.patchDynamicBarChart, exports.patchRangeColumnChart, exports.patchLinearProgressChart, exports.patchBasicHeatMapChart, exports.patchCartesianXField ];
    let newContext = Object.assign({}, context);
    return revisedFuncList.forEach((func => {
        newContext = Object.assign(Object.assign({}, newContext), func(newContext));
    })), newContext;
};

exports.getContextAfterRevised = getContextAfterRevised;

const patchChartType = context => {
    const {chartType: chartType, chartTypeList: chartTypeList} = context, chartTypeNew = (0, 
    text_1.replaceAll)((0, text_1.replaceAll)(chartType, "/", ""), "-", " ");
    return chartTypeList.includes(chartTypeNew) ? {
        chartType: chartTypeNew.toUpperCase()
    } : (console.error("Unsupported Chart Type. Please Change User Input"), {
        error: "Unsupported Chart Type. Please Change User Input"
    });
};

exports.patchChartType = patchChartType;

const patchTransposeField = context => {
    const {cell: cell, transpose: transpose, fieldInfo: fieldInfo} = context;
    if (transpose) {
        const {x: x, y: y} = cell, arrayX = (0, vutils_1.array)(x), arrayY = (0, vutils_1.array)(y), fieldMapping = fieldInfo.reduce(((prev, curv) => Object.assign(Object.assign({}, prev), {
            [curv.fieldName]: curv
        })), {});
        if (arrayX.every((field => !!fieldMapping[field] && fieldMapping[field].role === types_1.ROLE.MEASURE)) && arrayY.every((field => !!fieldMapping[field] && fieldMapping[field].role === types_1.ROLE.DIMENSION))) return Object.assign(Object.assign({}, context), {
            cell: Object.assign(Object.assign({}, cell), {
                x: y,
                y: x
            })
        });
    }
    return context;
};

exports.patchTransposeField = patchTransposeField;

const patchAxisField = context => {
    const {cell: cell} = context, cellNew = Object.assign({}, cell);
    return !cellNew.axis || cellNew.x && cellNew.y || (cellNew.x ? cellNew.y || (cellNew.y = cellNew.axis) : cellNew.x = cellNew.axis), 
    {
        cell: cellNew
    };
};

exports.patchAxisField = patchAxisField;

const patchColorField = context => {
    var _a;
    const {cell: cell} = context;
    return {
        cell: Object.assign(Object.assign({}, cell), {
            color: null !== (_a = cell.color) && void 0 !== _a ? _a : cell.category
        })
    };
};

exports.patchColorField = patchColorField;

const patchLabelField = context => {
    const {cell: cell} = context, cellNew = Object.assign({}, cell);
    return !cellNew.label || cellNew.color && 0 !== cellNew.color.length || (cellNew.color = cellNew.label), 
    {
        cell: cellNew
    };
};

exports.patchLabelField = patchLabelField;

const patchYField = context => {
    const {chartType: chartType, cell: cell, dataTable: dataTable, fieldInfo: fieldInfo} = context;
    let cellNew = Object.assign({}, cell);
    const {x: x, y: y} = cellNew;
    let chartTypeNew = chartType, datasetNew = dataTable;
    if (y && (0, vutils_1.isArray)(y) && y.length > 1) {
        if (chartTypeNew === types_1.ChartType.BoxPlot.toUpperCase() || chartTypeNew === types_1.ChartType.DualAxisChart.toUpperCase() && 2 === y.length || chartTypeNew === types_1.ChartType.RangeColumnChart.toUpperCase() && 2 === y.length) return Object.assign({}, context);
        if ((chartTypeNew === types_1.ChartType.BarChart.toUpperCase() || chartTypeNew === types_1.ChartType.LineChart.toUpperCase()) && 2 === y.length) return Object.assign(Object.assign({}, context), {
            chartType: types_1.ChartType.DualAxisChart.toUpperCase()
        });
        chartTypeNew === types_1.ChartType.BarChart.toUpperCase() || chartTypeNew === types_1.ChartType.LineChart.toUpperCase() || chartTypeNew === types_1.ChartType.DualAxisChart.toUpperCase() || chartTypeNew === types_1.ChartType.RadarChart.toUpperCase() ? (0, 
        dataTable_1.isValidDataTable)(datasetNew) && (datasetNew = (0, dataTable_1.foldDataTableByYField)(datasetNew, y, fieldInfo), 
        cellNew.y = chart_advisor_1.FOLD_VALUE.toString(), cellNew.color = chart_advisor_1.FOLD_NAME.toString()) : (chartTypeNew = types_1.ChartType.ScatterPlot.toUpperCase(), 
        cellNew = Object.assign(Object.assign({}, cell), {
            x: y[0],
            y: y[1],
            color: "string" == typeof x ? x : x[0]
        }));
    }
    return {
        chartType: chartTypeNew,
        cell: cellNew,
        dataTable: datasetNew
    };
};

exports.patchYField = patchYField;

const patchBoxPlot = context => {
    const {chartType: chartType, cell: cell} = context, cellNew = Object.assign({}, cell), {y: y} = cellNew;
    if (chartType === types_1.ChartType.BoxPlot.toUpperCase()) if ("string" == typeof y && y.split(",").length > 1) cellNew.y = y.split(",").map((str => str.trim())); else if ((0, 
    vutils_1.isNil)(y) || 0 === y.length) {
        const {lower_whisker: lower_whisker, lowerWhisker: lowerWhisker, min: min, lower: lower, lowerBox: lowerBox, lower_box: lower_box, q1: q1, lower_quartile: lower_quartile, lowerQuartile: lowerQuartile, midline: midline, median: median, q3: q3, upperBox: upperBox, upper_box: upper_box, upper_quartile: upper_quartile, upperQuartile: upperQuartile, upper_whisker: upper_whisker, upperWhisker: upperWhisker, max: max, upper: upper} = cellNew;
        cellNew.y = [ lower_whisker, lowerWhisker, min, lower, lowerBox, lower_box, q1, lower_quartile, lowerQuartile, midline, median, q3, upperBox, upper_box, upper_quartile, upperQuartile, upper_whisker, upperWhisker, max, upper ].filter(Boolean);
    }
    return {
        cell: cellNew
    };
};

exports.patchBoxPlot = patchBoxPlot;

const patchDualAxis = context => {
    const {chartType: chartType, cell: cell} = context, cellNew = Object.assign({}, cell);
    return chartType === types_1.ChartType.DualAxisChart.toUpperCase() && (cellNew.y = [ cellNew.y, cellNew.yLeft, cellNew.yRight, cellNew.y1, cellNew.y2 ].filter(Boolean).flat()), 
    {
        cell: cellNew
    };
};

exports.patchDualAxis = patchDualAxis;

const patchPieChart = context => {
    var _a, _b, _c;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo, dataTable: dataTable} = context, cellNew = Object.assign({}, cell);
    if (chartType === types_1.ChartType.RoseChart.toUpperCase() && (cellNew.angle = null !== (_b = null !== (_a = cellNew.radius) && void 0 !== _a ? _a : cellNew.size) && void 0 !== _b ? _b : cellNew.angle), 
    chartType === types_1.ChartType.PieChart.toUpperCase() || chartType === types_1.ChartType.RoseChart.toUpperCase()) {
        if (!cellNew.color || !cellNew.angle) {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo);
            if (!cellNew.color) {
                const colorField = (0, field_1.getFieldByRole)(remainedFields, types_1.ROLE.DIMENSION);
                colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_c = remainedFields[0]) || void 0 === _c ? void 0 : _c.fieldName);
            }
            if (!cellNew.angle) {
                const angleField = (0, field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.FLOAT, types_1.DataType.INT ]);
                cellNew.angle = angleField ? angleField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
            }
        }
        const colorField = (0, vutils_1.isArray)(cellNew.color) ? cellNew.color[0] : cellNew.color, angleField = (0, 
        vutils_1.isArray)(cellNew.angle) ? cellNew.angle[0] : cellNew.angle;
        if (dataTable.filter((dataItem => (0, common_1.isValidData)(dataItem[colorField]) && (0, 
        common_1.isValidData)(dataItem[angleField]) && Number(dataItem[angleField]) > 0)).length < 2) {
            const colorFieldInfo = fieldInfo.find((info => info.fieldName === colorField));
            return {
                chartType: (null == colorFieldInfo ? void 0 : colorFieldInfo.type) === types_1.DataType.DATE ? types_1.ChartType.LineChart.toUpperCase() : types_1.ChartType.BarChart.toUpperCase(),
                cell: {
                    x: colorField,
                    y: angleField
                }
            };
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchPieChart = patchPieChart;

const patchWordCloud = context => {
    var _a, _b, _c, _d, _e;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (!(chartType !== types_1.ChartType.WordCloud.toUpperCase() || cellNew.size && cellNew.color && cellNew.color !== cellNew.size)) {
        const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo);
        if (!cellNew.size || cellNew.size === cellNew.color) {
            const newSize = null !== (_a = cellNew.weight) && void 0 !== _a ? _a : cellNew.fontSize;
            if (newSize) cellNew.size = newSize; else {
                const sizeField = (0, field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.INT, types_1.DataType.FLOAT ]);
                cellNew.size = sizeField ? sizeField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
            }
        }
        if (!cellNew.color) {
            const newColor = null !== (_d = null !== (_c = null !== (_b = cellNew.text) && void 0 !== _b ? _b : cellNew.word) && void 0 !== _c ? _c : cellNew.label) && void 0 !== _d ? _d : cellNew.x;
            if (newColor) cellNew.color = newColor; else {
                const colorField = (0, field_1.getFieldByRole)(remainedFields, types_1.ROLE.DIMENSION);
                colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_e = remainedFields[0]) || void 0 === _e ? void 0 : _e.fieldName);
            }
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchWordCloud = patchWordCloud;

const patchDynamicBarChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo, dataTable: dataTable} = context, cellNew = Object.assign({}, cell);
    let chartTypeNew = chartType;
    if (chartType === types_1.ChartType.DynamicBarChart.toUpperCase() && (!cell.time || "" === cell.time || 0 === cell.time.length)) {
        const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), timeField = (0, 
        field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.DATE ]);
        if (timeField) cellNew.time = timeField.fieldName; else {
            const stringField = (0, field_1.getFieldByDataType)(remainedFields, [ types_1.DataType.STRING ]);
            stringField ? cellNew.time = stringField.fieldName : chartTypeNew = types_1.ChartType.BarChart.toUpperCase();
        }
    }
    if (cellNew.time) {
        ((0, field_1.getDataListByField)(dataTable, cellNew.time).length < 7 && !cellNew.color || cellNew.x === cellNew.time) && (chartTypeNew = cellNew.x !== cellNew.time ? types_1.ChartType.BarChart.toUpperCase() : types_1.ChartType.LineChart.toUpperCase(), 
        cellNew.color = cellNew.x !== cellNew.time ? cellNew.x : void 0, cellNew.x = cellNew.time, 
        cellNew.time = void 0);
    }
    return {
        cell: cellNew,
        chartType: chartTypeNew
    };
};

exports.patchDynamicBarChart = patchDynamicBarChart;

const patchCartesianXField = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (const_1.CARTESIAN_CHART_LIST.map((chart => chart.toUpperCase())).includes(chartType) && !cellNew.x) {
        const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), xField = (0, 
        field_1.getFieldByRole)(remainedFields, types_1.ROLE.DIMENSION);
        cellNew.x = xField ? xField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
    }
    return {
        cell: cellNew
    };
};

exports.patchCartesianXField = patchCartesianXField;

const patchNeedColor = context => {
    var _a;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (const_1.NEED_COLOR_FIELD_CHART_LIST.some((needColorFieldChartType => needColorFieldChartType.toUpperCase() === chartType)) || const_1.NEED_COLOR_AND_SIZE_CHART_LIST.some((needColorFieldChartType => needColorFieldChartType.toUpperCase() === chartType))) {
        const colorField = [ cellNew.color, cellNew.x, cellNew.label, cellNew.sets ].filter(Boolean);
        if (0 !== colorField.length) cellNew.color = colorField[0]; else {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), colorField = (0, 
            field_1.getFieldByRole)(remainedFields, types_1.ROLE.DIMENSION);
            colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_a = remainedFields[0]) || void 0 === _a ? void 0 : _a.fieldName);
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchNeedColor = patchNeedColor;

const patchNeedSize = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (const_1.NEED_SIZE_FIELD_CHART_LIST.some((needSizeFieldChartType => needSizeFieldChartType.toUpperCase() === chartType)) || const_1.NEED_COLOR_AND_SIZE_CHART_LIST.some((needSizeFieldChartType => needSizeFieldChartType.toUpperCase() === chartType))) {
        const sizeField = [ cellNew.size, cellNew.value, cellNew.y, cellNew.radius, cellNew.angle ].filter(Boolean).flat();
        if (0 !== sizeField.length) cellNew.size = sizeField[0]; else {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), sizeField = (0, 
            field_1.getFieldByRole)(remainedFields, types_1.ROLE.MEASURE);
            cellNew.size = sizeField ? sizeField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchNeedSize = patchNeedSize;

const patchRangeColumnChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell), remainedFields = (0, 
    field_1.getRemainedFields)(cellNew, fieldInfo), numericFields = (0, field_1.getFieldsByDataType)(remainedFields, [ types_1.DataType.FLOAT, types_1.DataType.INT ]);
    if (chartType === types_1.ChartType.RangeColumnChart.toUpperCase()) {
        if (cellNew.y && cellNew.y instanceof Array && 2 === cellNew.y.length) return {
            cell: cellNew
        };
        if (!(numericFields.length >= 2)) {
            const message = "The y-axis of the range column chart requires two numeric fields, but the result of data aggregation does not have two numeric fields";
            return console.error(message), {
                error: message
            };
        }
        cellNew.y = [ numericFields[0].fieldName, numericFields[1].fieldName ];
    }
    return {
        cell: cellNew
    };
};

exports.patchRangeColumnChart = patchRangeColumnChart;

const patchLinearProgressChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (chartType === types_1.ChartType.LinearProgress.toUpperCase()) {
        const xField = [ cellNew.x, cellNew.color ].filter(Boolean).flat();
        if (0 !== xField.length) cellNew.x = xField[0]; else {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), xField = (0, 
            field_1.getFieldByRole)(remainedFields, types_1.ROLE.DIMENSION);
            cellNew.x = xField ? xField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
        const yField = [ cellNew.y, cellNew.size, cellNew.value, cellNew.radius, cellNew.angle ].filter(Boolean).flat();
        if (0 !== yField.length) cellNew.y = yField[0]; else {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), yField = (0, 
            field_1.getFieldByRole)(remainedFields, types_1.ROLE.MEASURE);
            cellNew.y = yField ? yField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchLinearProgressChart = patchLinearProgressChart;

const patchBasicHeatMapChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (chartType === types_1.ChartType.BasicHeatMap.toUpperCase()) {
        const colorField = [ cellNew.x, cellNew.y, cellNew.label, cellNew.color ].filter(Boolean).flat();
        if (colorField.length >= 2) cellNew.x = colorField[0], cellNew.y = colorField[1]; else {
            const remainedFields = (0, field_1.getRemainedFields)(cellNew, fieldInfo), colorField = (0, 
            field_1.getFieldsByDataType)(remainedFields, [ types_1.DataType.STRING ]);
            colorField.length >= 2 ? (cellNew.x = colorField[0], cellNew.y = colorField[1]) : (cellNew.x = null == remainedFields ? void 0 : remainedFields[0].fieldName, 
            cellNew.y = remainedFields[1].fieldName);
        }
    }
    return {
        cell: cellNew
    };
};

exports.patchBasicHeatMapChart = patchBasicHeatMapChart;
//# sourceMappingURL=llmResultRevise.js.map