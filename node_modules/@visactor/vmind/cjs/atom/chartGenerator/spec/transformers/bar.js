"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.pipelineBar = exports.animationCartesianBar = exports.transposeField = exports.displayConfBar = exports.cartesianBar = exports.colorBar = void 0;

const base_1 = require("../../../../types/base"), field_1 = require("../../../../utils/field"), constants_1 = require("../constants"), cartesian_1 = require("./cartesian"), common_1 = require("./common"), colorBar = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context, colorThemes = constants_1.COLOR_THEMES.default;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = colorThemes.map((c => ({
        gradient: "linear",
        x0: .01,
        y0: 0,
        x1: .01,
        y1: 1,
        stops: [ {
            offset: 0,
            color: `#${c.split("#")[1]}FF`
        }, {
            offset: 1,
            color: `#${c.split("#")[1]}00`
        } ]
    })))), {
        spec: spec
    };
};

exports.colorBar = colorBar;

const cartesianBar = context => {
    const {cell: cell, fieldInfo: fieldInfo = [], spec: spec, stackOrPercent: stackOrPercent} = context, cellNew = Object.assign({}, cell), flattenedXField = Array.isArray(cell.x) ? cell.x : [ cell.x ];
    if (cell.color && cell.color.length > 0 && cell.color !== cell.x && flattenedXField.push(cell.color), 
    spec.xField = flattenedXField, spec.yField = cell.y, cell.color) spec.seriesField = cell.color; else {
        const remainedFields = fieldInfo.filter((({fieldName: fieldName}) => !spec.xField.includes(fieldName) && spec.yField !== fieldName)), colorField = (0, 
        field_1.getFieldByDataType)(remainedFields, [ base_1.DataType.STRING, base_1.DataType.DATE ]);
        colorField && (spec.seriesField = colorField.fieldName, spec.xField.push(colorField.fieldName), 
        cellNew.color = colorField.fieldName);
    }
    return spec.xField.length > 1 && stackOrPercent && (spec.xField = [ spec.xField[0] ], 
    spec.stack = !!stackOrPercent, spec.percent = "percent" === stackOrPercent), {
        spec: spec,
        cell: cellNew
    };
};

exports.cartesianBar = cartesianBar;

const displayConfBar = context => {
    const {spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (spec.bar = {
        style: {}
    }), {
        spec: spec
    };
};

exports.displayConfBar = displayConfBar;

const transposeField = context => {
    const {spec: spec, transpose: transpose} = context;
    if (transpose) {
        const newSpec = Object.assign(Object.assign({}, spec), {
            xField: spec.yField,
            yField: spec.xField,
            direction: "horizontal"
        }), bottomAxis = (newSpec.axes || []).find((axis => "bottom" === axis.orient)), leftAxis = (newSpec.axes || []).find((axis => "left" === axis.orient));
        return bottomAxis && (bottomAxis.orient = "left"), leftAxis && (leftAxis.orient = "bottom"), 
        Object.assign(Object.assign({}, context), {
            spec: newSpec
        });
    }
    return context;
};

exports.transposeField = transposeField;

const animationCartesianBar = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groupNum = spec.data.values.map((d => d[groupKey])).filter(common_1.onlyUnique).length;
    return spec.animationAppear = {
        oneByOne: Number.MIN_VALUE,
        duration: totalTime / groupNum
    }, {
        spec: spec
    };
};

exports.animationCartesianBar = animationCartesianBar, exports.pipelineBar = [ common_1.data, exports.colorBar, exports.cartesianBar, cartesian_1.seriesField, cartesian_1.axis, common_1.discreteLegend, exports.displayConfBar, exports.transposeField ];
//# sourceMappingURL=bar.js.map
