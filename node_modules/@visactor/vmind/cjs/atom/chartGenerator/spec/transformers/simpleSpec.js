"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.fomartSimpleSpec = void 0;

const vutils_1 = require("@visactor/vutils"), handleMaybeArray = (spec, handler) => (0, 
vutils_1.isArray)(spec) ? spec.map(handler) : handler(spec), combineTitle = titleSpec => {
    const titlesByOrient = {};
    titleSpec.forEach((title => {
        const {orient: orient} = title;
        titlesByOrient[orient] || (titlesByOrient[orient] = []), titlesByOrient[orient].push(title);
    }));
    const res = [];
    return Object.values(titlesByOrient).forEach((titles => {
        2 === titles.length && titles.every((title => (0, vutils_1.isNil)(title.text))) ? res.push(Object.assign(Object.assign({}, titles[0]), {
            text: titles[0].text,
            subtext: titles[1].text
        })) : titles.forEach((title => {
            res.push(title);
        }));
    })), res;
}, fomartSimpleSpec = context => {
    const {simpleVChartSpec: simpleVChartSpec, spec: spec} = context;
    if (simpleVChartSpec) {
        if (simpleVChartSpec.legends ? spec.legends = simpleVChartSpec.legends : "legends" in spec && delete spec.legends, 
        simpleVChartSpec.title ? spec.title = (0, vutils_1.isArray)(simpleVChartSpec.title) && simpleVChartSpec.title.length >= 2 ? combineTitle(simpleVChartSpec.title) : simpleVChartSpec.title : "title" in spec && delete spec.title, 
        simpleVChartSpec.axes ? spec.axes ? ((0, vutils_1.array)(simpleVChartSpec.axes).forEach((axis => {
            const {hasGrid: hasGrid, type: type, orient: orient} = axis, specAxis = spec.axes.find((a => a.type === type && a.orient === orient));
            specAxis ? specAxis.grid = Object.assign(Object.assign({}, specAxis.grid), {
                visible: hasGrid
            }) : spec.axes.push(Object.assign(Object.assign({}, axis), {
                grid: {
                    visible: hasGrid
                }
            }));
        })), spec.axes = spec.axes.filter((specAxis => simpleVChartSpec.axes.some((axis => axis.type === specAxis.type && axis.orient === specAxis.orient))))) : spec.axes = (0, 
        vutils_1.array)(simpleVChartSpec.axes).map((axis => {
            const {hasGrid: hasGrid} = axis, others = __rest(axis, [ "hasGrid" ]);
            return Object.assign(Object.assign({}, others), hasGrid ? {
                grid: {
                    visible: !0
                }
            } : {});
        })) : spec.axes && (spec.axes = spec.axes.map((axis => Object.assign(Object.assign({}, axis), {
            visible: !1
        })))), simpleVChartSpec.dataZoom ? spec.dataZoom = simpleVChartSpec.dataZoom : delete spec.dataZoom, 
        simpleVChartSpec.markPoint && (spec.markPoint = handleMaybeArray(simpleVChartSpec.markPoint, (entry => {
            const {label: label} = entry, res = __rest(entry, [ "label" ]);
            return Object.assign(Object.assign({}, res), {
                visible: !0,
                itemContent: {
                    confine: !0,
                    type: "text",
                    text: {
                        text: label
                    }
                }
            });
        }))), simpleVChartSpec.markLine && (spec.markLine = handleMaybeArray(simpleVChartSpec.markLine, (entry => {
            const {label: label} = entry, res = __rest(entry, [ "label" ]);
            return Object.assign(Object.assign({}, res), {
                visible: !0,
                label: {
                    text: entry.label
                }
            });
        }))), simpleVChartSpec.markArea && (spec.markArea = handleMaybeArray(simpleVChartSpec.markArea, (entry => {
            const {label: label} = entry, res = __rest(entry, [ "label" ]);
            return Object.assign(Object.assign({}, res), {
                visible: !0,
                label: {
                    text: entry.label
                }
            });
        }))), simpleVChartSpec.label ? spec.label = handleMaybeArray(simpleVChartSpec.label, (entry => Object.assign(Object.assign({}, entry), {
            visible: !0
        }))) : spec.label && delete spec.label, simpleVChartSpec.indicator) {
            const formatIndicator = entry => ({
                title: {
                    style: {
                        text: entry.title
                    }
                },
                content: handleMaybeArray(entry.content, (t => ({
                    style: {
                        text: t
                    }
                })))
            });
            spec.indicator = handleMaybeArray(simpleVChartSpec.indicator, formatIndicator);
        } else spec.indicator && delete spec.indicator;
        simpleVChartSpec.background && (spec.background = simpleVChartSpec.background), 
        simpleVChartSpec.palette && simpleVChartSpec.palette.length && (spec.color = simpleVChartSpec.palette);
    }
    return {
        spec: spec
    };
};

exports.fomartSimpleSpec = fomartSimpleSpec;
//# sourceMappingURL=simpleSpec.js.map
