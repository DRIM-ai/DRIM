"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.animationCartisianLine = exports.animationOneByOne = exports.oneByOneDelayFunc = exports.onlyUnique = exports.sunburstOrTreemapField = exports.indicator = exports.commonLabel = exports.color = exports.theme = exports.discreteLegend = exports.arrayData = exports.data = exports.revisedVChartType = void 0;

const chartTypeUtils_1 = require("../chartTypeUtils"), dataTable_1 = require("../../../../utils/dataTable"), const_1 = require("../../const"), constants_1 = require("../constants"), vutils_1 = require("@visactor/vutils"), field_1 = require("../../../../utils/field"), revisedVChartType = context => {
    const {chartType: chartType, spec: spec} = context;
    return spec.type = (0, chartTypeUtils_1.getVChartTypeByVmind)(chartType), {
        spec: spec
    };
};

exports.revisedVChartType = revisedVChartType;

const data = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.flat(4) : []
    }, {
        spec: spec
    };
};

exports.data = data;

const arrayData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = [ {
        id: "data",
        values: (0, dataTable_1.isValidDataTable)(dataTable) ? dataTable.flat(4) : []
    } ], {
        spec: spec
    };
};

exports.arrayData = arrayData;

const discreteLegend = context => {
    const {cell: cell, spec: spec} = context;
    return spec.legends || !cell.color && !cell.category && !spec.seriesField && "common" !== spec.type || (spec.legends = [ {
        orient: "right",
        type: "discrete",
        item: {
            visible: !0,
            background: {
                style: {}
            },
            label: {
                style: {}
            },
            shape: {
                style: {}
            }
        }
    } ]), {
        spec: spec
    };
};

exports.discreteLegend = discreteLegend;

const theme = context => {
    const {chartTheme: chartTheme, spec: spec} = context;
    return "string" == typeof chartTheme ? Object.keys(const_1.builtinThemeMap).some((key => key === chartTheme && (spec.theme = const_1.builtinThemeMap[chartTheme], 
    !0))) : "object" == typeof chartTheme && (spec.theme = chartTheme), spec.theme && spec.theme.colorScheme && (spec.color = void 0), 
    {
        spec: spec
    };
};

exports.theme = theme;

const color = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = constants_1.COLOR_THEMES.default), 
    {
        spec: spec
    };
};

exports.color = color;

const commonLabel = context => {
    const {spec: spec, fieldInfo: fieldInfo, cell: cell} = context, {y: celly} = cell;
    if (spec.label = {
        visible: !0
    }, (0, vutils_1.isArray)(celly) && celly.length > 1) ; else if (celly) {
        const field = (0, vutils_1.isArray)(celly) ? celly[0] : celly, info = fieldInfo.find((v => v.fieldName === field));
        (null == info ? void 0 : info.ratioGranularity) && (spec.label.formatter = `{${field}:~%}`);
    }
    return {
        spec: spec
    };
};

exports.commonLabel = commonLabel;

const indicator = context => {
    var _a, _b;
    const {spec: spec, cell: cell} = context, firstEntry = spec.data.values[0];
    if (!firstEntry) return {
        spec: spec
    };
    const valueField = null !== (_a = cell.value) && void 0 !== _a ? _a : cell.y, value = firstEntry[valueField], cat = firstEntry[(0, 
    field_1.getFieldIdInCell)(null !== (_b = cell.radius) && void 0 !== _b ? _b : cell.x)];
    return spec.indicator = {
        visible: !0,
        fixed: !0,
        trigger: "none",
        title: {
            visible: !0,
            autoLimit: !0,
            space: 12,
            style: {
                fontSize: 16,
                fill: "gray",
                text: null != cat ? cat : valueField
            }
        },
        content: [ {
            visible: !0,
            style: {
                fontSize: 20,
                fill: "#000",
                text: `${(100 * value).toFixed(1)}%`
            }
        } ]
    }, {
        spec: spec
    };
};

exports.indicator = indicator;

const sunburstOrTreemapField = context => {
    const {spec: spec} = context;
    return spec.categoryField = "name", spec.valueField = "value", {
        spec: spec
    };
};

function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
}

exports.sunburstOrTreemapField = sunburstOrTreemapField, exports.onlyUnique = onlyUnique;

const oneByOneDelayFunc = delay => datum => datum.__CHARTSPACE_DEFAULT_DATA_INDEX % constants_1.oneByOneGroupSize * delay;

exports.oneByOneDelayFunc = oneByOneDelayFunc;

const animationOneByOne = context => {
    var _a;
    const {spec: spec} = context;
    if ("wordCloud3d" === spec.type) return {
        spec: spec
    };
    const totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH_LONG, duration = constants_1.animationDuration, dataLength = spec.data.values.length, delay = Math.max(totalTime / dataLength - duration, 0), finalDuration = 0 === delay ? totalTime / dataLength : duration, finalDelay = 0 === delay ? Number.MIN_VALUE : delay;
    return spec.animationAppear = {
        oneByOne: finalDelay,
        duration: finalDuration
    }, {
        spec: spec
    };
};

exports.animationOneByOne = animationOneByOne;

const animationCartisianLine = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groups = spec.data.values.map((d => d[groupKey])).filter(onlyUnique), lineAnimationTotalTime = totalTime > 2e3 ? 2e3 : totalTime, pointDelay = lineAnimationTotalTime / groups.length;
    return spec.animationAppear = {
        line: {
            type: "clipIn",
            duration: lineAnimationTotalTime,
            easing: "linear"
        },
        point: {
            delay: datum => groups.findIndex((d => d === datum[groupKey])) * pointDelay
        }
    }, spec.animationNormal = {
        point: {
            loop: !0,
            timeSlices: [ {
                effects: {
                    channel: {
                        size: {
                            to: 14
                        }
                    },
                    easing: "circInOut"
                },
                duration: 1e3
            }, {
                effects: {
                    channel: {
                        size: {
                            to: 10
                        }
                    },
                    easing: "circInOut"
                },
                duration: 500
            } ]
        }
    }, {
        spec: spec
    };
};

exports.animationCartisianLine = animationCartisianLine;
//# sourceMappingURL=common.js.map
