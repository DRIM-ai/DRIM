"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.estimateVideoTime = exports.checkChartTypeAndCell = exports.getCell = exports.chartTypeMap = exports.VMindChartTypeMap = exports.typeMap = exports.getVizSchema = exports.getVChartTypeByVmind = void 0;

const vutils_1 = require("@visactor/vutils"), chart_advisor_1 = require("@visactor/chart-advisor"), types_1 = require("../../types"), constants_1 = require("./spec/constants");

var chartTypeUtils_1 = require("./spec/chartTypeUtils");

Object.defineProperty(exports, "getVChartTypeByVmind", {
    enumerable: !0,
    get: function() {
        return chartTypeUtils_1.getVChartTypeByVmind;
    }
});

const getVizSchema = context => {
    const {fieldInfo: fieldInfo} = context;
    return {
        fields: fieldInfo && fieldInfo.map((d => ({
            id: d.fieldName,
            alias: d.fieldName,
            description: d.description,
            visible: !0,
            type: d.type,
            role: d.role,
            location: d.role
        })))
    };
};

exports.getVizSchema = getVizSchema;

const typeMap = type => [ "string" ].includes(type) ? "string" : [ "date", "datetime", "time" ].includes(type) ? "date" : [ "int", "float" ].includes(type) ? "number" : "string";

exports.typeMap = typeMap, exports.VMindChartTypeMap = {
    [types_1.ChartType.BarChart]: [ chart_advisor_1.ChartType.COLUMN, chart_advisor_1.ChartType.COLUMN_PERCENT, chart_advisor_1.ChartType.COLUMN_PARALLEL, chart_advisor_1.ChartType.BAR, chart_advisor_1.ChartType.BAR_PERCENT, chart_advisor_1.ChartType.BAR_PARALLEL ],
    [types_1.ChartType.LineChart]: [ chart_advisor_1.ChartType.LINE, chart_advisor_1.ChartType.AREA, chart_advisor_1.ChartType.AREA_PERCENT ],
    [types_1.ChartType.AreaChart]: [ chart_advisor_1.ChartType.AREA, chart_advisor_1.ChartType.AREA_PERCENT ],
    [types_1.ChartType.PieChart]: [ chart_advisor_1.ChartType.PIE, chart_advisor_1.ChartType.ANNULAR ],
    [types_1.ChartType.RoseChart]: [ chart_advisor_1.ChartType.ROSE ],
    [types_1.ChartType.ScatterPlot]: [ chart_advisor_1.ChartType.SCATTER ],
    [types_1.ChartType.DualAxisChart]: [ chart_advisor_1.ChartType.DUAL_AXIS ],
    [types_1.ChartType.WordCloud]: [ chart_advisor_1.ChartType.WORD_CLOUD ],
    [types_1.ChartType.FunnelChart]: [ chart_advisor_1.ChartType.FUNNEL ],
    [types_1.ChartType.SankeyChart]: [ chart_advisor_1.ChartType.SANKEY ],
    [types_1.ChartType.RadarChart]: [ chart_advisor_1.ChartType.RADAR ]
};

const chartTypeMap = advisorChartType => {
    if ([ chart_advisor_1.ChartType.COLUMN, chart_advisor_1.ChartType.COLUMN_PERCENT, chart_advisor_1.ChartType.COLUMN_PARALLEL, chart_advisor_1.ChartType.BAR, chart_advisor_1.ChartType.BAR_PERCENT, chart_advisor_1.ChartType.BAR_PARALLEL ].includes(advisorChartType)) return "Bar Chart";
    if ([ chart_advisor_1.ChartType.LINE, chart_advisor_1.ChartType.AREA, chart_advisor_1.ChartType.AREA_PERCENT ].includes(advisorChartType)) return "Line Chart";
    if ([ chart_advisor_1.ChartType.PIE, chart_advisor_1.ChartType.ANNULAR ].includes(advisorChartType)) return "Pie Chart";
    if (chart_advisor_1.ChartType.ROSE === advisorChartType) return "Rose Chart";
    if (chart_advisor_1.ChartType.SCATTER === advisorChartType) return "Scatter Plot";
    if (chart_advisor_1.ChartType.DUAL_AXIS === advisorChartType) return "Dual Axis Chart";
    if (chart_advisor_1.ChartType.WORD_CLOUD === advisorChartType) return "Word Cloud";
    if (chart_advisor_1.ChartType.FUNNEL === advisorChartType) return "Funnel Chart";
    if (chart_advisor_1.ChartType.SANKEY === advisorChartType) return "Sankey Chart";
    if (chart_advisor_1.ChartType.RADAR === advisorChartType) return "Radar Chart";
    throw "no matched chart type " + advisorChartType;
};

exports.chartTypeMap = chartTypeMap;

const getCell = cell => {
    const keys = Object.keys(cell), result = {};
    return keys.forEach((key => {
        const channel = cell[key];
        Array.isArray(channel) && 1 === channel.length ? result[key] = String(channel[0]) : result[key] = Array.isArray(channel) ? channel.map((c => String(c))) : channel;
    })), result;
};

exports.getCell = getCell;

const checkChannel = (cell, channel, count = 1) => 1 === count && "string" == typeof cell[channel] || (!!(Array.isArray(cell[channel]) && cell[channel].length >= count) || (console.error(`cell mismatch channel '${channel}'`), 
!1)), checkChartTypeAndCell = (chartType, cell, fieldInfo) => {
    const fieldList = fieldInfo.map((f => f.fieldName));
    Object.values(cell).forEach((cellField => {
        cellField && ((0, vutils_1.isArray)(cellField) ? cellField.every((f => f && fieldList.includes(f))) || console.warn(`missing field ${cellField}`) : cellField && !fieldList.includes(cellField) && console.warn(`missing field ${cellField}`));
    }));
    let checkChannelResult = !0;
    switch (chartType) {
      case "BAR CHART":
      case "LINE CHART":
        checkChannelResult = checkChannel(cell, "x") && checkChannel(cell, "y");
        break;

      case "DUAL AXIS CHART":
        checkChannelResult = checkChannel(cell, "x") && checkChannel(cell, "y", 2);
    }
    return checkChannelResult;
};

exports.checkChartTypeAndCell = checkChartTypeAndCell;

const estimateVideoTime = (chartType, spec, parsedTime) => {
    var _a;
    if ("DYNAMIC BAR CHART" === chartType) {
        const frameNumber = spec.player.specs.length, duration = spec.player.interval;
        return {
            totalTime: null != parsedTime ? parsedTime : frameNumber * duration,
            frameArr: parsedTime ? Array.from(new Array(frameNumber).keys()).map((n => Number(parsedTime / frameNumber))) : Array.from(new Array(frameNumber).keys()).map((n => duration))
        };
    }
    return {
        totalTime: null !== (_a = null != parsedTime ? parsedTime : constants_1.VIDEO_LENGTH_BY_CHART_TYPE[{
            "PIE CHART": "pie",
            "WORD CLOUD": "wordCloud"
        }[chartType]]) && void 0 !== _a ? _a : constants_1.DEFAULT_VIDEO_LENGTH,
        frameArr: []
    };
};

exports.estimateVideoTime = estimateVideoTime;
//# sourceMappingURL=utils.js.map