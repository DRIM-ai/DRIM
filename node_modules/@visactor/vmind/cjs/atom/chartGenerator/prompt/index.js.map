{"version":3,"sources":["../src/atom/chartGenerator/prompt/index.ts"],"names":[],"mappings":";;;AAAA,6CAAmD;AACnD,6CAOsB;AACtB,kDAAwD;AAExD,0CAA2C;AAI3C,MAAM,yBAAyB,GAAG,CAChC,YAAqB,EACrB,kBAA4B,EAC5B,SAAiB,EACjB,cAAsB,EACtB,QAAgB,EAChB,cAAuB,EACvB,SAAmB,EACnB,EAAE,CAAC;;;;;;;;;;;;;;;;;GAiBF,YAAY,CAAC,CAAC,CAAC,8BAA8B,CAAC,CAAC,CAAC,EAAE;;;EAGnD,cAAc;GACb,YAAY,CAAC,CAAC,CAAC,0EAA0E,CAAC,CAAC,CAAC,EAAE,GAC/F,cAAc,CAAC,CAAC,CAAC,+DAA+D,CAAC,CAAC,CAAC,EACrF,GAAG,SAAS,CAAC,CAAC,CAAC,4CAA4C,CAAC,CAAC,CAAC,EAAE;;;;;mCAK7B,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC;;;;;;;;;EASnE,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE;EAC3C,SAAS;;;;;;;;;;EAUT,QAAQ;CACT,CAAC;AAEK,MAAM,SAAS,GAAG,CAAC,cAA2B,EAAE,eAAwB,IAAI,EAAE,EAAE;IACrF,MAAM,aAAa,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,+BAAkB,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1E,MAAM,mBAAmB,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,+BAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,+BAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAEpH,MAAM,cAAc,GAAG,mBAAmB,CAAC,MAAM,CAC/C,CAAC,GAAG,EAAE,SAAS,EAAE,EAAE;QACjB,MAAM,EAAE,SAAS,EAAE,GAAG,+BAAkB,CAAC,SAAS,CAAC,CAAC;QACpD,OAAO,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,EAAE,CAAC,CAAC,CAAC;IACxC,CAAC,EACD,CAAC,IAAA,yCAA4B,EAAC,aAAa,CAAC,EAAE,IAAA,kDAAqC,EAAC,aAAa,CAAC,CAAC,CACpG,CAAC;IAEF,MAAM,YAAY,GAAG,IAAA,wBAAe,EAAC,cAAc,CAAC,CAAC;IAErD,MAAM,cAAc,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,SAAS,EAAE,EAAE;QACnE,MAAM,EAAE,cAAc,EAAE,GAAG,+BAAkB,CAAC,SAAS,CAAC,CAAC;QACzD,OAAO,CAAC,GAAG,GAAG,EAAE,GAAG,cAAc,CAAC,CAAC;IACrC,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,MAAM,iBAAiB,GAAG,IAAA,kBAAS,EAAC,cAAc,CAAC;SAChD,GAAG,CAAC,CAAC,OAAsB,EAAE,EAAE,CAAC,IAAI,OAAO,MAAM,iCAAoB,CAAC,OAAO,CAAC,CAAC,mBAAmB,CAAC,EAAE,CAAC;SACtG,IAAI,CAAC,IAAI,CAAC,CAAC;IAEd,MAAM,cAAc,GAAG,IAAA,wBAAe,EAAC,uCAA0B,CAAC,CAAC;IAEnE,MAAM,aAAa,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,SAAS,EAAE,EAAE;QAClE,MAAM,EAAE,QAAQ,EAAE,GAAG,+BAAkB,CAAC,SAAS,CAAC,CAAC;QACnD,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QACtD,OAAO,CAAC,GAAG,GAAG,EAAE,GAAG,UAAU,CAAC,CAAC;IACjC,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,MAAM,WAAW,GAAG,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,4BAAe,CAAC,CAAC,IAAI,CAC/F,kCAAkC,CACnC,CAAC;IAEF,MAAM,kBAAkB,GAAG,yBAAyB,CAClD,YAAY,EACZ,aAAa,EACb,YAAY,EACZ,iBAAiB,EACjB,WAAW,EACX,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,iBAAS,CAAC,QAAQ,EAAE,iBAAS,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAChF,aAAa,CAAC,QAAQ,CAAC,iBAAS,CAAC,QAAQ,CAAC,CAC3C,CAAC;IACF,OAAO,kBAAkB,CAAC;AAC5B,CAAC,CAAC;AA7CW,QAAA,SAAS,aA6CpB;AAEF,MAAM,cAAc,GAAG,CAAC,SAAiB,EAAE,EAAE;IAC3C,MAAM,kBAAkB,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IACtC,MAAM,kBAAkB,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAEtC,MAAM,gBAAgB,GAAG,CAAC,IAAI,CAAC,CAAC;IAChC,MAAM,iBAAiB,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IACrD,MAAM,WAAW,GAAG,0BAA0B,CAAC;IAC/C,MAAM,QAAQ,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;QAC7D,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,WAAW,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC;IACzD,CAAC,EAAE,SAAS,CAAC,CAAC;IACd,MAAM,QAAQ,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;QACrD,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAClC,CAAC,EAAE,QAAQ,CAAC,CAAC;IACb,MAAM,WAAW,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;QAChE,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACzD,CAAC,EAAE,QAAQ,CAAC,CAAC;IAEb,IAAI,QAAQ,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;QAC5D,OAAO,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;IAC/E,CAAC,EAAE,WAAW,CAAC,CAAC;IAChB,MAAM,aAAa,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACpD,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;QAC9F,QAAQ,IAAI,GAAG,CAAC;KACjB;IACD,QAAQ;QACN,8GAA8G,CAAC;IACjH,OAAO,QAAQ,CAAC;AAClB,CAAC,CAAC;AAEK,MAAM,gBAAgB,GAAG,CAAC,KAAa,EAAE,SAAoB,EAAE,EAAE;IACtE,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;IAExC,MAAM,cAAc,GAAG,SAAS,CAAC,MAAM;SACpC,MAAM,CACL,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,CAEvB;SACA,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,mBACT,IAAA,aAAI,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,aAAa,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC,EACrD,CAAC,CAAC;IACN,OAAO,IAAI,CAAC,SAAS,CAAC;QACpB,SAAS;QACT,SAAS,EAAE,cAAc;KAC1B,CAAC,CAAC;AACL,CAAC,CAAC;AAfW,QAAA,gBAAgB,oBAe3B","file":"index.js","sourcesContent":["import { pick, uniqArray } from '@visactor/vutils';\nimport {\n  chartGenerationConstraints,\n  chartKnowledgeDict,\n  defaultExamples,\n  getCartesianCoordinateSystemKnowledge,\n  getNeedColorAndSizeKnowledge,\n  visualChannelInfoMap\n} from './knowledges';\nimport { getStrFromArray } from '../../../utils/common';\nimport type { VizSchema } from '../../../types';\nimport { ChartType } from '../../../types';\nimport type { VisualChannel } from '../type';\n\n/* eslint-disable max-len */\nconst ChartAdvisorPromptEnglish = (\n  showThoughts: boolean,\n  supportedChartList: string[],\n  knowledge: string,\n  visualChannels: string,\n  examples: string,\n  stackOrPercent: boolean,\n  transpose?: boolean\n) => `You are a data visualization expert with an in-depth understanding of visualization grammar. Your task is to provide the chart type and field visualization mapping based on the user's visualization needs and the existing field descriptions.\n# User Input\nUser Input is Bellow:\n\\`\\`\\`typescript\n{\nuserInput: string; // User visualization instructions.\nfieldInfo: { // field information\nid: string; // id of this field, also the field's name\nrole: 'measure' | 'dimension',\ntype: 'numerical' | 'ratio' | 'string' | 'date', // 'ratio' means percentage data, 'string' means regular categorical text\ndescription?: string; // description of field\n}[],\n}\n\\`\\`\\`\n# Response\nResponse in the following format:\n\\`\\`\\`\n{${showThoughts ? '\\n\"thoughts\" : your thoughts' : ''}\n\"CHART_TYPE\": string; // The chart type you choose.\n\"FIELD_MAP\": { // Visualization channel mapping results\n${visualChannels}\n}${showThoughts ? ',\\n\"Reason\": the reason for selecting the chart type and visual mapping.' : ''}${\n  stackOrPercent ? '\\n\"stackOrPercent\"?: \"stack\" | \"percent\" // default undefined' : ''\n}${transpose ? '\\n\"transpose\"?: boolean // 是否横向展示，或者是否为条形图' : ''}\n}\n\\`\\`\\`\n\n# Requirements\n1. CHART_TYPE MUST selected from ${JSON.stringify(supportedChartList)}\n2. All fields MUST be mapped to visual channels.\n3. The field names in FIELD_MAP MUST be CONSISTENT with the id in fieldInfo.\n4. The color field MUST be a dimension field\n5. The y-axis field MUST be a measure field.\n6. The x field and the time field MUST be different.\n7. Focus only on chart visualization tasks.\n8. Strictly define the type of return format, use JSON format to reply, do not include any extra content.\n9. The xy fields remain UNCHANGED even under transpose.\n${knowledge.length > 0 ? '\\n# Knowledge' : ''}\n${knowledge}\n\n# Steps\nYou should think step-by-step as follow, while ensuring all requirements are met during the process.\n1. Based on the user's input, infer the user's intention, such as comparison, ranking, trend display, proportion, distribution, etc. If user did not show their intention, just ignore and do the next steps.\n2. Select the SINGLE chart type that best suites the data from the Requirment 1.\n3. Map ALL the fields in the data to the visual channels according to user input and the chart type you choose.\n4. Check the results to ensure they meet all the requirements.\n\n# Examples\n${examples}\n`;\n\nexport const getPrompt = (propsChartList: ChartType[], showThoughts: boolean = true) => {\n  const chartTypeList = propsChartList.filter(v => !!chartKnowledgeDict[v]);\n  const sortedChartTypeList = chartTypeList.sort((a, b) => chartKnowledgeDict[a].index - chartKnowledgeDict[b].index);\n\n  const chartKnowledge = sortedChartTypeList.reduce(\n    (res, chartType) => {\n      const { knowledge } = chartKnowledgeDict[chartType];\n      return [...res, ...(knowledge ?? [])];\n    },\n    [getNeedColorAndSizeKnowledge(chartTypeList), getCartesianCoordinateSystemKnowledge(chartTypeList)]\n  );\n\n  const knowledgeStr = getStrFromArray(chartKnowledge);\n\n  const visualChannels = sortedChartTypeList.reduce((res, chartType) => {\n    const { visualChannels } = chartKnowledgeDict[chartType];\n    return [...res, ...visualChannels];\n  }, []);\n\n  const visualChannelsStr = uniqArray(visualChannels)\n    .map((channel: VisualChannel) => `\"${channel}\": ${visualChannelInfoMap[channel](sortedChartTypeList)}`)\n    .join('\\n');\n\n  const constraintsStr = getStrFromArray(chartGenerationConstraints);\n\n  const chartExamples = sortedChartTypeList.reduce((res, chartType) => {\n    const { examples } = chartKnowledgeDict[chartType];\n    const exampleStr = examples.map(e => e(showThoughts));\n    return [...res, ...exampleStr];\n  }, []);\n\n  const examplesStr = (chartExamples.length > 0 ? chartExamples.slice(0, 4) : defaultExamples).join(\n    `\\n\\n------------------------\\n\\n`\n  );\n\n  const QueryDatasetPrompt = ChartAdvisorPromptEnglish(\n    showThoughts,\n    chartTypeList,\n    knowledgeStr,\n    visualChannelsStr,\n    examplesStr,\n    !!chartTypeList.find(v => [ChartType.BarChart, ChartType.AreaChart].includes(v)),\n    chartTypeList.includes(ChartType.BarChart)\n  );\n  return QueryDatasetPrompt;\n};\n\nconst patchUserInput = (userInput: string) => {\n  const FULL_WIDTH_SYMBOLS = ['，', '。'];\n  const HALF_WIDTH_SYMBOLS = [',', '.'];\n\n  const BANNED_WORD_LIST = ['动态'];\n  const ALLOWED_WORD_LIST = ['动态条形图', '动态柱状图', '动态柱图'];\n  const PLACEHOLDER = '_USER_INPUT_PLACE_HOLDER';\n  const tempStr1 = ALLOWED_WORD_LIST.reduce((prev, cur, index) => {\n    return prev.split(cur).join(PLACEHOLDER + '_' + index);\n  }, userInput);\n  const tempStr2 = BANNED_WORD_LIST.reduce((prev, cur) => {\n    return prev.split(cur).join('');\n  }, tempStr1);\n  const replacedStr = ALLOWED_WORD_LIST.reduce((prev, cur, index) => {\n    return prev.split(PLACEHOLDER + '_' + index).join(cur);\n  }, tempStr2);\n\n  let finalStr = HALF_WIDTH_SYMBOLS.reduce((prev, cur, index) => {\n    return prev.split(HALF_WIDTH_SYMBOLS[index]).join(FULL_WIDTH_SYMBOLS[index]);\n  }, replacedStr);\n  const lastCharacter = finalStr[finalStr.length - 1];\n  if (!FULL_WIDTH_SYMBOLS.includes(lastCharacter) && !HALF_WIDTH_SYMBOLS.includes(lastCharacter)) {\n    finalStr += '。';\n  }\n  finalStr +=\n    'Use the original id in fieldInfo and DO NOT change or translate any word of the data fields in the response.';\n  return finalStr;\n};\n\nexport const revisedUserInput = (query: string, vizSchema: VizSchema) => {\n  const userInput = patchUserInput(query);\n\n  const filteredFields = vizSchema.fields\n    .filter(\n      field => field.visible\n      //usefulFields.includes(field.fieldName)\n    )\n    .map(field => ({\n      ...pick(field, ['id', 'description', 'type', 'role'])\n    }));\n  return JSON.stringify({\n    userInput,\n    fieldInfo: filteredFields\n  });\n};\n"]}