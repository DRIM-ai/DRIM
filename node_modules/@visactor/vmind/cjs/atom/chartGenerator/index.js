"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerChartGeneratorAtom = exports.ChartGeneratorAtom = void 0;

const atom_1 = require("../../types/atom"), base_1 = require("../base"), vutils_1 = require("@visactor/vutils"), const_1 = require("./const"), prompt_1 = require("./prompt"), llmResultRevise_1 = require("./llmResultRevise"), utils_1 = require("./utils"), spec_1 = require("./spec"), rule_1 = require("./rule"), advisor_1 = require("./advisor"), field_1 = require("../../utils/field"), factory_1 = require("../../core/factory");

class ChartGeneratorAtom extends base_1.BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = atom_1.AtomName.CHART_GENERATE, this.isLLMAtom = !0, 
        this._generateType = "llm", this.setFinalChartTypeList();
    }
    setFinalChartTypeList() {
        const {chartTypeList: chartTypeList, unsupportChartTypeList: unsupportChartTypeList} = this.options;
        this.finalChartTypeList = chartTypeList.filter((v => !unsupportChartTypeList.includes(v)));
    }
    buildDefaultContext(context) {
        return (0, vutils_1.merge)({}, {
            dataTable: [],
            fieldInfo: []
        }, context);
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            useChartAdvisor: !1,
            chartTypeList: const_1.SUPPORTED_CHART_LIST,
            basemapOption: const_1.DEFAULT_MAP_OPTION,
            unsupportChartTypeList: [],
            useChartRule: !1
        });
    }
    updateContext(context) {
        return this.context = super.updateContext(context), this.context.vizSchema = (0, 
        utils_1.getVizSchema)(this.context), this.context;
    }
    updateOptions(options) {
        super.updateOptions(options), this.setFinalChartTypeList();
    }
    getLLMMessages(query) {
        const {command: command} = this.context, {showThoughts: showThoughts} = this.options, addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: (0, prompt_1.getPrompt)(this.finalChartTypeList, showThoughts)
        }, {
            role: "user",
            content: (0, prompt_1.revisedUserInput)(command, this.context.vizSchema)
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {CHART_TYPE: CHART_TYPE, FIELD_MAP: FIELD_MAP, thoughts: thoughts, stackOrPercent: stackOrPercent, transpose: transpose} = resJson;
        let newContext = Object.assign(Object.assign({}, this.context), {
            thoughts: thoughts,
            chartType: CHART_TYPE,
            cell: FIELD_MAP,
            chartTypeList: this.finalChartTypeList,
            stackOrPercent: stackOrPercent,
            transpose: transpose
        });
        newContext = (0, llmResultRevise_1.getContextAfterRevised)(newContext);
        const {error: error, chartType: chartType, fieldInfo: fieldInfo, cell: cell} = newContext;
        return !error && (0, utils_1.checkChartTypeAndCell)(chartType, cell, fieldInfo) || (console.warn("LLM generation error, use rule generation."), 
        delete newContext.error, delete newContext.message), newContext;
    }
    runBeforeLLM() {
        const {dataTable: dataTable, fieldInfo: fieldInfo, simpleVChartSpec: simpleVChartSpec} = this.context;
        if (simpleVChartSpec) {
            this.isLLMAtom = !1, this._generateType = "simpleSpec";
            const {ctx: ctx, mockLLMContent: mockLLMContent} = (0, rule_1.getCellContextBySimpleVChartSpec)(simpleVChartSpec);
            this.updateContext(ctx), this.updateContext(this.parseLLMContent(mockLLMContent));
        } else {
            if (fieldInfo && 0 !== fieldInfo.length || this.updateContext({
                fieldInfo: (0, field_1.getFieldInfoFromDataset)(dataTable)
            }), (dataTable.length > 1 || !this.options.useChartRule) && !simpleVChartSpec) return this._generateType = this.options.useChartAdvisor ? "chartAdvistor" : "llm", 
            this.isLLMAtom = "llm" === this._generateType, this.context;
            this.isLLMAtom = !1, this._generateType = "rule";
            const ruleResJson = (0, rule_1.getRuleLLMContent)(this.context);
            ruleResJson ? this.updateContext(this.parseLLMContent(ruleResJson)) : this.updateContext({
                cell: null
            });
        }
        return this.context;
    }
    runWithLLMError(error) {
        return super._runWithOutLLM(), this._generateType = "chartAdvistor", this._runWithOutLLM();
    }
    _runWithOutLLM() {
        var _a, _b, _c, _d;
        if (this.isLLMAtom = !0, "rule" === this._generateType && !this.context.cell) return this.context.spec = null, 
        this.context;
        const additionalCtx = {
            chartTypeList: this.finalChartTypeList,
            basemapOption: null === (_a = this.options) || void 0 === _a ? void 0 : _a.basemapOption,
            totalTime: null === (_b = this.options) || void 0 === _b ? void 0 : _b.animationDuration,
            colors: null === (_c = this.options) || void 0 === _c ? void 0 : _c.colorPalette,
            chartTheme: null === (_d = this.options) || void 0 === _d ? void 0 : _d.theme
        };
        if ("chartAdvistor" === this._generateType || this.options.useChartAdvisor) {
            const {cell: cell, dataset: dataset, chartType: chartType, advisedList: advisedList, usage: usage} = (0, 
            advisor_1.getCellContextByAdvisor)(Object.assign(Object.assign({}, this.context), additionalCtx));
            this.context = Object.assign(Object.assign({}, this.context), {
                usage: usage,
                cell: cell,
                dataTable: dataset,
                chartType: chartType,
                chartAdvistorRes: advisedList.map((item => {
                    const tmpContext = (0, vutils_1.merge)({}, this.context, {
                        cell: item.cell,
                        dataTable: item.dataset,
                        chartType: item.chartType
                    });
                    return {
                        chartType: item.chartType,
                        score: item.score,
                        spec: (0, spec_1.getChartSpecWithContext)(Object.assign(Object.assign({}, tmpContext), additionalCtx)).spec
                    };
                }))
            });
        } else this.context.chartAdvistorRes = [];
        const newContext = Object.assign(Object.assign({}, this.context), (0, spec_1.getChartSpecWithContext)(Object.assign(Object.assign({}, this.context), additionalCtx)));
        return this.updateContext(newContext), newContext;
    }
}

exports.ChartGeneratorAtom = ChartGeneratorAtom;

const registerChartGeneratorAtom = () => {
    factory_1.Factory.registerAtom(atom_1.AtomName.CHART_GENERATE, ChartGeneratorAtom);
};

exports.registerChartGeneratorAtom = registerChartGeneratorAtom;
//# sourceMappingURL=index.js.map