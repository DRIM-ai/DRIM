import { isArray, uniqArray } from "@visactor/vutils";

import { DataType, ROLE } from "../types";

import { sampleSize, validateDate } from "./common";

import { isInteger } from "@visactor/calculator";

export const getRoleByFieldType = type => [ DataType.DATE, DataType.TIME, DataType.STRING, DataType.REGION ].includes(type) ? ROLE.DIMENSION : ROLE.MEASURE;

export const formatFieldInfo = fieldInfo => (fieldInfo.forEach((info => {
    info.role = getRoleByFieldType(info.type), info.location = getRoleByFieldType(info.type), 
    info.ratioGranularity = (null == info ? void 0 : info.type) === DataType.RATIO ? (null == info ? void 0 : info.ratioGranularity) || "%" : null;
})), fieldInfo);

export const getDataListByField = (dataset, fieldName) => uniqArray(dataset.map((d => d[fieldName])));

export const getRemainedFields = (cell, fieldInfo) => {
    const usedFields = Object.values(cell).flat();
    return fieldInfo.filter((f => !usedFields.includes(f.fieldName)));
};

export const getFieldByRole = (fields, role) => fields.find((f => f.role === role));

export const getFieldByDataType = (fields, dataTypeList) => (fields || []).find((f => dataTypeList.includes(f.type)));

export const getFieldsByDataType = (fields, dataTypeList) => fields.filter((f => dataTypeList.includes(f.type)));

export const getFieldDomain = (dataset, column, role) => {
    const domain = dataset.map((d => role === ROLE.DIMENSION ? d[column] : Number(d[column])));
    return role === ROLE.DIMENSION ? uniqArray(domain).slice(0, 20) : [ Math.min(...domain), Math.max(...domain) ];
};

export const detectFieldType = (dataset, column) => {
    let fieldType = [ "年份", "date" ].includes(column) ? DataType.DATE : void 0;
    dataset.every((data => {
        const value = data[column], numberValue = Number(value);
        return fieldType ? fieldType !== DataType.DATE || validateDate(value) ? fieldType === DataType.INT ? isNaN(numberValue) ? (fieldType = DataType.STRING, 
        !1) : (isInteger(numberValue) || (fieldType = DataType.FLOAT), !0) : fieldType === DataType.FLOAT ? !isNaN(numberValue) || (fieldType = DataType.STRING, 
        !1) : fieldType !== DataType.STRING : (fieldType = DataType.STRING, !1) : (fieldType = isNaN(numberValue) ? validateDate(value) ? DataType.DATE : DataType.STRING : isInteger(numberValue) ? DataType.INT : DataType.FLOAT, 
        !0);
    }));
    const role = [ DataType.STRING, DataType.DATE ].includes(fieldType) ? ROLE.DIMENSION : ROLE.MEASURE, domain = getFieldDomain(dataset, column, role);
    return {
        fieldName: column,
        type: fieldType,
        role: role,
        domain: domain
    };
};

export const getFieldInfo = (dataset, columns) => {
    let sampledDataset = dataset;
    return dataset.length > 1e3 && (sampledDataset = sampleSize(dataset, 1e3)), columns.map((column => detectFieldType(sampledDataset, column)));
};

export const getFieldInfoFromDataset = dataset => {
    if (!dataset || !dataset.length) return [];
    const columns = new Set;
    return dataset.forEach((data => {
        Object.keys(data).forEach((column => {
            columns.has(column) || columns.add(column);
        }));
    })), getFieldInfo(dataset, Array.from(columns));
};

export const hasMeasureField = fieldInfo => fieldInfo.some((f => f.role === ROLE.MEASURE));

export const getFieldIdInCell = cellField => isArray(cellField) ? cellField[0] : cellField;
//# sourceMappingURL=field.js.map