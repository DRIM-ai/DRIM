{"version":3,"sources":["../src/utils/json.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,OAAO,EAAE,UAAU,EAAE,MAAM,YAAY,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AAEpC,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,GAAW,EAAE,EAAE;IAC1C,MAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IAC/B,MAAM,IAAI,GAAG,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IAClC,MAAM,MAAM,GAAG,GAAG,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;IAC9C,OAAO,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AAC3E,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,GAAW,EAAE,EAAE;IAC5C,IAAI,GAAG,GAAG,GAAG,CAAC;IACd,IAAI,GAAG,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;QAC/B,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;KACjD;IACD,IAAI,GAAG,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE;QAChC,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;KAClD;IACD,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,OAAe,EAAE,MAAe,EAAE,EAAE;IAC/D,MAAM,gBAAgB,GAAG,CAAC,GAAW,EAAE,EAAE;QACvC,IAAI;YACF,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SACzB;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI;gBACF,OAAO,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;aACrC;YAAC,OAAO,GAAG,EAAE;gBACZ,OAAO;oBACL,KAAK,EAAE,0CAA0C,OAAO,EAAE;oBAC1D,SAAS,EAAE,GAAG;iBACf,CAAC;aACH;SACF;IACH,CAAC,CAAC;IACF,IAAI,MAAM,EAAE;QACV,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QACvC,MAAM,WAAW,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAClD,MAAM,GAAG,GAAG,gBAAgB,CAAC,WAAW,CAAC,CAAC;QAC1C,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE;YACd,OAAO,GAAG,CAAC;SACZ;KACF;IACD,MAAM,IAAI,GAAG,gBAAgB,CAAC,OAAO,CAAC,CAAC;IACvC,IAAI,IAAI,CAAC,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KAC/B;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC","file":"json.js","sourcesContent":["import JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { replaceAll } from './text';\n\nexport const matchJSONStr = (str: string) => {\n  const first = str.indexOf('{');\n  const last = str.lastIndexOf('}');\n  const result = str.substring(first, last + 1);\n  return result && result.length > 0 ? replaceAll(result, '\\n', ' ') : str;\n};\n\nexport const revisedJSONStr = (str: string) => {\n  let res = str;\n  if (str.includes('\"unit\":\"%\"\"')) {\n    res = res.replaceAll('\"unit\":\"%\"\"', \"unit:'%'\");\n  }\n  if (str.includes('\"unit\": \"%\"\"')) {\n    res = res.replaceAll('\"unit\": \"%\"\"', \"unit:'%'\");\n  }\n  return res;\n};\n\nexport const parseLLMJson = (JsonStr: string, prefix?: string) => {\n  const parseNoPrefixStr = (str: string) => {\n    try {\n      return JSON5.parse(str);\n    } catch (err) {\n      try {\n        return JSON5.parse(jsonrepair(str));\n      } catch (err) {\n        return {\n          error: `LLM Result is not Valid JSON; llm res: ${JsonStr}`,\n          errorInfo: err\n        };\n      }\n    }\n  };\n  if (prefix) {\n    const splitArr = JsonStr.split(prefix);\n    const splittedStr = splitArr[splitArr.length - 2];\n    const res = parseNoPrefixStr(splittedStr);\n    if (!res.error) {\n      return res;\n    }\n  }\n  const res2 = parseNoPrefixStr(JsonStr);\n  if (res2.error) {\n    console.error(res2.errorInfo);\n  }\n  return res2;\n};\n"]}