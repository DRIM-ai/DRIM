var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { DataSet, DataView, csvParser, fold as vdatasetFold } from "@visactor/vdataset";

import { getFieldInfo } from "./field";

import { DataType } from "../types";

import { isArray, isNil, isNumber } from "@visactor/vutils";

import { FOLD_NAME, FOLD_VALUE, fold } from "@visactor/chart-advisor";

import { ROLE } from "../types";

export const parseCSVWithVChart = csvString => {
    const dataSet = new DataSet;
    dataSet.registerParser("csv", csvParser), dataSet.registerTransform("fold", vdatasetFold);
    const dataView = new DataView(dataSet, {
        name: "data"
    });
    return dataView.parse(csvString, {
        type: "csv"
    }), dataView;
};

export const getDataset = csvString => {
    const _a = parseCSVWithVChart(csvString).latestData, {columns: columns} = _a, dataColumns = __rest(_a, [ "columns" ]);
    return {
        dataset: Object.keys(dataColumns).map((key => dataColumns[key])),
        columns: columns
    };
};

export const convertNumberField = (dataset, fieldInfo) => {
    const numberFields = fieldInfo.filter((field => [ DataType.INT, DataType.FLOAT ].includes(field.type))).map((field => field.fieldName));
    return dataset.forEach((d => {
        numberFields.forEach((numberField => {
            isNil(d[numberField]) || (d[numberField] = Number(d[numberField]));
        }));
    })), dataset;
};

export const parseCSVData = csvString => {
    const {dataset: dataset, columns: columns} = getDataset(csvString), fieldInfo = getFieldInfo(dataset, columns);
    return convertNumberField(dataset, fieldInfo), {
        fieldInfo: fieldInfo,
        dataset: dataset
    };
};

export const foldDatasetByYField = (dataset, yFieldList, fieldInfo, foldName = FOLD_NAME, foldValue = FOLD_VALUE) => {
    const aliasMap = Object.fromEntries(fieldInfo.map((d => [ d.fieldName, d.fieldName ])));
    return fold(dataset, yFieldList, foldName, foldValue, aliasMap, !1);
};

export const foldDataTableByYField = (dataTable, yFieldList, fieldInfo, foldName = FOLD_NAME, foldValue = FOLD_VALUE) => {
    const aliasMap = Object.fromEntries(fieldInfo.map((d => [ d.fieldName, d.fieldName ])));
    return fold(dataTable, yFieldList, foldName, foldValue, aliasMap, !1);
};

export const isValidDataTable = dataTable => !isNil(dataTable) && isArray(dataTable) && dataTable.length > 0;

export const transferMeasureInTable = (dataTable, fieldInfo) => {
    const newDataTable = [], measureFields = fieldInfo.filter((field => field.role === ROLE.MEASURE));
    return measureFields.length ? (dataTable.forEach((row => {
        const newRow = Object.assign({}, row);
        measureFields.forEach((field => {
            const value = Number(row[field.fieldName]);
            isNumber(value) && "" !== row[field.fieldName] && (newRow[field.fieldName] = value);
        })), newDataTable.push(newRow);
    })), newDataTable) : dataTable;
};
//# sourceMappingURL=dataTable.js.map