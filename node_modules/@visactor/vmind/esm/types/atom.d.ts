import type { Cell, ChartType } from './chart';
import type { FieldInfo, DataTable } from './base';
import type { Insight } from '../atom/dataInsight/type';
import type { ILLMManage, ToolMessage, LLMMessage } from '../types/llm';
import type { SimpleVChartSpec } from '../atom/imageReader/interface';
export interface BaseOptions {
    llm?: ILLMManage;
    tools?: ToolMessage[];
    showThoughts?: boolean;
    language?: 'chinese' | 'english';
    maxMessagesCnt?: number;
}
export interface DataExtractionOptions extends BaseOptions {
    reGenerateFieldInfo?: boolean;
    isMultiple?: boolean;
}
export interface ChartCommandOptions extends BaseOptions {
    useDataTable?: boolean;
    filterByRule?: boolean;
}
export type RangeValueTransferType = 'string' | 'filter' | 'avg' | 'max' | 'min' | 'first' | 'last';
export interface DataCleanOptions extends BaseOptions {
    needNumericalFields?: boolean;
    filterSameValueColumn?: boolean;
    measureAutoTransfer?: boolean;
    filterSameDataItem?: boolean;
    filterRowWithEmptyValues?: boolean;
    rangeValueTransfer?: RangeValueTransferType;
    hierarchicalClustering?: boolean;
    clusterThreshold?: number;
}
export interface MultipleDataCleanOptions extends DataCleanOptions {
    filterRatioInDataset?: number;
}
export interface DataQueryOptions extends BaseOptions {
    useSQL?: boolean;
}
export interface SpecInsightOptions extends BaseOptions {
    defaultMarkerLineStyle?: any;
    defaultMarkerSymbolStyle?: any;
    diffMarkerSymbolStyle?: any;
    labelBackground?: any;
    defaultOffsetInGrowthMarkLine?: number;
}
export interface CustomPromptOptions extends BaseOptions {
    promptTemplate: string;
}
export interface SchemaFieldInfo extends Pick<FieldInfo, 'description' | 'role' | 'location' | 'type'> {
    id: string;
    alias?: string;
    visible?: boolean;
}
export type VizSchema = {
    chartType?: string;
    fields: SchemaFieldInfo[];
};
export declare enum AtomName {
    BASE = "base",
    DATA_EXTRACT = "dataExtract",
    DATA_CLEAN = "dataClean",
    MULTIPLE_DATA_CLEAN = "multipleDataClean",
    DATA_QUERY = "dataQuery",
    CHART_COMMAND = "chartCommand",
    MULTIPLE_CHART_COMMAND = "multipleChartCommand",
    CHART_GENERATE = "chartGenerate",
    DATA_INSIGHT = "dataInsight",
    SPEC_INSIGHT = "specInsight",
    CHART_QA_EXTRACTION = "chartQAExtraction",
    CUSTOM_PROMPT = "custom_prompt",
    VCHART_SPEC = "vchart_spec",
    IMAGE_READER = "imageReader"
}
export interface Usage {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
}
export interface BaseContext {
    logId?: string;
    id?: string;
    query?: string;
    response?: string;
    error?: string;
    usage?: Usage;
    thoughts?: string;
    toolRes?: any;
}
export interface ClusterDataView {
    dataTable: DataTable;
    fieldInfo: FieldInfo[];
    validColumnLength: number;
    validRowLength: number;
    validCellCount: number;
    validMeasureCellCount: number;
}
export interface DatasetFromText {
    text?: string;
    summary: string;
    dataTable: DataTable;
    fieldInfo: FieldInfo[];
    textRange?: [string, string];
}
export interface DataExtractionCtx extends BaseContext {
    text: string;
    fieldInfo?: FieldInfo[];
    dataTable?: DataTable;
    datasets?: DatasetFromText[];
}
export interface ChartCommandCtx extends BaseContext {
    text: string;
    summary?: string;
    fieldInfo?: FieldInfo[];
    dataTable?: DataTable;
    command: string;
}
export interface DataCleanCtx extends BaseContext {
    fieldInfo?: FieldInfo[];
    dataTable?: DataTable;
    clusterResult?: ClusterDataView[];
    originalDataTable?: DataTable;
}
export interface MultipleDataCleanCtx extends BaseContext {
    datasets: DatasetFromText[];
}
export interface MultipleChartCommandsCtx extends BaseContext {
    datasets: DatasetFromText[];
    commands: string[];
}
export interface DataQueryCtx extends BaseContext {
    dataTableSummary?: string;
    fieldInfo?: FieldInfo[];
    llmFieldInfo?: FieldInfo[];
    dataTable: DataTable;
    command: string;
    sql?: string;
}
export interface ChartGeneratorCtx extends BaseContext {
    fieldInfo?: FieldInfo[];
    dataTable: DataTable;
    command: string;
    chartType?: ChartType;
    cell: Cell;
    vizSchema?: VizSchema;
    spec: any;
    chartAdvistorRes?: {
        chartType: ChartType;
        spec: any;
        score: number;
    }[];
    simpleVChartSpec?: SimpleVChartSpec;
    time?: {
        totalTime: number;
        frameArr: any[];
    };
}
export interface DataInsightCtx extends BaseContext {
    spec?: any;
    dataTable?: DataTable;
    fieldInfo?: FieldInfo[];
    insights: Insight[];
    vChartType?: string;
    chartType?: ChartType;
}
export interface SpecInsightCtx extends BaseContext {
    spec?: any;
    insights: Insight[];
    chartType?: ChartType;
    newSpec?: any;
}
export interface ChartQAExtractionCtx extends BaseContext {
    text: string;
    question: string;
    answer: string;
    keyList: string[];
    explanation: string;
}
export interface IVChartOperationItem {
    op: 'add' | 'update' | 'delete' | 'deleteAll';
    target: string;
    value?: any;
}
export interface VChartSpecCtx extends BaseContext {
    originalSpec: any;
    spec?: any;
    prevSpec?: any;
    operations?: IVChartOperationItem[];
    opertationsResult?: number[];
}
export interface DialogueChartCtx extends BaseContext {
    spec: any;
    oneSpec: any;
}
export interface IBaseAtom<Ctx extends BaseContext, O extends BaseOptions> {
    name: string;
    options: O;
    isLLMAtom: boolean;
    history: {
        map: Map<number, Ctx>;
        idList: number[];
        id: number;
    };
    undo: (id?: string) => void;
    redo: (id?: string) => void;
    buildDefaultContext: (context: Ctx) => Ctx;
    buildDefaultOptions: () => O;
    updateContext: (context: Partial<Ctx>, replace?: boolean) => Ctx;
    updateOptions: (options: Partial<O>) => void;
    reset: (context?: Partial<Ctx>) => void;
    getContext: () => Ctx;
    getContextBeforeRun: () => Ctx;
    shouldRunByContextUpdate: (context: Ctx) => boolean;
    run: (userInput?: {
        context?: Ctx;
        query?: string;
        messages?: ILLMManage[];
    }) => Promise<Ctx>;
    runWithChat: (query: string) => Promise<Ctx>;
    setResponses: (messages: LLMMessage[]) => void;
    getResponses: () => LLMMessage[];
    clearHistory: () => void;
}
export interface BaseAtomConstructor<Ctx extends BaseContext = BaseContext, O extends BaseOptions = BaseOptions> {
    new (context: Partial<Ctx>, options: Partial<O>): IBaseAtom<Ctx, O>;
}
