var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { merge } from "@visactor/vutils";

import axios from "axios";

export class RAGManage {
    constructor(options) {
        this.options = merge({}, this.getDefaultOptions(), options);
    }
    getDefaultOptions() {
        return {
            url: "",
            headers: {
                "Content-Type": "application/json"
            },
            method: "POST",
            vikingdbName: ""
        };
    }
    updateOptions(options) {
        this.options = merge({}, this.options, options);
    }
    recall(options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {url: url, headers: headers, vikingdbName: vikingdbName, method: method} = this.options, {indexName: indexName, subIndex: subIndex = "default", topK: topK, dslQuery: dslQuery, isRandomRecall: isRandomRecall, vector: vector, missAsEmpty: missAsEmpty, sparseVector: sparseVector, sparseLogitAlpha: sparseLogitAlpha} = options;
            try {
                const res = yield axios(url + "recall", {
                    method: method,
                    headers: headers,
                    data: {
                        vikingdb_name: vikingdbName,
                        index_name: indexName,
                        sub_index: subIndex,
                        topk: topK,
                        dsl_query: JSON.stringify(dslQuery),
                        is_random_recall: isRandomRecall,
                        vector: vector,
                        sparse_vector: (null != sparseVector ? sparseVector : []).map((item => {
                            const match = item.match(/\("(.+?)", ([\d.]+)\)/);
                            if (match) return [ match[1], parseFloat(match[2]) ];
                            const oldMatch = item.match(/\('(.+)', ([\d.]+)\)/);
                            return oldMatch ? [ oldMatch[1], parseFloat(oldMatch[2]) ] : null;
                        })).filter((item => null !== item)),
                        sparse_logit_alpha: sparseLogitAlpha,
                        miss_as_empty: missAsEmpty
                    }
                }).then((response => response.data));
                return res.error ? (console.error(res.error), {
                    error: res.error
                }) : res;
            } catch (err) {
                return console.error(err), {
                    error: err
                };
            }
        }));
    }
    rawEmbedding(options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const {url: url, headers: headers, method: method, vikingdbName: vikingdbName} = this.options, {rawDatas: rawDatas} = options;
            try {
                const res = yield axios(url + "raw_embedding", {
                    method: method,
                    headers: headers,
                    data: {
                        vikingdb_prefix: vikingdbName,
                        raw_datas: rawDatas
                    }
                }).then((response => response.data));
                return res.error ? (console.error(res.error), {
                    error: res.error
                }) : {
                    vector: null == res ? void 0 : res.embeddings,
                    sparseVector: null == res ? void 0 : res.sparse_embeddings
                };
            } catch (err) {
                return console.error(err), {
                    error: err
                };
            }
        }));
    }
    rawRecall(options) {
        return __awaiter(this, void 0, void 0, (function*() {
            const result = yield this.rawEmbedding(Object.assign(Object.assign({}, options), {
                rawDatas: [ {
                    text: options.text
                } ]
            }));
            if (!(null == result ? void 0 : result.error)) {
                const {vector: vector = [], sparseVector: sparseVector = []} = result;
                return yield this.recall(Object.assign(Object.assign({}, options), {
                    vector: vector[0],
                    sparseVector: sparseVector[0]
                }));
            }
            return {
                error: result.error,
                result: []
            };
        }));
    }
}
//# sourceMappingURL=rag.js.map