var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { merge } from "@visactor/vutils";

import { AtomName } from "../types/atom";

import { Factory } from "../core/factory";

export class BaseAtom {
    constructor(context, options) {
        this.name = AtomName.BASE, this.options = merge({}, this.buildDefaultOptions(), options), 
        this.responses = [], this.history = {
            map: new Map,
            idList: [],
            id: null
        }, this.setNewContext(this.buildDefaultContext(context)), !this.options.llm && this.isLLMAtom && console.error(`Does't support LLM Mange in ${this.name} Atom which need LLM`);
    }
    setNewContext(context) {
        this.context = context;
        const newHistoryId = (this.history.id || 0) + 1;
        this.history.map.set(newHistoryId, context), this.history.idList.push(newHistoryId), 
        this.history.id = newHistoryId;
    }
    undo(id) {}
    redo(id) {}
    buildDefaultContext(context) {
        return null != context ? context : this.context;
    }
    buildDefaultOptions() {
        return {
            maxMessagesCnt: 10
        };
    }
    updateContext(context, replace) {
        return context && (replace ? Object.keys(context).forEach((k => {
            this.context[k] = context[k];
        })) : this.context = merge({}, this.context, context)), this.context;
    }
    updateOptions(options) {
        this.options = merge({}, this.options, options);
    }
    reset(context) {
        this.context = this.buildDefaultContext(context), this.responses = [], this.history.map.clear(), 
        this.history.idList = [], this.history.id = null;
    }
    getContext() {
        return this.context;
    }
    getContextBeforeRun() {
        return this.originContext;
    }
    shouldRunByContextUpdate(context) {
        return !1;
    }
    run(userInput) {
        var _a;
        return __awaiter(this, void 0, void 0, (function*() {
            const {context: context, query: query, messages: messages} = userInput || {};
            messages && this.setResponses(messages), this.context.error = null, this.updateContext(context), 
            this.originContext = this.context;
            try {
                if (this.runBeforeLLM(), this.isLLMAtom && query) return yield this.runWithChat(query), 
                this._runWithOutLLM(), this.context;
                if (this.isLLMAtom) {
                    const messages = this.getLLMMessages(), functionCalls = this.getFunctionCalls(), data = yield this.options.llm.run(this.name, messages, functionCalls), resJson = this.options.llm.parseJson(data), toolJson = this.options.llm.parseTools(data);
                    if (resJson.error || (null == data ? void 0 : data.error)) return this.runWithLLMError(null !== (_a = resJson.error) && void 0 !== _a ? _a : null == data ? void 0 : data.error);
                    this.recordLLMResponse(data), this.setNewContext(Object.assign(Object.assign({}, this.parseLLMContent(resJson, toolJson, data)), {
                        usage: null == data ? void 0 : data.usage
                    })), this._runWithOutLLM();
                } else this._runWithOutLLM();
            } catch (error) {
                return this.runWithLLMError(error);
            }
            return this.context;
        }));
    }
    runBeforeLLM() {
        return this.context;
    }
    runWithLLMError(error) {
        return this.updateContext({
            error: `LLM Error in ${this.name}.\n${error}`
        }), console.error(this.context.error), this.context;
    }
    runWithChat(query) {
        return __awaiter(this, void 0, void 0, (function*() {
            const messages = this.getLLMMessages(query), functionCalls = this.getFunctionCalls(), data = yield this.options.llm.run(this.name, messages, functionCalls), resJson = this.options.llm.parseJson(data), toolJson = this.options.llm.parseTools(data);
            return resJson.error || resJson.error ? this.updateContext({
                error: (null == resJson ? void 0 : resJson.error) || (null == toolJson ? void 0 : toolJson.error)
            }) : (this.recordLLMResponse(data, query), this.setNewContext(Object.assign(Object.assign({}, this.parseLLMContent(resJson, toolJson, data)), {
                usage: null == data ? void 0 : data.usage
            }))), this.context;
        }));
    }
    _runWithOutLLM() {
        return this.context;
    }
    getHistoryLLMMessages(query) {
        return query ? [ ...this.responses, {
            role: "user",
            content: query
        } ] : [];
    }
    getLLMMessages(query) {
        return [];
    }
    getFunctionCalls() {
        var _a;
        return null === (_a = this.options) || void 0 === _a ? void 0 : _a.tools;
    }
    parseLLMContent(resJson, toolJson, llmRes) {
        return Object.assign({}, this.context);
    }
    recordLLMResponse(data, query) {
        const newResponse = data.choices[0].message, assistantMsg = {
            role: "assistant",
            content: newResponse
        };
        query ? this.responses.push({
            role: "user",
            content: newResponse
        }, assistantMsg) : this.responses = [ assistantMsg ];
    }
    setResponses(messages) {
        this.responses = messages;
    }
    getResponses() {
        return this.responses;
    }
    clearHistory() {
        this.responses.length = 0;
    }
}

export const registerBaseAtom = () => {
    Factory.registerAtom(AtomName.BASE, BaseAtom);
};
//# sourceMappingURL=base.js.map