import { isArray, merge } from "@visactor/vutils";

import { AtomName } from "../../types";

import { BaseAtom } from "../base";

import { getLanguageOfText } from "../../utils/text";

import { getChartCommandPrompt } from "./prompt";

import { getRoleByFieldType } from "../../utils/field";

import { isValidData } from "../../utils/common";

import { Factory } from "../../core/factory";

export class MultipleChartCommandAtom extends BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = AtomName.MULTIPLE_CHART_COMMAND, this.isLLMAtom = !0;
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            useDataTable: !1,
            filterByRule: !0
        });
    }
    buildDefaultContext(context) {
        return merge({}, {
            commands: []
        }, context);
    }
    shouldRunByContextUpdate(context) {
        return context.datasets !== this.context.datasets;
    }
    runBeforeLLM() {
        return this.ruleList = this.context.datasets.map((dataset => {
            var _a, _b;
            return !!(null === (_a = this.options) || void 0 === _a ? void 0 : _a.filterByRule) && (null === (_b = null == dataset ? void 0 : dataset.dataTable) || void 0 === _b ? void 0 : _b.length) < 2;
        })), this.context;
    }
    getLLMMessages(query) {
        var _a, _b, _c, _d;
        const {datasets: datasets} = this.context, language = null !== (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.language) && void 0 !== _b ? _b : getLanguageOfText((null === (_c = null == datasets ? void 0 : datasets[0]) || void 0 === _c ? void 0 : _c.text) || (null === (_d = null == datasets ? void 0 : datasets[0]) || void 0 === _d ? void 0 : _d.summary)), addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: getChartCommandPrompt(language)
        }, {
            role: "user",
            content: JSON.stringify({
                userInput: datasets.filter(((datasets, i) => !this.ruleList[i])).map((dataset => {
                    var _a;
                    const {text: text, summary: summary, fieldInfo: fieldInfo, dataTable: dataTable} = dataset;
                    return {
                        text: text,
                        summary: summary,
                        fieldInfo: fieldInfo.map((info => {
                            var _a;
                            return {
                                fieldName: info.fieldName,
                                type: info.role || getRoleByFieldType(info.type),
                                dataLength: (null === (_a = null == dataTable ? void 0 : dataTable.filter((v => isValidData(v[info.fieldName])))) || void 0 === _a ? void 0 : _a.length) || void 0
                            };
                        })),
                        dataTable: (null === (_a = this.options) || void 0 === _a ? void 0 : _a.useDataTable) ? JSON.stringify(dataTable) : void 0
                    };
                }))
            })
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {commands: commands = []} = resJson;
        if (!isArray(commands) || 0 === commands.length) return console.error("Can't generate chart command in this case"), 
        Object.assign(Object.assign({}, this.context), {
            commands: this.context.datasets.map((v => ""))
        });
        const res = [];
        let commandIndex = 0;
        for (let i = 0; i < this.context.datasets.length; i++) {
            this.ruleList[i] ? res.push("") : res.push(commands[commandIndex++]);
        }
        return Object.assign(Object.assign({}, this.context), {
            commands: res
        });
    }
}

export const registerMultipleChartCommandAtom = () => {
    Factory.registerAtom(AtomName.MULTIPLE_CHART_COMMAND, MultipleChartCommandAtom);
};
//# sourceMappingURL=multiple.js.map