import { merge } from "@visactor/vutils";

import { AtomName } from "../../types";

import { BaseAtom } from "../base";

import { getLanguageOfText } from "../../utils/text";

import { getChartCommandPrompt } from "./prompt";

import { getRoleByFieldType } from "../../utils/field";

import { isValidData } from "../../utils/common";

import { Factory } from "../../core/factory";

export class ChartCommandAtom extends BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = AtomName.CHART_COMMAND, this.isLLMAtom = !0;
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            useDataTable: !1
        });
    }
    buildDefaultContext(context) {
        return merge({}, {
            command: ""
        }, context);
    }
    shouldRunByContextUpdate(context) {
        return context.text !== this.context.text || context.fieldInfo !== this.context.fieldInfo;
    }
    getLLMMessages(query) {
        var _a, _b, _c;
        const {fieldInfo: fieldInfo, text: text, dataTable: dataTable, summary: summary} = this.context, language = null !== (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.language) && void 0 !== _b ? _b : getLanguageOfText(text || summary), addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: getChartCommandPrompt(language)
        }, {
            role: "user",
            content: JSON.stringify({
                userInput: [ {
                    text: text,
                    summary: summary,
                    fieldInfo: fieldInfo.map((info => {
                        var _a;
                        return {
                            fieldName: info.fieldName,
                            type: info.role || getRoleByFieldType(info.type),
                            dataLength: (null === (_a = null == dataTable ? void 0 : dataTable.filter((v => isValidData(v[info.fieldName])))) || void 0 === _a ? void 0 : _a.length) || void 0
                        };
                    })),
                    dataTable: (null === (_c = this.options) || void 0 === _c ? void 0 : _c.useDataTable) ? JSON.stringify(dataTable) : void 0
                } ]
            })
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {commands: commands = []} = resJson, command = (null == commands ? void 0 : commands[0]) || "";
        return !1 !== command && "false" !== command && command ? Object.assign(Object.assign({}, this.context), {
            command: command
        }) : (console.error("Can't generate chart command in this case"), Object.assign(Object.assign({}, this.context), {
            command: "",
            error: "Can't generate chart command in this case"
        }));
    }
}

export const registerChartCommandAtom = () => {
    Factory.registerAtom(AtomName.CHART_COMMAND, ChartCommandAtom);
};
//# sourceMappingURL=index.js.map