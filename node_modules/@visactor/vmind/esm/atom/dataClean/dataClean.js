import { AtomName } from "../../types/atom";

import { BaseAtom } from "../base";

import { merge } from "@visactor/vutils";

import { getCtxByfilterSameValueColumn, getCtxByneedNumericalFields, getCtxBymeasureAutoTransfer, getCtxByfilterSameDataItem, getCtxByFilterRowWithNonEmptyValues, getCtxByRangeValueTranser, getSplitDataViewOfDataTable, transferFieldInfo, revisedUnMatchedFieldInfo, sortDataTableByDate } from "./utils";

import { Factory } from "../../core/factory";

export const pipelines = [ {
    key: "revisedUnMatchedInfo",
    func: revisedUnMatchedFieldInfo
}, {
    key: "rangeValueTransfer",
    func: getCtxByRangeValueTranser
}, {
    key: "measureAutoTransfer",
    func: getCtxBymeasureAutoTransfer
}, {
    key: "filterRowWithEmptyValues",
    func: getCtxByFilterRowWithNonEmptyValues
}, {
    key: "filterSameDataItem",
    func: getCtxByfilterSameDataItem
}, {
    key: "filterSameValueColumn",
    func: getCtxByfilterSameValueColumn
}, {
    key: "needNumericalFields",
    func: getCtxByneedNumericalFields
}, {
    key: "sortByDate",
    func: sortDataTableByDate
} ];

export class DataCleanAtom extends BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = AtomName.DATA_CLEAN;
    }
    buildDefaultContext(context) {
        return merge({}, {
            dataTable: [],
            fieldInfo: []
        }, context);
    }
    buildDefaultOptions() {
        return {
            filterSameValueColumn: !0,
            needNumericalFields: !0,
            measureAutoTransfer: !0,
            filterSameDataItem: !0,
            filterRowWithEmptyValues: !0,
            rangeValueTransfer: "avg",
            hierarchicalClustering: !0
        };
    }
    updateContext(context) {
        return this.context = transferFieldInfo(super.updateContext(context)), this.context;
    }
    shouldRunByContextUpdate(context) {
        return context.dataTable !== this.context.dataTable;
    }
    _runWithOutLLM() {
        let newContext = Object.assign({}, this.context);
        return pipelines.forEach((({key: key, func: func}) => {
            const currentOption = this.options[key];
            !1 !== currentOption && (newContext = func(newContext, currentOption));
        })), this.setNewContext(newContext), this.options.hierarchicalClustering && this.setNewContext(getSplitDataViewOfDataTable(newContext, this.options.clusterThreshold)), 
        this.context;
    }
}

export const registerDataCleanAtom = () => {
    Factory.registerAtom(AtomName.DATA_CLEAN, DataCleanAtom);
};
//# sourceMappingURL=dataClean.js.map