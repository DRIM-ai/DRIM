{"version":3,"sources":["../src/atom/dataQuery/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import JSON5 from 'json5';\nimport { isArray, isString, uniqArray } from '@visactor/vutils';\nimport { capitalize, replaceAll } from '../../utils/text';\nimport { alasqlKeywordList } from './const';\nimport type { DataItem, DataTable, FieldInfo } from '../../types';\nimport { ROLE } from '../../types';\nimport alasql from 'alasql';\nimport { detectFieldType } from '../../utils/field';\n\nexport function generateRandomString(len: number) {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\nconst operatorList = [\n  ['+', `_${generateRandomString(3)}_PLUS_${generateRandomString(3)}_`],\n  ['-', `_${generateRandomString(3)}_DASH_${generateRandomString(3)}_`],\n  ['*', `_${generateRandomString(3)}_ASTERISK_${generateRandomString(3)}_`],\n  ['/', `_${generateRandomString(3)}_SLASH_${generateRandomString(3)}_`]\n];\n\nconst operators = operatorList.map(op => op[0]);\n\nconst RESERVE_REPLACE_MAP = new Map<string, string>([\n  ...operatorList,\n  ...(alasqlKeywordList.map(keyword => [keyword, generateRandomString(10)]) as any)\n]);\n\nexport const parseSQLResponse = (response: string) => {\n  const sql = response.match(/sql:\\n?```(.*?)```/s)[1];\n  const fieldInfoStr = response.match(/fieldInfo:\\n?```(.*?)```/s)[1];\n  let fieldInfo = [];\n  try {\n    const tempFieldInfo = JSON5.parse(fieldInfoStr);\n    if (isArray(tempFieldInfo)) {\n      fieldInfo = tempFieldInfo;\n    } else {\n      fieldInfo = tempFieldInfo.fieldInfo;\n    }\n  } catch (e) {\n    //fieldInfoStr is not a json string; try to wrap it with []\n    fieldInfo = JSON5.parse(`[${fieldInfoStr}]`);\n  }\n  return {\n    sql,\n    llmFieldInfo: fieldInfo,\n    thoughts: ''\n  };\n};\n\nexport function removeEmptyLines(str: string) {\n  return str.replace(/\\n\\s*\\n/g, '\\n');\n}\n\nexport const swapMap = (map: Map<string, string>) => {\n  //swap the map\n  const swappedMap = new Map();\n\n  // Swap key with value\n  map.forEach((value, key) => {\n    swappedMap.set(value, key);\n  });\n  return swappedMap;\n};\n\n/**\n * replace the string according to replaceMap\n * @param str\n * @param replaceMap\n */\nexport const replaceByMap = (str: string, replaceMap: Map<string, string>) => {\n  const originalStringList = [...replaceMap.keys()];\n\n  const finalSql = originalStringList.reduce((prev, cur) => {\n    const originColumnName = cur;\n    const validColumnName = replaceMap.get(cur);\n    return replaceAll(prev, originColumnName, validColumnName);\n  }, str);\n\n  return finalSql;\n};\n\n/**\n * replace all the non-ascii characters in the sql str into valid strings.\n * @param str\n * @returns\n */\nconst replaceNonASCIICharacters = (str: string) => {\n  const nonAsciiCharMap = new Map();\n\n  const newStr = str.replace(/([^\\x00-\\x7F]+)/g, m => {\n    let replacement;\n    if (nonAsciiCharMap.has(m)) {\n      replacement = nonAsciiCharMap.get(m);\n    } else {\n      replacement = generateRandomString(10);\n      nonAsciiCharMap.set(m, replacement);\n    }\n    return replacement;\n  });\n\n  //const swappedMap = swapMap(nonAsciiCharMap);\n\n  return { validStr: newStr, replaceMap: nonAsciiCharMap };\n};\n\n/**\n * replace strings according to replaceMap\n * @param str\n * @param replaceMap\n * @returns\n */\nexport const replaceString = (str: string | number, replaceMap: Map<string, string>) => {\n  if (!isString(str)) {\n    return str;\n  }\n  if (replaceMap.has(str)) {\n    return replaceMap.get(str);\n  }\n  //Some string may be linked by ASCII characters as non-ASCII characters.Traversing the replaceMap and replaced it to the original character\n  //sort the replace keys according to their length to make sure longer string can be replaced first\n  const replaceKeys = [...replaceMap.keys()].sort((a, b) => b.length - a.length);\n  return replaceKeys.reduce((prev, cur) => {\n    return replaceAll(prev, cur, replaceMap.get(cur));\n  }, str);\n};\n\n//replace data keys and data values according to replaceMap\nexport const replaceDataset = (dataset: DataTable, replaceMap: Map<string, string>, keysOnly: boolean): DataTable => {\n  return dataset.map((d: DataItem) => {\n    const dataKeys = Object.keys(d);\n    return dataKeys.reduce((prev, cur) => {\n      const replacedKey = replaceString(cur, replaceMap);\n      const replacedValue = replaceString(d[cur], replaceMap);\n      prev[replacedKey] = keysOnly ? d[cur] : replacedValue;\n      return prev;\n    }, {} as DataItem);\n  });\n};\n\nexport const getValueByAttributeName = (obj: any, outterKey: string): string[] => {\n  //get all the attributes of an object by outterKey\n  const values: string[] = [];\n  for (const key in obj) {\n    if (key === outterKey && typeof obj[key] === 'string') {\n      values.push(obj[key]);\n    } else if (typeof obj[key] === 'object') {\n      const childValues = getValueByAttributeName(obj[key], outterKey);\n      values.push(...childValues);\n    }\n  }\n  return uniqArray(values) as string[];\n};\n\n/**\n * replace operator and reserved words inside the column name in the sql str\n * operators such as +, -, *, / in column names in sql will cause ambiguity and parsing error\n * so we need to replace them only in column names\n * sometimes skylark2 pro will return a sql statement in which non-ascii characters are not wrapped with ``\n * this will cause error in alasql\n * so we need to replace them with random string in the whole sql\n * @param sql\n * @param columns\n * @returns validStr: sql without invalid characters; columnReplaceMap: replace map of column names; sqlReplaceMap: replace map of the whole sql including dimension values.\n *\n */\nexport const replaceInvalidWords = (sql: string, columns: string[]) => {\n  const operatorReplaceMap = new Map<string, string>();\n\n  //replace column names according to RESERVED_REPLACE_MAP\n  const validColumnNames = columns.map(column => {\n    const nameWithoutOperator = [...RESERVE_REPLACE_MAP.keys()].reduce((prev, cur) => {\n      //try to match the keywords in column names with different style\n      const replaceStr = [cur.toUpperCase(), cur.toLowerCase(), capitalize(cur)].find(str => {\n        //operators need to be replaced if it is includes by the column name\n        //while other reserved words need to be replaced if it is exactly the same as column words\n        return operators.includes(cur) ? prev.includes(str) : prev === str;\n      });\n      if (replaceStr) {\n        if (!operatorReplaceMap.has(replaceStr)) {\n          operatorReplaceMap.set(replaceStr, RESERVE_REPLACE_MAP.get(cur));\n        }\n        return replaceAll(prev, replaceStr, RESERVE_REPLACE_MAP.get(cur));\n      }\n      return prev;\n    }, column);\n\n    return nameWithoutOperator;\n  });\n\n  const columnReplaceMap = new Map<string, string>(\n    columns\n      .map((column, index) => {\n        const validStr = validColumnNames[index];\n        if (column !== validStr) {\n          return [column, validStr];\n        }\n        return undefined;\n      })\n      .filter(Boolean) as any\n  );\n\n  //only replace operators in column names, not all operators in the sql\n  const sqlWithoutOperator = replaceByMap(sql, columnReplaceMap);\n\n  //replace non-ascii characters in sql\n  const { validStr: sqlWithoutAscii, replaceMap: asciiReplaceMap } = replaceNonASCIICharacters(sqlWithoutOperator);\n\n  return { validStr: sqlWithoutAscii, columnReplaceMap: operatorReplaceMap, sqlReplaceMap: asciiReplaceMap };\n};\n\n/**\n * merge two maps\n * @param map1\n * @param map2\n * @returns\n */\nexport const mergeMap = (map1: Map<string, string>, map2: Map<string, string>) => {\n  // merge map2 into map1\n  map2.forEach((value, key) => {\n    map1.set(key, value);\n  });\n  return map1;\n};\n\n/**\n * match the column name with field name without blank spaces\n * @param columnName\n * @param fieldName\n * @returns\n */\nexport const matchColumnName = (columnName: string, fieldName: string) => {\n  const fieldWithoutSpace = fieldName.replace(/\\s/g, '');\n  const columnWithoutString = columnName.replace(/\\s/g, '');\n\n  if (columnWithoutString === fieldWithoutSpace) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * sometimes skylark2 pro will return a sql statement with some blank spaces in column names\n * this will make the alasql can't find the correct column in dataset\n * so we need to remove these blank spaces\n * only replace when no fields can match the column name in sql\n *\n */\nexport const replaceBlankSpace = (sql: string, fieldNames: string[]) => {\n  //extract all the columns in sql str\n  const ast = alasql.parse(sql) as any;\n  const columnsInSql = getValueByAttributeName(ast.statements[0], 'columnid');\n\n  //replace all the spaces and reserved words in column names in sql\n  //only replace when two names can match without space\n  const validColumnNames = columnsInSql.map(column => {\n    const matchedFieldName = fieldNames.find(field => matchColumnName(column, field));\n    return matchedFieldName ?? column;\n  });\n\n  const finalSql = columnsInSql.reduce((prev, _cur, index) => {\n    const originColumnName = columnsInSql[index];\n    const validColumnName = validColumnNames[index];\n    if (validColumnName !== originColumnName) {\n      return replaceAll(prev, originColumnName, validColumnName);\n    }\n    return prev;\n  }, sql);\n  return finalSql;\n};\n\n/**\n * sometimes skylark2 pro will return a sql statement with some measure fields not being aggregated\n * this will make an empty field in dataset\n * so we need to aggregate these fields.\n *\n */\nexport const sumAllMeasureFields = (\n  sql: string,\n  fieldInfo: FieldInfo[],\n  columnReplaceMap: Map<string, string>,\n  sqlReplaceMap: Map<string, string>\n) => {\n  const measureFieldsInSql = fieldInfo\n    .filter(field => field.role === ROLE.MEASURE)\n    .map(field => {\n      const { fieldName } = field;\n      const replacedName1 = replaceString(fieldName, columnReplaceMap);\n      const replacedName2 = replaceString(replacedName1, sqlReplaceMap);\n\n      return replacedName2;\n    });\n\n  const ast: any = alasql.parse(sql);\n  const selectedColumns = ast.statements[0].columns;\n  const nonAggregatedColumns: string[] = selectedColumns\n    .filter((column: any) => !column.aggregatorid)\n    .map((column: any) => column.columnid);\n\n  const groupByColumns: string[] = (ast.statements[0].group ?? []).map((column: any) => column.columnid);\n\n  //if there exist some aggregated columns in sql and there exist GROUP BY statement in sql, then aggregate all the measure columns\n  let needAggregateColumns: string[] = [];\n  if (groupByColumns.length > 0 && nonAggregatedColumns.length !== selectedColumns.length) {\n    //aggregate columns that is not in group by statement\n    needAggregateColumns = nonAggregatedColumns\n      //filter all the measure fields\n      .filter(column => measureFieldsInSql.includes(column))\n      //filter measure fields that is not in groupby\n      .filter(column => !groupByColumns.includes(column));\n  }\n\n  const patchedFields = needAggregateColumns.map(column => `SUM(\\`${column}\\`) as ${column}`);\n\n  const finalSql = needAggregateColumns.reduce((prev, cur, index) => {\n    const regexStr = `\\`?${cur}\\`?`;\n    const regex = new RegExp(regexStr, 'g');\n    return prev.replace(regex, patchedFields[index]);\n  }, sql);\n\n  return finalSql;\n};\n\n/**\n * convert group by columns to string\n */\nexport const convertGroupByToString = (sql: string, dataset: DataItem[]) => {\n  const ast: any = alasql.parse(sql);\n  const groupByColumns: string[] = ast.statements[0].group.map((column: any) => column.columnid);\n  dataset.forEach(item => {\n    groupByColumns.forEach(column => {\n      item[column] = item[column].toString();\n    });\n  });\n};\n\n/**\n * parse the respond field in data query to get field type and role\n * @param fieldInfo\n * @param responseFieldInfo\n * @param dataset\n */\nexport const parseRespondField = (\n  responseFieldInfo: { fieldName: string; description?: string }[],\n  dataset: DataItem[]\n) =>\n  responseFieldInfo.map(field => ({\n    ...field,\n    ...detectFieldType(dataset, field.fieldName)\n  }));\n"]}