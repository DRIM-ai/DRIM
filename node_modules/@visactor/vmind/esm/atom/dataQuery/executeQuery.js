import alasql from "alasql";

import { matchColumnName, parseRespondField, replaceBlankSpace, replaceDataset, replaceInvalidWords, replaceString, sumAllMeasureFields, swapMap } from "./utils";

import { VMIND_DATA_SOURCE } from "./const";

export const patchSQLBeforeQuery = context => {
    const {sql: sql, dataTable: dataTable, fieldInfo: fieldInfo, llmFieldInfo: propsLLMFieldInfo} = context, fieldNames = fieldInfo.map((field => field.fieldName)), {validStr: validStr, sqlReplaceMap: sqlReplaceMap, columnReplaceMap: columnReplaceMap} = replaceInvalidWords(sql, fieldNames), validColumnDataset = replaceDataset(dataTable, columnReplaceMap, !0), validDataset = replaceDataset(validColumnDataset, sqlReplaceMap, !1), replacedFieldNames = fieldNames.map((field => replaceString(field, columnReplaceMap))).map((field => replaceString(field, sqlReplaceMap))), validSql = replaceBlankSpace(validStr, replacedFieldNames), llmFieldInfo = propsLLMFieldInfo.map((field => {
        const {fieldName: fieldName} = field, temp = replaceString(fieldName, columnReplaceMap), validFieldName = replaceString(temp, sqlReplaceMap), matchedFieldName = replacedFieldNames.find((f => matchColumnName(validFieldName, f)));
        return Object.assign(Object.assign({}, field), {
            fieldName: null != matchedFieldName ? matchedFieldName : validFieldName
        });
    }));
    return {
        finalSql: sumAllMeasureFields(validSql, fieldInfo, columnReplaceMap, sqlReplaceMap),
        validDataset: validDataset,
        columnReplaceMap: columnReplaceMap,
        sqlReplaceMap: sqlReplaceMap,
        llmFieldInfo: llmFieldInfo
    };
};

export const executeDataQuery = context => {
    const {finalSql: finalSql, validDataset: validDataset} = context, sqlParts = (finalSql + " ").split(VMIND_DATA_SOURCE), sqlCount = sqlParts.length - 1, alasqlQuery = sqlParts.join("?");
    return {
        alasqlDataset: alasql(alasqlQuery, new Array(sqlCount).fill(validDataset))
    };
};

export const restoreDatasetAfterQuery = context => {
    const {columnReplaceMap: columnReplaceMap, sqlReplaceMap: sqlReplaceMap, alasqlDataset: alasqlDataset, llmFieldInfo: propsLLMFieldInfo} = context, columnReversedMap = swapMap(columnReplaceMap), columnRestoredDataset = replaceDataset(alasqlDataset, columnReversedMap, !0), sqlReversedMap = swapMap(sqlReplaceMap);
    return {
        datasetAfterQuery: replaceDataset(columnRestoredDataset, sqlReversedMap, !1),
        llmFieldInfo: propsLLMFieldInfo.map((field => {
            const {fieldName: fieldName} = field, temp = replaceString(fieldName, columnReversedMap), validFieldName = replaceString(temp, sqlReversedMap);
            return Object.assign(Object.assign({}, field), {
                fieldName: validFieldName
            });
        }))
    };
};

export const getFinalQueryResult = context => {
    const {dataTable: sourceDataset, fieldInfo: fieldInfo, llmFieldInfo: responseFieldInfo, datasetAfterQuery: datasetAfterQuery} = context, fieldInfoNew = parseRespondField(responseFieldInfo, datasetAfterQuery);
    return 0 === datasetAfterQuery.length && console.warn("empty dataset after query!"), 
    {
        dataTable: 0 === datasetAfterQuery.length ? sourceDataset : datasetAfterQuery,
        fieldInfo: 0 === datasetAfterQuery.length ? fieldInfo : fieldInfoNew
    };
};
//# sourceMappingURL=executeQuery.js.map
