import { FOLD_NAME, FOLD_VALUE } from "@visactor/chart-advisor";

import { array, isArray, isNil } from "@visactor/vutils";

import { getDataListByField, getFieldByDataType, getFieldByRole, getFieldsByDataType, getRemainedFields } from "../../utils/field";

import { foldDataTableByYField, isValidDataTable } from "../../utils/dataTable";

import { replaceAll } from "../../utils/text";

import { ChartType, DataType, ROLE } from "../../types";

import { NEED_COLOR_FIELD_CHART_LIST, NEED_SIZE_FIELD_CHART_LIST, CARTESIAN_CHART_LIST, NEED_COLOR_AND_SIZE_CHART_LIST } from "./const";

import { isValidData } from "../../utils/common";

export const getContextAfterRevised = context => {
    const revisedFuncList = [ patchChartType, patchTransposeField, patchAxisField, patchColorField, patchLabelField, patchYField, patchNeedColor, patchNeedSize, patchBoxPlot, patchDualAxis, patchPieChart, patchWordCloud, patchDynamicBarChart, patchRangeColumnChart, patchLinearProgressChart, patchBasicHeatMapChart, patchCartesianXField ];
    let newContext = Object.assign({}, context);
    return revisedFuncList.forEach((func => {
        newContext = Object.assign(Object.assign({}, newContext), func(newContext));
    })), newContext;
};

export const patchChartType = context => {
    const {chartType: chartType, chartTypeList: chartTypeList} = context, chartTypeNew = replaceAll(replaceAll(chartType, "/", ""), "-", " ");
    return chartTypeList.includes(chartTypeNew) ? {
        chartType: chartTypeNew.toUpperCase()
    } : (console.error("Unsupported Chart Type. Please Change User Input"), {
        error: "Unsupported Chart Type. Please Change User Input"
    });
};

export const patchTransposeField = context => {
    const {cell: cell, transpose: transpose, fieldInfo: fieldInfo} = context;
    if (transpose) {
        const {x: x, y: y} = cell, arrayX = array(x), arrayY = array(y), fieldMapping = fieldInfo.reduce(((prev, curv) => Object.assign(Object.assign({}, prev), {
            [curv.fieldName]: curv
        })), {});
        if (arrayX.every((field => !!fieldMapping[field] && fieldMapping[field].role === ROLE.MEASURE)) && arrayY.every((field => !!fieldMapping[field] && fieldMapping[field].role === ROLE.DIMENSION))) return Object.assign(Object.assign({}, context), {
            cell: Object.assign(Object.assign({}, cell), {
                x: y,
                y: x
            })
        });
    }
    return context;
};

export const patchAxisField = context => {
    const {cell: cell} = context, cellNew = Object.assign({}, cell);
    return !cellNew.axis || cellNew.x && cellNew.y || (cellNew.x ? cellNew.y || (cellNew.y = cellNew.axis) : cellNew.x = cellNew.axis), 
    {
        cell: cellNew
    };
};

export const patchColorField = context => {
    var _a;
    const {cell: cell} = context;
    return {
        cell: Object.assign(Object.assign({}, cell), {
            color: null !== (_a = cell.color) && void 0 !== _a ? _a : cell.category
        })
    };
};

export const patchLabelField = context => {
    const {cell: cell} = context, cellNew = Object.assign({}, cell);
    return !cellNew.label || cellNew.color && 0 !== cellNew.color.length || (cellNew.color = cellNew.label), 
    {
        cell: cellNew
    };
};

export const patchYField = context => {
    const {chartType: chartType, cell: cell, dataTable: dataTable, fieldInfo: fieldInfo} = context;
    let cellNew = Object.assign({}, cell);
    const {x: x, y: y} = cellNew;
    let chartTypeNew = chartType, datasetNew = dataTable;
    if (y && isArray(y) && y.length > 1) {
        if (chartTypeNew === ChartType.BoxPlot.toUpperCase() || chartTypeNew === ChartType.DualAxisChart.toUpperCase() && 2 === y.length || chartTypeNew === ChartType.RangeColumnChart.toUpperCase() && 2 === y.length) return Object.assign({}, context);
        if ((chartTypeNew === ChartType.BarChart.toUpperCase() || chartTypeNew === ChartType.LineChart.toUpperCase()) && 2 === y.length) return Object.assign(Object.assign({}, context), {
            chartType: ChartType.DualAxisChart.toUpperCase()
        });
        chartTypeNew === ChartType.BarChart.toUpperCase() || chartTypeNew === ChartType.LineChart.toUpperCase() || chartTypeNew === ChartType.DualAxisChart.toUpperCase() || chartTypeNew === ChartType.RadarChart.toUpperCase() ? isValidDataTable(datasetNew) && (datasetNew = foldDataTableByYField(datasetNew, y, fieldInfo), 
        cellNew.y = FOLD_VALUE.toString(), cellNew.color = FOLD_NAME.toString()) : (chartTypeNew = ChartType.ScatterPlot.toUpperCase(), 
        cellNew = Object.assign(Object.assign({}, cell), {
            x: y[0],
            y: y[1],
            color: "string" == typeof x ? x : x[0]
        }));
    }
    return {
        chartType: chartTypeNew,
        cell: cellNew,
        dataTable: datasetNew
    };
};

export const patchBoxPlot = context => {
    const {chartType: chartType, cell: cell} = context, cellNew = Object.assign({}, cell), {y: y} = cellNew;
    if (chartType === ChartType.BoxPlot.toUpperCase()) if ("string" == typeof y && y.split(",").length > 1) cellNew.y = y.split(",").map((str => str.trim())); else if (isNil(y) || 0 === y.length) {
        const {lower_whisker: lower_whisker, lowerWhisker: lowerWhisker, min: min, lower: lower, lowerBox: lowerBox, lower_box: lower_box, q1: q1, lower_quartile: lower_quartile, lowerQuartile: lowerQuartile, midline: midline, median: median, q3: q3, upperBox: upperBox, upper_box: upper_box, upper_quartile: upper_quartile, upperQuartile: upperQuartile, upper_whisker: upper_whisker, upperWhisker: upperWhisker, max: max, upper: upper} = cellNew;
        cellNew.y = [ lower_whisker, lowerWhisker, min, lower, lowerBox, lower_box, q1, lower_quartile, lowerQuartile, midline, median, q3, upperBox, upper_box, upper_quartile, upperQuartile, upper_whisker, upperWhisker, max, upper ].filter(Boolean);
    }
    return {
        cell: cellNew
    };
};

export const patchDualAxis = context => {
    const {chartType: chartType, cell: cell} = context, cellNew = Object.assign({}, cell);
    return chartType === ChartType.DualAxisChart.toUpperCase() && (cellNew.y = [ cellNew.y, cellNew.yLeft, cellNew.yRight, cellNew.y1, cellNew.y2 ].filter(Boolean).flat()), 
    {
        cell: cellNew
    };
};

export const patchPieChart = context => {
    var _a, _b, _c;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo, dataTable: dataTable} = context, cellNew = Object.assign({}, cell);
    if (chartType === ChartType.RoseChart.toUpperCase() && (cellNew.angle = null !== (_b = null !== (_a = cellNew.radius) && void 0 !== _a ? _a : cellNew.size) && void 0 !== _b ? _b : cellNew.angle), 
    chartType === ChartType.PieChart.toUpperCase() || chartType === ChartType.RoseChart.toUpperCase()) {
        if (!cellNew.color || !cellNew.angle) {
            const remainedFields = getRemainedFields(cellNew, fieldInfo);
            if (!cellNew.color) {
                const colorField = getFieldByRole(remainedFields, ROLE.DIMENSION);
                colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_c = remainedFields[0]) || void 0 === _c ? void 0 : _c.fieldName);
            }
            if (!cellNew.angle) {
                const angleField = getFieldByDataType(remainedFields, [ DataType.FLOAT, DataType.INT ]);
                cellNew.angle = angleField ? angleField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
            }
        }
        const colorField = isArray(cellNew.color) ? cellNew.color[0] : cellNew.color, angleField = isArray(cellNew.angle) ? cellNew.angle[0] : cellNew.angle;
        if (dataTable.filter((dataItem => isValidData(dataItem[colorField]) && isValidData(dataItem[angleField]) && Number(dataItem[angleField]) > 0)).length < 2) {
            const colorFieldInfo = fieldInfo.find((info => info.fieldName === colorField));
            return {
                chartType: (null == colorFieldInfo ? void 0 : colorFieldInfo.type) === DataType.DATE ? ChartType.LineChart.toUpperCase() : ChartType.BarChart.toUpperCase(),
                cell: {
                    x: colorField,
                    y: angleField
                }
            };
        }
    }
    return {
        cell: cellNew
    };
};

export const patchWordCloud = context => {
    var _a, _b, _c, _d, _e;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (!(chartType !== ChartType.WordCloud.toUpperCase() || cellNew.size && cellNew.color && cellNew.color !== cellNew.size)) {
        const remainedFields = getRemainedFields(cellNew, fieldInfo);
        if (!cellNew.size || cellNew.size === cellNew.color) {
            const newSize = null !== (_a = cellNew.weight) && void 0 !== _a ? _a : cellNew.fontSize;
            if (newSize) cellNew.size = newSize; else {
                const sizeField = getFieldByDataType(remainedFields, [ DataType.INT, DataType.FLOAT ]);
                cellNew.size = sizeField ? sizeField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
            }
        }
        if (!cellNew.color) {
            const newColor = null !== (_d = null !== (_c = null !== (_b = cellNew.text) && void 0 !== _b ? _b : cellNew.word) && void 0 !== _c ? _c : cellNew.label) && void 0 !== _d ? _d : cellNew.x;
            if (newColor) cellNew.color = newColor; else {
                const colorField = getFieldByRole(remainedFields, ROLE.DIMENSION);
                colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_e = remainedFields[0]) || void 0 === _e ? void 0 : _e.fieldName);
            }
        }
    }
    return {
        cell: cellNew
    };
};

export const patchDynamicBarChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo, dataTable: dataTable} = context, cellNew = Object.assign({}, cell);
    let chartTypeNew = chartType;
    if (chartType === ChartType.DynamicBarChart.toUpperCase() && (!cell.time || "" === cell.time || 0 === cell.time.length)) {
        const remainedFields = getRemainedFields(cellNew, fieldInfo), timeField = getFieldByDataType(remainedFields, [ DataType.DATE ]);
        if (timeField) cellNew.time = timeField.fieldName; else {
            const stringField = getFieldByDataType(remainedFields, [ DataType.STRING ]);
            stringField ? cellNew.time = stringField.fieldName : chartTypeNew = ChartType.BarChart.toUpperCase();
        }
    }
    if (cellNew.time) {
        (getDataListByField(dataTable, cellNew.time).length < 7 && !cellNew.color || cellNew.x === cellNew.time) && (chartTypeNew = cellNew.x !== cellNew.time ? ChartType.BarChart.toUpperCase() : ChartType.LineChart.toUpperCase(), 
        cellNew.color = cellNew.x !== cellNew.time ? cellNew.x : void 0, cellNew.x = cellNew.time, 
        cellNew.time = void 0);
    }
    return {
        cell: cellNew,
        chartType: chartTypeNew
    };
};

export const patchCartesianXField = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (CARTESIAN_CHART_LIST.map((chart => chart.toUpperCase())).includes(chartType) && !cellNew.x) {
        const remainedFields = getRemainedFields(cellNew, fieldInfo), xField = getFieldByRole(remainedFields, ROLE.DIMENSION);
        cellNew.x = xField ? xField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
    }
    return {
        cell: cellNew
    };
};

export const patchNeedColor = context => {
    var _a;
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (NEED_COLOR_FIELD_CHART_LIST.some((needColorFieldChartType => needColorFieldChartType.toUpperCase() === chartType)) || NEED_COLOR_AND_SIZE_CHART_LIST.some((needColorFieldChartType => needColorFieldChartType.toUpperCase() === chartType))) {
        const colorField = [ cellNew.color, cellNew.x, cellNew.label, cellNew.sets ].filter(Boolean);
        if (0 !== colorField.length) cellNew.color = colorField[0]; else {
            const remainedFields = getRemainedFields(cellNew, fieldInfo), colorField = getFieldByRole(remainedFields, ROLE.DIMENSION);
            colorField ? cellNew.color = colorField.fieldName : (null == remainedFields ? void 0 : remainedFields[0]) && (cellNew.color = null === (_a = remainedFields[0]) || void 0 === _a ? void 0 : _a.fieldName);
        }
    }
    return {
        cell: cellNew
    };
};

export const patchNeedSize = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (NEED_SIZE_FIELD_CHART_LIST.some((needSizeFieldChartType => needSizeFieldChartType.toUpperCase() === chartType)) || NEED_COLOR_AND_SIZE_CHART_LIST.some((needSizeFieldChartType => needSizeFieldChartType.toUpperCase() === chartType))) {
        const sizeField = [ cellNew.size, cellNew.value, cellNew.y, cellNew.radius, cellNew.angle ].filter(Boolean).flat();
        if (0 !== sizeField.length) cellNew.size = sizeField[0]; else {
            const remainedFields = getRemainedFields(cellNew, fieldInfo), sizeField = getFieldByRole(remainedFields, ROLE.MEASURE);
            cellNew.size = sizeField ? sizeField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
    }
    return {
        cell: cellNew
    };
};

export const patchRangeColumnChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell), remainedFields = getRemainedFields(cellNew, fieldInfo), numericFields = getFieldsByDataType(remainedFields, [ DataType.FLOAT, DataType.INT ]);
    if (chartType === ChartType.RangeColumnChart.toUpperCase()) {
        if (cellNew.y && cellNew.y instanceof Array && 2 === cellNew.y.length) return {
            cell: cellNew
        };
        if (!(numericFields.length >= 2)) {
            const message = "The y-axis of the range column chart requires two numeric fields, but the result of data aggregation does not have two numeric fields";
            return console.error(message), {
                error: message
            };
        }
        cellNew.y = [ numericFields[0].fieldName, numericFields[1].fieldName ];
    }
    return {
        cell: cellNew
    };
};

export const patchLinearProgressChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (chartType === ChartType.LinearProgress.toUpperCase()) {
        const xField = [ cellNew.x, cellNew.color ].filter(Boolean).flat();
        if (0 !== xField.length) cellNew.x = xField[0]; else {
            const remainedFields = getRemainedFields(cellNew, fieldInfo), xField = getFieldByRole(remainedFields, ROLE.DIMENSION);
            cellNew.x = xField ? xField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
        const yField = [ cellNew.y, cellNew.size, cellNew.value, cellNew.radius, cellNew.angle ].filter(Boolean).flat();
        if (0 !== yField.length) cellNew.y = yField[0]; else {
            const remainedFields = getRemainedFields(cellNew, fieldInfo), yField = getFieldByRole(remainedFields, ROLE.MEASURE);
            cellNew.y = yField ? yField.fieldName : null == remainedFields ? void 0 : remainedFields[0].fieldName;
        }
    }
    return {
        cell: cellNew
    };
};

export const patchBasicHeatMapChart = context => {
    const {chartType: chartType, cell: cell, fieldInfo: fieldInfo} = context, cellNew = Object.assign({}, cell);
    if (chartType === ChartType.BasicHeatMap.toUpperCase()) {
        const colorField = [ cellNew.x, cellNew.y, cellNew.label, cellNew.color ].filter(Boolean).flat();
        if (colorField.length >= 2) cellNew.x = colorField[0], cellNew.y = colorField[1]; else {
            const remainedFields = getRemainedFields(cellNew, fieldInfo), colorField = getFieldsByDataType(remainedFields, [ DataType.STRING ]);
            colorField.length >= 2 ? (cellNew.x = colorField[0], cellNew.y = colorField[1]) : (cellNew.x = null == remainedFields ? void 0 : remainedFields[0].fieldName, 
            cellNew.y = remainedFields[1].fieldName);
        }
    }
    return {
        cell: cellNew
    };
};
//# sourceMappingURL=llmResultRevise.js.map