import { getVChartTypeByVmind } from "../chartTypeUtils";

import { isValidDataTable } from "../../../../utils/dataTable";

import { builtinThemeMap } from "../../const";

import { animationDuration, COLOR_THEMES, DEFAULT_VIDEO_LENGTH, DEFAULT_VIDEO_LENGTH_LONG, oneByOneGroupSize } from "../constants";

import { isArray } from "@visactor/vutils";

import { getFieldIdInCell } from "../../../../utils/field";

export const revisedVChartType = context => {
    const {chartType: chartType, spec: spec} = context;
    return spec.type = getVChartTypeByVmind(chartType), {
        spec: spec
    };
};

export const data = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.flat(4) : []
    }, {
        spec: spec
    };
};

export const arrayData = context => {
    const {dataTable: dataTable, spec: spec} = context;
    return spec.data = [ {
        id: "data",
        values: isValidDataTable(dataTable) ? dataTable.flat(4) : []
    } ], {
        spec: spec
    };
};

export const discreteLegend = context => {
    const {cell: cell, spec: spec} = context;
    return spec.legends || !cell.color && !cell.category && !spec.seriesField && "common" !== spec.type || (spec.legends = [ {
        orient: "right",
        type: "discrete",
        item: {
            visible: !0,
            background: {
                style: {}
            },
            label: {
                style: {}
            },
            shape: {
                style: {}
            }
        }
    } ]), {
        spec: spec
    };
};

export const theme = context => {
    const {chartTheme: chartTheme, spec: spec} = context;
    return "string" == typeof chartTheme ? Object.keys(builtinThemeMap).some((key => key === chartTheme && (spec.theme = builtinThemeMap[chartTheme], 
    !0))) : "object" == typeof chartTheme && (spec.theme = chartTheme), spec.theme && spec.theme.colorScheme && (spec.color = void 0), 
    {
        spec: spec
    };
};

export const color = context => {
    const {colors: colors, spec: spec, chartTheme: chartTheme} = context;
    return chartTheme || (colors && colors.length > 0 ? spec.color = colors : spec.color = COLOR_THEMES.default), 
    {
        spec: spec
    };
};

export const commonLabel = context => {
    const {spec: spec, fieldInfo: fieldInfo, cell: cell} = context, {y: celly} = cell;
    if (spec.label = {
        visible: !0
    }, isArray(celly) && celly.length > 1) ; else if (celly) {
        const field = isArray(celly) ? celly[0] : celly, info = fieldInfo.find((v => v.fieldName === field));
        (null == info ? void 0 : info.ratioGranularity) && (spec.label.formatter = `{${field}:~%}`);
    }
    return {
        spec: spec
    };
};

export const indicator = context => {
    var _a, _b;
    const {spec: spec, cell: cell} = context, firstEntry = spec.data.values[0];
    if (!firstEntry) return {
        spec: spec
    };
    const valueField = null !== (_a = cell.value) && void 0 !== _a ? _a : cell.y, value = firstEntry[valueField], cat = firstEntry[getFieldIdInCell(null !== (_b = cell.radius) && void 0 !== _b ? _b : cell.x)];
    return spec.indicator = {
        visible: !0,
        fixed: !0,
        trigger: "none",
        title: {
            visible: !0,
            autoLimit: !0,
            space: 12,
            style: {
                fontSize: 16,
                fill: "gray",
                text: null != cat ? cat : valueField
            }
        },
        content: [ {
            visible: !0,
            style: {
                fontSize: 20,
                fill: "#000",
                text: `${(100 * value).toFixed(1)}%`
            }
        } ]
    }, {
        spec: spec
    };
};

export const sunburstOrTreemapField = context => {
    const {spec: spec} = context;
    return spec.categoryField = "name", spec.valueField = "value", {
        spec: spec
    };
};

export function onlyUnique(value, index, array) {
    return array.indexOf(value) === index;
}

export const oneByOneDelayFunc = delay => datum => datum.__CHARTSPACE_DEFAULT_DATA_INDEX % oneByOneGroupSize * delay;

export const animationOneByOne = context => {
    var _a;
    const {spec: spec} = context;
    if ("wordCloud3d" === spec.type) return {
        spec: spec
    };
    const totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH_LONG, duration = animationDuration, dataLength = spec.data.values.length, delay = Math.max(totalTime / dataLength - duration, 0), finalDuration = 0 === delay ? totalTime / dataLength : duration, finalDelay = 0 === delay ? Number.MIN_VALUE : delay;
    return spec.animationAppear = {
        oneByOne: finalDelay,
        duration: finalDuration
    }, {
        spec: spec
    };
};

export const animationCartisianLine = context => {
    var _a;
    const {spec: spec} = context, totalTime = null !== (_a = context.totalTime) && void 0 !== _a ? _a : DEFAULT_VIDEO_LENGTH, groupKey = Array.isArray(spec.xField) ? spec.xField[0] : spec.xField, groups = spec.data.values.map((d => d[groupKey])).filter(onlyUnique), lineAnimationTotalTime = totalTime > 2e3 ? 2e3 : totalTime, pointDelay = lineAnimationTotalTime / groups.length;
    return spec.animationAppear = {
        line: {
            type: "clipIn",
            duration: lineAnimationTotalTime,
            easing: "linear"
        },
        point: {
            delay: datum => groups.findIndex((d => d === datum[groupKey])) * pointDelay
        }
    }, spec.animationNormal = {
        point: {
            loop: !0,
            timeSlices: [ {
                effects: {
                    channel: {
                        size: {
                            to: 14
                        }
                    },
                    easing: "circInOut"
                },
                duration: 1e3
            }, {
                effects: {
                    channel: {
                        size: {
                            to: 10
                        }
                    },
                    easing: "circInOut"
                },
                duration: 500
            } ]
        }
    }, {
        spec: spec
    };
};
//# sourceMappingURL=common.js.map
