{"version":3,"sources":["../src/atom/chartGenerator/spec/transformers/polar.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,wBAAwB,EAAE,MAAM,cAAc,CAAC;AACxD,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAEtC,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,OAAiC,EAAE,EAAE;;IAChE,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;IAEzB,MAAM,SAAS,GAAG,MAAA,OAAO,CAAC,SAAS,mCAAI,wBAAwB,CAAC;IAChE,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,KAAe,CAAC;IAC9C,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,MAAe,CAAC;IAC7C,MAAM,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAS,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;IAE7E,MAAM,QAAQ,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,GAAG,GAAG,CAAC;IAE5C,IAAI,QAAQ,GAAG,GAAG,GAAG,QAAQ,GAAG,SAAS,EAAE;QAEzC,IAAI,CAAC,eAAe,GAAG;YACrB,QAAQ,EAAE,MAAM,CAAC,SAAS;YAC1B,QAAQ,EAAE,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,QAAQ;YAC3C,OAAO,EAAE;gBACP,OAAO,EAAE,KAAK;aACf;SACF,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG;YACrB,GAAG,EAAE;gBACH;oBACE,SAAS,EAAE,GAAG;oBACd,QAAQ,EAAE,GAAG;oBACb,UAAU,EAAE;wBACV;4BACE,KAAK,EAAE,CAAC;4BACR,OAAO,EAAE;gCACP,OAAO,EAAE;oCACP,MAAM,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE;oCACnB,MAAM,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE;iCACpB;gCACD,MAAM,EAAE,QAAQ;6BACjB;4BACD,QAAQ,EAAE,GAAG;yBACd;wBACD;4BACE,OAAO,EAAE;gCACP,OAAO,EAAE;oCACP,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE;oCACjB,MAAM,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE;iCAClB;gCAED,MAAM,EAAE,QAAQ;6BACjB;4BACD,QAAQ,EAAE,GAAG;yBACd;qBACF;iBACF;aACF;SACF,CAAC;KACH;SAAM;QACL,IAAI,CAAC,eAAe,GAAG;YACrB,QAAQ,EAAE,MAAM,CAAC,SAAS;YAC1B,QAAQ,EAAE,SAAS,GAAG,QAAQ;YAC9B,OAAO,EAAE;gBACP,OAAO,EAAE,KAAK;aACf;SACF,CAAC;KACH;IACD,OAAO,EAAE,IAAI,EAAE,CAAC;AAClB,CAAC,CAAC","file":"polar.js","sourcesContent":["import type { GenerateChartCellContext } from '../../type';\nimport { DEFAULT_PIE_VIDEO_LENGTH } from '../constants';\nimport { onlyUnique } from './common';\n\nexport const animationPie = (context: GenerateChartCellContext) => {\n  const { spec } = context;\n\n  const totalTime = context.totalTime ?? DEFAULT_PIE_VIDEO_LENGTH;\n  const groupKey = context.cell.color as string;\n  const dataValues = spec.data.values as any[];\n  const groupNum = dataValues.map(d => d[groupKey!]).filter(onlyUnique).length;\n  //const delay = totalTime / groupNum - 1000;\n  const loopTime = 100 + groupNum * 100 + 400;\n  // 看看是否可以500ms走一个循环\n  if (groupNum * 500 + loopTime < totalTime) {\n    // 前面500ms的oneByone\n    spec.animationAppear = {\n      oneByOne: Number.MIN_VALUE,\n      duration: (totalTime - loopTime) / groupNum,\n      options: {\n        overall: false\n      }\n    };\n    // 然后走循环动画\n    spec.animationNormal = {\n      pie: [\n        {\n          startTime: 100,\n          oneByOne: 100,\n          timeSlices: [\n            {\n              delay: 0,\n              effects: {\n                channel: {\n                  scaleX: { to: 1.2 },\n                  scaleY: { to: 1.2 }\n                },\n                easing: 'linear'\n              },\n              duration: 200\n            },\n            {\n              effects: {\n                channel: {\n                  scaleX: { to: 1 },\n                  scaleY: { to: 1 }\n                },\n\n                easing: 'linear'\n              },\n              duration: 200\n            }\n          ]\n        }\n      ]\n    };\n  } else {\n    spec.animationAppear = {\n      oneByOne: Number.MIN_VALUE,\n      duration: totalTime / groupNum,\n      options: {\n        overall: false\n      }\n    };\n  }\n  return { spec };\n};\n"]}