import { ROLE, DataType, ChartType } from "../../../types";

import { formatTypeToVMind } from "../spec/chartTypeUtils";

import { unfoldTransform } from "../../../utils/unfold";

export const getRuleLLMContent = context => {
    const {fieldInfo: fieldInfo} = context, measureFields = fieldInfo.filter((field => field.role === ROLE.MEASURE));
    let chartType = null;
    const cell = {};
    return 1 === measureFields.length && measureFields[0].type === DataType.RATIO ? (chartType = ChartType.LiquidChart, 
    cell.value = measureFields[0].fieldName, {
        CHART_TYPE: chartType,
        FIELD_MAP: cell
    }) : null;
};

const formatDataTable = (simpleVChartSpec, data) => {
    if ("rangeColumn" === simpleVChartSpec.type) {
        const firstDatum = data[0];
        if (firstDatum && "group" in firstDatum) {
            const groups = data.reduce(((acc, cur) => (acc.includes(cur.group) || acc.push(cur.group), 
            acc)), []);
            if (2 === groups.length) {
                return unfoldTransform({
                    keyField: "group",
                    valueField: "value",
                    groupBy: "name"
                }, data).map((entry => ({
                    name: entry.name,
                    value: entry[groups[0]],
                    value1: entry[groups[1]]
                })));
            }
        }
    }
    return data;
};

export const getCellContextBySimpleVChartSpec = simpleVChartSpec => {
    var _a, _b, _c;
    const {type: type, transpose: transpose, stackOrPercent: stackOrPercent, coordinate: coordinate, data: data, series: series, palette: palette} = simpleVChartSpec, cell = {}, dataTable = formatDataTable(simpleVChartSpec, null != data ? data : series.reduce(((acc, cur) => (acc.push(...cur.data), 
    acc)), [])), firstDatum = null == dataTable ? void 0 : dataTable[0], chartType = "common" === type ? series && series.length >= 2 && series.some(((s, index) => index > 0 && s.type !== series[0].type)) ? type : "bar" === (null === (_a = null == series ? void 0 : series[0]) || void 0 === _a ? void 0 : _a.type) && "polar" === coordinate ? "rose" : null !== (_c = null === (_b = null == series ? void 0 : series[0]) || void 0 === _b ? void 0 : _b.type) && void 0 !== _c ? _c : type : type;
    firstDatum && "group" in firstDatum ? cell.color = "group" : palette && palette.length === dataTable.length && palette.length > 1 && (cell.color = "name"), 
    "polar" === coordinate ? ("pie" === type ? cell.angle = "value" : "rose" === type ? (cell.angle = "name", 
    cell.radius = "value") : "radar" === type && (cell.x = "name", cell.y = "value"), 
    cell.category = "name") : "rect" === coordinate || "funnel" === chartType ? (cell.x = "name", 
    cell.y = "value") : "circlePacking" === chartType && (cell.size = "value");
    const fieldInfo = [ "name", "value", "group" ].reduce(((res, field) => (firstDatum && field in firstDatum && res.push({
        fieldName: field,
        type: "value" === field ? DataType.FLOAT : DataType.STRING,
        role: "value" === field ? ROLE.MEASURE : ROLE.DIMENSION
    }), res)), []);
    return "rangeColumn" === chartType && "value1" in firstDatum && (cell.y = [ "value", "value1" ], 
    fieldInfo.push({
        fieldName: "value1",
        type: DataType.FLOAT,
        role: ROLE.MEASURE
    })), {
        mockLLMContent: {
            CHART_TYPE: formatTypeToVMind(chartType),
            FIELD_MAP: cell,
            stackOrPercent: stackOrPercent,
            transpose: transpose
        },
        ctx: {
            dataTable: dataTable,
            fieldInfo: fieldInfo
        }
    };
};
//# sourceMappingURL=index.js.map
