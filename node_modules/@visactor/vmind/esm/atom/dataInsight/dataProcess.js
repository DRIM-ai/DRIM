import { sumDimensionValues } from "./utils";

import { ChartType } from "../../types";

import { isArray, isValidNumber } from "@visactor/vutils";

import { DEFAULT_SERIES_NAME } from "./const";

import { getFieldInfoFromDataset } from "../../utils/field";

import { getCellFromSpec, getChartTypeFromSpec, getDatasetFromSpec, getFieldMappingFromSpec, revisedCell } from "../../utils/spec";

import { transferFieldInfo } from "../dataClean/utils";

import { transferMeasureInTable } from "../../utils/dataTable";

const getDimensionDataInfo = context => {
    const {xField: xField, yField: yField, onlyOneSeries: onlyOneSeries, dataset: dataset} = context, dimensionDataMap = {}, dimensionValues = [];
    dataset.forEach(((dataItem, index) => {
        const groupBy = dataItem[xField];
        groupBy && (dimensionDataMap[groupBy] || (dimensionDataMap[groupBy] = [], dimensionValues.push(groupBy)), 
        dimensionDataMap[groupBy].push({
            index: index,
            dataItem: dataItem
        }));
    }));
    const dimensionStackSumMap = {}, dimensionSumMap = {};
    return yField.forEach((measureId => {
        dimensionStackSumMap[measureId] = [], dimensionSumMap[measureId] = dimensionValues.map((dimension => {
            const dimensionDataset = dimensionDataMap[dimension].map((d => d.dataItem));
            return dimensionStackSumMap[measureId].push(sumDimensionValues(dimensionDataset, measureId, (v => v))), 
            sumDimensionValues(dimensionDataset, measureId, onlyOneSeries ? v => v : void 0);
        }));
    })), {
        dimensionDataMap: dimensionDataMap,
        dimensionValues: dimensionValues,
        dimensionSumMap: dimensionSumMap,
        dimensionStackSumMap: dimensionStackSumMap
    };
}, getDataBySeries = context => {
    var _a, _b;
    const {spec: spec, xField: xField, seriesField: seriesField, position: position, yField: yField} = context, {series: series = [], _vmindAxesDiffKey: _vmindAxesDiffKey = "_editor_axis_orient", data: data, axes: axes = []} = spec, currentAxis = axes.find((v => position.includes(v.orient))), axisTitle = null === (_a = null == currentAxis ? void 0 : currentAxis.title) || void 0 === _a ? void 0 : _a.text;
    let currentSeries = [], seriesIndex = null, seriesId = "";
    (null == currentAxis ? void 0 : currentAxis.seriesId) ? (seriesId = null == currentAxis ? void 0 : currentAxis.seriesId, 
    currentSeries = series.filter((s => currentAxis.seriesId.includes(s.id)))) : (null == currentAxis ? void 0 : currentAxis.seriesIndex) ? (seriesIndex = null == currentAxis ? void 0 : currentAxis.seriesIndex, 
    currentSeries = currentAxis.seriesIndex.map((v => series[v])).filter((s => !!s))) : (series.filter((s => position.includes(s[_vmindAxesDiffKey]))), 
    seriesId = (series || []).map((v => v.id)).filter((v => !!v)));
    const dataList = [];
    currentSeries.forEach((s => {
        var _a, _b, _c;
        (null === (_a = null == s ? void 0 : s.data) || void 0 === _a ? void 0 : _a.values) ? dataList.push(...s.data.values) : (null == s ? void 0 : s.dataId) ? dataList.push(...(null === (_b = data.find((subData => subData.id === s.dataId))) || void 0 === _b ? void 0 : _b.values) || []) : isValidNumber(null == s ? void 0 : s.dataIndex) && dataList.push(...(null === (_c = null == data ? void 0 : data[s.dataIndex]) || void 0 === _c ? void 0 : _c.values) || []);
    }));
    const seriesNames = seriesField ? [ ...new Set(dataList.map((d => d[seriesField]))) ] : [];
    return Object.assign({
        dataset: dataList,
        series: currentSeries,
        seriesNames: seriesNames,
        axisTitle: axisTitle,
        seriesIndex: isArray(seriesIndex) ? seriesIndex[0] : seriesIndex,
        seriesId: isArray(seriesId) ? null == seriesId ? void 0 : seriesId[0] : seriesId,
        yField: null === (_b = null == currentSeries ? void 0 : currentSeries[0]) || void 0 === _b ? void 0 : _b.yField
    }, getDimensionDataInfo({
        xField: xField,
        yField: yField,
        onlyOneSeries: 1 === seriesNames.length,
        dataset: dataList
    }));
};

export const extractAxesData = context => {
    const {chartType: chartType} = context;
    return chartType !== ChartType.DualAxisChart ? {} : {
        leftAxesDataList: getDataBySeries(Object.assign(Object.assign({}, context), {
            position: [ "left" ]
        })),
        rightAxesDataList: getDataBySeries(Object.assign(Object.assign({}, context), {
            position: [ "right" ]
        }))
    };
};

export const extractDataFromContext = context => {
    var _a;
    const {spec: spec, fieldInfo: inputFieldInfo, dataTable: dataTable, vChartType: vChartType} = context, chartType = getChartTypeFromSpec(spec, vChartType);
    if (!chartType) return console.error("unsupported spec type"), null;
    let dataset = dataTable;
    dataset && 0 !== (null == dataset ? void 0 : dataset.length) || (dataset = getDatasetFromSpec(spec));
    const specFieldMapping = getFieldMappingFromSpec(spec);
    let fieldInfo = inputFieldInfo;
    fieldInfo && 0 !== (null == fieldInfo ? void 0 : fieldInfo.length) || (fieldInfo = getFieldInfoFromDataset(dataset)), 
    fieldInfo = null === (_a = transferFieldInfo({
        fieldInfo: fieldInfo
    }, specFieldMapping)) || void 0 === _a ? void 0 : _a.fieldInfo;
    const originDataset = dataset;
    dataset = transferMeasureInTable(dataset, fieldInfo);
    const cell = revisedCell(getCellFromSpec(spec, chartType), dataset), {color: color, x: cellx, y: celly} = cell, seriesField = isArray(color) ? color[0] : color, seriesDataMap = {};
    seriesField && ![ ChartType.PieChart, ChartType.RoseChart ].includes(chartType) ? dataset.forEach(((dataItem, index) => {
        const groupBy = dataItem[seriesField];
        !groupBy || chartType === ChartType.WaterFallChart && "total" === groupBy || (seriesDataMap[groupBy] || (seriesDataMap[groupBy] = []), 
        seriesDataMap[groupBy].push({
            index: index,
            dataItem: dataItem
        }));
    })) : seriesDataMap[DEFAULT_SERIES_NAME] = dataset.map(((dataItem, index) => ({
        index: index,
        dataItem: dataItem
    })));
    const xField = isArray(cellx) ? cellx[0] : cellx, yField = isArray(celly) ? celly.flat() : [ celly ], onlyOneSeries = 1 === Object.keys(seriesDataMap).length;
    return Object.assign(Object.assign({
        dataset: dataset,
        originDataset: originDataset,
        fieldInfo: fieldInfo,
        chartType: chartType,
        seriesDataMap: seriesDataMap,
        cell: cell
    }, getDimensionDataInfo({
        xField: xField,
        yField: yField,
        onlyOneSeries: onlyOneSeries,
        dataset: dataset
    })), extractAxesData({
        spec: spec,
        chartType: chartType,
        seriesField: seriesField,
        yField: yField,
        xField: xField
    }));
};
//# sourceMappingURL=dataProcess.js.map