import { isArray, isNumber } from "@visactor/vutils";

import { InsightType } from "../../type";

import { isPercenSeries } from "../../utils";

const getExtremeValue = (dataset, measureId, seriesName, propsLowerThreshold, propsUpperThreshold) => {
    if (!dataset || 0 === dataset.length) return [];
    const lowerThreshold = null != propsLowerThreshold ? propsLowerThreshold : .2, upperThreshold = null != propsUpperThreshold ? propsUpperThreshold : 5, result = [], avg = dataset.map((d => d.dataItem)).reduce(((prev, cur) => {
        const numValue = parseFloat(cur[measureId]);
        return prev + (isNumber(numValue) ? Math.abs(numValue) : 0);
    }), 0) / dataset.length;
    return avg - 0 <= Number.EPSILON ? [] : (dataset.forEach((d => {
        const numValue = parseFloat(d.dataItem[measureId]), percent = (isNumber(numValue) ? Math.abs(numValue) : 0) / avg;
        percent > upperThreshold && result.push({
            type: InsightType.ExtremeValue,
            data: [ d ],
            value: d.dataItem[measureId],
            significant: percent / upperThreshold,
            fieldId: measureId,
            seriesName: seriesName,
            info: {
                type: "extreme_high",
                averageValue: avg,
                percent: percent
            }
        }), percent - 0 > Number.EPSILON && percent < lowerThreshold && result.push({
            type: InsightType.ExtremeValue,
            data: [ d ],
            value: d.dataItem[measureId],
            significant: lowerThreshold / percent,
            fieldId: measureId,
            seriesName: seriesName,
            info: {
                type: "extreme_low",
                averageValue: avg,
                percent: percent
            }
        });
    })), result);
}, calcExtremeValue = (context, options) => {
    const {seriesDataMap: seriesDataMap, cell: cell, spec: spec} = context, {y: celly} = cell, {upperThreshold: upperThreshold, lowerThreshold: lowerThreshold} = options || {}, yField = isArray(celly) ? celly.flat() : [ celly ], result = [];
    return Object.keys(seriesDataMap).forEach((series => {
        const dataset = seriesDataMap[series];
        yField.forEach((measure => {
            if (isPercenSeries(spec, measure)) return;
            const insights = getExtremeValue(dataset, measure, series, lowerThreshold, upperThreshold);
            result.push(...insights);
        }));
    })), [];
};

export const ExtremeValue = {
    name: "extremeValue",
    insightType: InsightType.ExtremeValue,
    algorithmFunction: calcExtremeValue,
    supportStack: !0,
    supportPercent: !1
};
//# sourceMappingURL=index.js.map
