import { isArray } from "@visactor/vutils";

import { InsightType } from "../type";

import { ChartType } from "../../../types";

const filterInsight = (insights, type) => insights.filter((insight => insight.type === type)), getBandInsightByOutliear = (context, outliearFieldMapping) => {
    const bandInsightKeys = [], abnormalBand = [], {dimensionValues: dimensionValues, cell: cell, chartType: chartType} = context;
    if (![ ChartType.DualAxisChart, ChartType.LineChart, ChartType.BarChart, ChartType.AreaChart, ChartType.WaterFallChart ].includes(chartType)) return {
        bandInsightKeys: bandInsightKeys,
        abnormalBand: abnormalBand
    };
    const {x: cellx} = cell, xField = isArray(cellx) ? cellx[0] : cellx;
    return Object.keys(outliearFieldMapping).forEach((fieldId => {
        var _a;
        const indexOfInsights = outliearFieldMapping[fieldId].map((content => {
            const xValue = content.insight.data[0].dataItem[xField];
            return {
                xIndex: dimensionValues.indexOf(xValue),
                content: content
            };
        })).sort(((a, b) => a.xIndex - b.xIndex));
        let band = [ indexOfInsights[0] ];
        for (let i = 1; i <= indexOfInsights.length; i++) {
            const curIndex = null === (_a = indexOfInsights[i]) || void 0 === _a ? void 0 : _a.xIndex, prevIndex = band[band.length - 1].xIndex;
            i < indexOfInsights.length && curIndex - prevIndex == 1 ? band.push(indexOfInsights[i]) : (band.length > 1 && (abnormalBand.push({
                type: InsightType.AbnormalBand,
                name: InsightType.AbnormalBand,
                data: band.map((v => v.content.insight.data[0])),
                seriesName: fieldId,
                value: null,
                significant: band.length,
                info: {
                    startValue: band[0].content.insight.data[0].dataItem[xField],
                    endValue: band[band.length - 1].content.insight.data[0].dataItem[xField],
                    xField: xField
                }
            }), bandInsightKeys.push(...band.map((v => v.content.key)))), band = [ indexOfInsights[i] ]);
        }
    })), {
        abnormalBand: abnormalBand,
        bandInsightKeys: bandInsightKeys
    };
};

export const mergePointInsight = (insightCtx, type, context) => {
    const outliear = {}, {insights: insights} = insightCtx, outliearFieldMapping = {}, filterOutliearInsight = filterInsight(insights, InsightType.Outlier);
    filterOutliearInsight.forEach((insight => {
        const {data: data} = insight, seriesName = null == insight ? void 0 : insight.seriesName, key = `${data[0].index}-&&&-${seriesName}`;
        outliear[key] || (outliear[key] = [], outliearFieldMapping[seriesName] || (outliearFieldMapping[seriesName] = []), 
        outliearFieldMapping[seriesName].push({
            insight: insight,
            key: key
        })), outliear[key].push(insight);
    }));
    const majorityValueInsight = filterInsight(insights, InsightType.MajorityValue).filter((insight => {
        const {data: data} = insight, seriesName = null == insight ? void 0 : insight.seriesName, key = `${data[0].index}-&&&-${seriesName}`;
        return !outliear[key];
    })), pairOutlier = filterPairInsight(insights, filterOutliearInsight), turnPointInsight = filterInsight(insights, InsightType.TurningPoint), {abnormalBand: abnormalBand, bandInsightKeys: bandInsightKeys} = getBandInsightByOutliear(context, outliearFieldMapping);
    bandInsightKeys.forEach((key => {
        delete outliear[key];
    })), turnPointInsight.forEach((insight => {
        const {data: data} = insight, seriesName = null == insight ? void 0 : insight.seriesName, key = `${data[0].index}-&&&-${seriesName}`;
        outliear[key] && delete outliear[key];
    }));
    const outliearInsight = Object.keys(outliear).map((key => Object.assign(Object.assign({}, outliear[key][0]), {
        significant: outliear[key].reduce(((prev, cur) => prev + cur.significant), 0)
    })));
    return Object.assign(Object.assign({}, insightCtx), {
        [InsightType.Outlier]: outliearInsight,
        [InsightType.PairOutlier]: pairOutlier,
        [InsightType.TurningPoint]: turnPointInsight,
        [InsightType.AbnormalBand]: abnormalBand,
        [InsightType.MajorityValue]: majorityValueInsight
    });
};

const filterPairInsight = (insights, outliers) => {
    const pairs = filterInsight(insights, InsightType.PairOutlier), outlierKeys = new Set;
    return outliers.forEach((insight => {
        const {data: data, seriesName: seriesName} = insight, key = `${data[0].index}-&&&-${seriesName}`;
        outlierKeys.add(key);
    })), pairs.filter((v => {
        const {data: data, seriesName: seriesName} = v, keyList = data.map((v => `${v.index}-&&&-${seriesName}`));
        return !keyList.find((key => outlierKeys.has(key)));
    }));
};

export const filterCorrelationInsight = insightCtx => {
    const {insights: insights} = insightCtx, abnormalTrend = filterInsight(insights, InsightType.AbnormalTrend), trendFields = new Set(abnormalTrend.map((insight => insight.seriesName))), correlation = filterInsight(insights, InsightType.Correlation).filter((insight => "pearson-coefficient" === insight.name || isArray(insight.seriesName) && !insight.seriesName.find((seriesName => trendFields.has(seriesName)))));
    return Object.assign(Object.assign({}, insightCtx), {
        [InsightType.Correlation]: correlation
    });
};

export const filterInsightByType = (insightCtx, type) => Object.assign(Object.assign({}, insightCtx), {
    [type]: (null == insightCtx ? void 0 : insightCtx[type]) ? null == insightCtx ? void 0 : insightCtx[type] : filterInsight(insightCtx.insights, type)
});
//# sourceMappingURL=revised.js.map
