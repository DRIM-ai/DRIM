import { AlgorithmType, InsightType } from "../type";

import { AbnormalTrend } from "./abnormalTrend";

import { ScatterPlotCorrelation } from "./correlation/pearson";

import { LineChartCorrelation } from "./correlation/spearman";

import { ExtremeValue } from "./extremeValue";

import { LineChartMajorityValue } from "./majorityValue";

import { DBSCANOutlier } from "./outlier/dbscan";

import { LOFOutlier } from "./outlier/lof";

import { OverallTrending } from "./overallTrending";

import { TurningPoint } from "./turningPoint";

import { Volatility } from "./volatility";

import { StatisticsAlo } from "./outlier/statistics";

import { filterCorrelationInsight, filterInsightByType, mergePointInsight } from "./revised";

import { DifferenceAlg } from "./outlier/difference";

import { PageHinkleyAlg } from "./drift";

import { generateInsightTemplate } from "./template";

import { isPercentChart, isStackChart } from "../utils";

import { BaseStatistics } from "./base/baseStatistics";

const algorithmMapping = {
    [AlgorithmType.OverallTrending]: {
        info: OverallTrending,
        priority: 1
    },
    [AlgorithmType.AbnormalTrend]: {
        info: AbnormalTrend,
        priority: 2
    },
    [AlgorithmType.PearsonCorrelation]: {
        info: ScatterPlotCorrelation,
        priority: 3
    },
    [AlgorithmType.SpearmanCorrelation]: {
        info: LineChartCorrelation,
        priority: 4
    },
    [AlgorithmType.ExtremeValue]: {
        info: ExtremeValue,
        priority: 5
    },
    [AlgorithmType.MajorityValue]: {
        info: LineChartMajorityValue,
        priority: 6
    },
    [AlgorithmType.StatisticsAbnormal]: {
        info: StatisticsAlo,
        priority: 7
    },
    [AlgorithmType.LOFOutlier]: {
        info: LOFOutlier,
        priority: 8
    },
    [AlgorithmType.DifferenceOutlier]: {
        info: DifferenceAlg,
        priority: 9
    },
    [AlgorithmType.TurningPoint]: {
        info: TurningPoint,
        priority: 10
    },
    [AlgorithmType.PageHinkley]: {
        info: PageHinkleyAlg,
        priority: 10
    },
    [AlgorithmType.DbscanOutlier]: {
        info: DBSCANOutlier,
        priority: 11
    },
    [AlgorithmType.Volatility]: {
        info: Volatility,
        priority: 12
    },
    [AlgorithmType.StatisticsBase]: {
        info: BaseStatistics,
        priority: 13
    }
}, InsightSortMapping = {
    [InsightType.Min]: 0,
    [InsightType.Max]: 0,
    [InsightType.Avg]: 0,
    [InsightType.Outlier]: 1,
    [InsightType.PairOutlier]: 2,
    [InsightType.AbnormalBand]: 10,
    [InsightType.ExtremeValue]: 1,
    [InsightType.TurningPoint]: 1,
    [InsightType.MajorityValue]: 1,
    [InsightType.AbnormalTrend]: 2,
    [InsightType.OverallTrend]: 2,
    [InsightType.Correlation]: 2,
    [InsightType.Volatility]: 2
}, revisedInsightByTypeMapping = {
    [InsightType.Outlier]: mergePointInsight,
    [InsightType.PairOutlier]: null,
    [InsightType.AbnormalBand]: null,
    [InsightType.ExtremeValue]: filterInsightByType,
    [InsightType.TurningPoint]: null,
    [InsightType.MajorityValue]: filterInsightByType,
    [InsightType.AbnormalTrend]: filterInsightByType,
    [InsightType.OverallTrend]: filterInsightByType,
    [InsightType.Correlation]: filterCorrelationInsight,
    [InsightType.Volatility]: filterInsightByType,
    [InsightType.Min]: filterInsightByType,
    [InsightType.Max]: filterInsightByType,
    [InsightType.Avg]: filterInsightByType
};

export const getInsights = (context, options) => {
    const {algorithms: algorithms, maxNum: maxNum, isLimitedbyChartType: isLimitedbyChartType, detailMaxNum: detailMaxNum = [], language: language} = options, {chartType: chartType, cell: cell, spec: spec, originDataset: originDataset} = context, insights = [], insightAlgorithmContext = Object.assign(Object.assign({}, context), {
        insights: insights
    }), isStack = isStackChart(spec, chartType, cell), isPercent = isPercentChart(spec, chartType, cell);
    algorithms.sort(((a, b) => algorithmMapping[a].priority - algorithmMapping[b].priority)), 
    algorithms.forEach((key => {
        var _a;
        const algoInfo = algorithmMapping[key].info, {chartType: algoSupportedChartType, algorithmFunction: algorithmFunction, forceChartType: forceChartType, name: name, canRun: canRun, supportPercent: supportPercent, supportStack: supportStack} = algoInfo;
        if ((!forceChartType || forceChartType.includes(chartType)) && (!isLimitedbyChartType || !algoSupportedChartType || algoSupportedChartType.includes(chartType)) && (!canRun || canRun(insightAlgorithmContext)) && (isStack && !1 !== supportStack || !isStack) && (!isPercent || isPercent && !1 !== supportPercent)) {
            const res = algorithmFunction(insightAlgorithmContext, null === (_a = null == options ? void 0 : options.algorithmOptions) || void 0 === _a ? void 0 : _a[key]);
            insights.push(...res.map((v => {
                var _a;
                return Object.assign(Object.assign({}, v), {
                    data: (null === (_a = v.info) || void 0 === _a ? void 0 : _a.isAxesArea) ? v.data : (v.data || []).map((vv => ({
                        index: vv.index,
                        dataItem: originDataset[vv.index]
                    }))),
                    name: name
                });
            })));
        }
    }));
    let res = {
        insights: insights
    };
    Object.keys(revisedInsightByTypeMapping).forEach((type => {
        const revisedFunc = revisedInsightByTypeMapping[type];
        revisedFunc && (res = revisedFunc(res, type, context));
    }));
    const revisedInsights = [];
    Object.keys(revisedInsightByTypeMapping).forEach((type => {
        revisedInsights.push(...res[type]);
    })), revisedInsights.sort(((a, b) => {
        var _a, _b;
        const significant1 = null !== (_a = a.significant) && void 0 !== _a ? _a : -1, significant2 = null !== (_b = b.significant) && void 0 !== _b ? _b : -1;
        return InsightSortMapping[a.type] > InsightSortMapping[b.type] || InsightSortMapping[a.type] === InsightSortMapping[b.type] && significant2 - significant1 >= 0 ? -1 : 1;
    }));
    let afterLimitsInsights = [ ...revisedInsights ];
    detailMaxNum.forEach((item => {
        const {types: types, maxNum: maxNum} = item, filteredInsights = revisedInsights.filter((insight => types.includes(insight.type))).slice(maxNum);
        afterLimitsInsights = afterLimitsInsights.filter((insight => !filteredInsights.includes(insight)));
    }));
    return generateInsightTemplate(maxNum ? afterLimitsInsights.slice(0, maxNum) : afterLimitsInsights, context, language);
};
//# sourceMappingURL=index.js.map
