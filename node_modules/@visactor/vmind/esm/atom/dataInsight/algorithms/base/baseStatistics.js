import { isArray, isValidNumber } from "@visactor/vutils";

import { ChartType } from "../../../../types";

import { InsightType } from "../../type";

import { isStackChart, isStackChartInAxes } from "../../utils";

const getMinMaxAvg = data => {
    const min = {
        index: -1,
        value: 1 / 0
    }, max = {
        index: -1,
        value: -1 / 0
    };
    let sum = 0, validCount = 0;
    return data.forEach(((value, index) => {
        isValidNumber(value) && (sum += value, validCount++, value < min.value && (min.index = index, 
        min.value = value), value > max.value && (max.index = index, max.value = value));
    })), {
        min: min,
        max: max,
        avg: sum / validCount
    };
}, getBaseInsightByDataset = context => {
    const {xField: xField, measureId: measureId, dataset: dataset, isStack: isStack, dimensionValues: dimensionValues, dimensionStackSumMap: dimensionStackSumMap, axisTitle: axisTitle = [], isAxesArea: isAxesArea = !1, axesDirection: axesDirection, seriesId: seriesId, seriesIndex: seriesIndex} = context, dataList = dataset.map(((d, index) => ({
        index: index,
        dataItem: d
    }))), result = [], yField = isArray(measureId) ? measureId[0] : measureId, valueList = isStack ? dimensionStackSumMap[yField] : dataList.map((d => Number(d.dataItem[yField]))), {min: min, max: max, avg: avg} = getMinMaxAvg(valueList), titleName = (isArray(axisTitle) ? null == axisTitle ? void 0 : axisTitle[0] : axisTitle) || "";
    return -1 !== min.index && result.push({
        name: "min",
        type: InsightType.Min,
        fieldId: yField,
        value: min.value,
        significant: 1,
        data: isStack ? dataList.filter((d => d.dataItem[xField] === dimensionValues[min.index])) : [ {
            index: min.index,
            dataItem: dataList[min.index].dataItem
        } ],
        info: {
            seriesId: seriesId,
            seriesIndex: seriesIndex,
            isAxesArea: isAxesArea,
            titleName: titleName,
            isGroup: isStack,
            dimValue: isStack ? dimensionValues[min.index] : dataList[min.index].dataItem[xField]
        }
    }), -1 !== max.index && result.push({
        name: "max",
        type: InsightType.Max,
        fieldId: yField,
        value: max.value,
        significant: 1,
        data: isStack ? dataList.filter((d => d.dataItem[xField] === dimensionValues[max.index])) : [ {
            index: max.index,
            dataItem: dataList[max.index].dataItem
        } ],
        info: {
            isAxesArea: isAxesArea,
            titleName: titleName,
            seriesId: seriesId,
            seriesIndex: seriesIndex,
            isGroup: isStack,
            dimValue: isStack ? dimensionValues[max.index] : dataList[max.index].dataItem[xField]
        }
    }), isValidNumber(avg) && result.push({
        name: "avg",
        type: InsightType.Avg,
        fieldId: yField,
        value: avg,
        significant: 1,
        data: [],
        info: {
            seriesId: seriesId,
            seriesIndex: seriesIndex,
            isAxesArea: isAxesArea,
            titleName: titleName,
            axesDirection: axesDirection
        }
    }), result;
}, BaseStatisticsFunction = (context, options) => {
    const result = [], {spec: spec, chartType: chartType, cell: cell, leftAxesDataList: leftAxesDataList, rightAxesDataList: rightAxesDataList} = context, {y: celly, x: cellx} = cell, xField = isArray(cellx) ? cellx[0] : cellx, yField = isArray(celly) ? celly[0] : celly, baseInfo = Object.assign(Object.assign({}, context), {
        xField: xField,
        measureId: yField
    });
    return leftAxesDataList && result.push(...getBaseInsightByDataset(Object.assign(Object.assign(Object.assign({}, baseInfo), leftAxesDataList), {
        isAxesArea: !0,
        measureId: null == leftAxesDataList ? void 0 : leftAxesDataList.yField,
        axisTitle: leftAxesDataList.axisTitle || (null == options ? void 0 : options.defaultLeftAxisName),
        isStack: isStackChartInAxes(leftAxesDataList.series, chartType),
        axesDirection: "left"
    }))), rightAxesDataList && result.push(...getBaseInsightByDataset(Object.assign(Object.assign(Object.assign({}, baseInfo), rightAxesDataList), {
        isAxesArea: !0,
        measureId: null == rightAxesDataList ? void 0 : rightAxesDataList.yField,
        axisTitle: rightAxesDataList.axisTitle || (null == options ? void 0 : options.defaultRightAxisName),
        isStack: isStackChartInAxes(rightAxesDataList.series, chartType),
        axesDirection: "right"
    }))), !leftAxesDataList && !rightAxesDataList && result.push(...getBaseInsightByDataset(Object.assign(Object.assign({}, baseInfo), {
        axisTitle: "",
        seriesId: "",
        seriesIndex: null,
        isStack: isStackChart(spec, chartType, cell)
    }))), result;
};

export const BaseStatistics = {
    name: "base",
    forceChartType: [ ChartType.DualAxisChart, ChartType.LineChart, ChartType.BarChart, ChartType.AreaChart ],
    insightType: InsightType.Min,
    supportPercent: !1,
    algorithmFunction: BaseStatisticsFunction
};
//# sourceMappingURL=baseStatistics.js.map
