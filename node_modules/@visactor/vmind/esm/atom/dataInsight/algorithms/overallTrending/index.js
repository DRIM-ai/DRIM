import { isArray, isValidNumber } from "@visactor/vutils";

import { longestTrendInterval, originalMKTest, TrendType } from "../statistics";

import { InsightType } from "../../type";

import { ChartType } from "../../../../types";

import { isPercentChart, isStackChart } from "../../utils";

import { findLastIndex } from "../../../../utils/common";

export const overallTrendingAlgo = (context, options) => {
    const {cell: cell, dimensionSumMap: dimensionSumMap, dimensionValues: dimensionValues} = context, {alpha: alpha = .05, calcScope: calcScope = !1} = options || {}, result = [], {y: celly, x: cellx} = cell, yField = isArray(celly) ? celly.flat() : [ celly ], xField = isArray(cellx) ? cellx[0] : cellx;
    return yField.forEach((measureId => {
        const overallDataset = dimensionSumMap[measureId], {trend: trend, pValue: pValue, zScore: zScore, slope: slope, intercept: intercept} = originalMKTest(overallDataset, alpha, calcScope);
        if (trend !== TrendType.NO_TREND) {
            const {length: length, start: start, end: end, maxTrend: maxTrend} = longestTrendInterval(overallDataset, trend), overallEndIndex = findLastIndex(overallDataset, (v => isValidNumber(v))), onverallStartIndex = overallDataset.findIndex((v => isValidNumber(v))), overallChange = 0 === overallDataset[onverallStartIndex] ? -overallDataset[overallEndIndex] : overallDataset[overallEndIndex] / overallDataset[onverallStartIndex] - 1;
            (trend === TrendType.INCREASING && overallChange > 0 || trend === TrendType.DECREASING && overallChange < 0) && result.push({
                type: InsightType.OverallTrend,
                fieldId: measureId,
                value: trend,
                significant: 1 - pValue,
                info: {
                    slope: slope,
                    intercept: intercept,
                    length: length,
                    overall: {
                        coordinates: [ {
                            [xField]: dimensionValues[onverallStartIndex],
                            [measureId]: overallDataset[onverallStartIndex]
                        }, {
                            [xField]: dimensionValues[overallEndIndex],
                            [measureId]: overallDataset[overallEndIndex]
                        } ],
                        start: onverallStartIndex,
                        end: overallEndIndex,
                        change: overallChange,
                        startValue: overallDataset[onverallStartIndex],
                        endValue: overallDataset[overallEndIndex],
                        startDimValue: dimensionValues[onverallStartIndex],
                        endDimValue: dimensionValues[overallEndIndex]
                    },
                    start: start,
                    end: end,
                    maxTrend: maxTrend,
                    change: 0 === overallDataset[start] ? -overallDataset[end] : overallDataset[end] / overallDataset[start] - 1,
                    startDimValue: dimensionValues[start],
                    endDimValue: dimensionValues[end],
                    startValue: overallDataset[start],
                    endValue: overallDataset[end]
                }
            });
        }
    })), result;
};

const canRun = context => {
    const {seriesDataMap: seriesDataMap, chartType: chartType, cell: cell, spec: spec} = context;
    return isStackChart(spec, chartType, cell) && !isPercentChart(spec, chartType, cell) || 1 === Object.keys(seriesDataMap).length;
};

export const OverallTrending = {
    name: "overallTrending",
    forceChartType: [ ChartType.LineChart, ChartType.BarChart, ChartType.AreaChart ],
    insightType: InsightType.OverallTrend,
    canRun: canRun,
    algorithmFunction: overallTrendingAlgo
};
//# sourceMappingURL=index.js.map
