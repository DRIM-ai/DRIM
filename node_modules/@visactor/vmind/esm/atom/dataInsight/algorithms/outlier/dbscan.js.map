{"version":3,"sources":["../src/atom/dataInsight/algorithms/outlier/dbscan.ts"],"names":[],"mappings":"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","file":"dbscan.js","sourcesContent":["import { isArray } from '@visactor/vutils';\n\nimport clustering from 'density-clustering';\nimport normalize from 'array-normalize';\nimport type { InsightAlgorithm } from '../../type';\nimport { InsightType, type DataInsightExtractContext, type Insight } from '../../type';\nimport type { FieldInfo } from '../../../../types';\nimport { ChartType, ROLE, type DataItem } from '../../../../types';\n\nexport interface DbscanOptions {\n  eps?: number;\n  minPts?: number;\n}\n\nconst isMeasureField = (field: string, fieldInfo: FieldInfo[]) => {\n  const fieldInfoItem = fieldInfo.find(v => v.fieldName === field);\n  return fieldInfoItem && fieldInfoItem.role === ROLE.MEASURE;\n};\n\nconst dbscanAlgo = (context: DataInsightExtractContext, options: DbscanOptions) => {\n  const { seriesDataMap, cell, fieldInfo } = context;\n  const { eps = 0.2, minPts = 5 } = options || {};\n  const { y: celly, x: cellx, color, size } = cell;\n\n  const yField: string[] = isArray(celly) ? celly.flat() : [celly];\n  const xField: string = isArray(cellx) ? cellx[0] : cellx;\n  const colorField: string = isArray(color) ? color[0] : color;\n  const sizeField: string = isArray(size) ? size[0] : size;\n  const allMeasureFields = [colorField, sizeField].filter(v => !!v && isMeasureField(v, fieldInfo));\n\n  const result: Insight[] = [];\n  Object.keys(seriesDataMap).forEach(series => {\n    const seriesDataset: { index: number; dataItem: DataItem }[] = seriesDataMap[series];\n    if (seriesDataset.length <= minPts || seriesDataset.length < 5) {\n      return;\n    }\n    const flatDataset = seriesDataset.reduce(\n      (prev: any, cur: any) => [\n        ...prev,\n        cur.dataItem[xField] ?? 0,\n        cur.dataItem[yField[0]] ?? 0,\n        ...allMeasureFields.map(v => cur.dataItem[v] ?? 0)\n      ],\n      []\n    );\n    const dimensionCount = 2 + allMeasureFields.length;\n\n    const normalizedDataset = normalize(flatDataset, dimensionCount);\n\n    const clusterDataset = [];\n    for (let index = 0; index < normalizedDataset.length; index += dimensionCount) {\n      const item = normalizedDataset.slice(index, index + dimensionCount);\n      clusterDataset.push(item);\n    }\n\n    const dbscan = new clustering.DBSCAN();\n    /** @todo add clusters */\n    const clusters = dbscan.run(clusterDataset, eps, minPts);\n    const noises = dbscan.noise;\n\n    const insights = noises.map((noiseIndex: number) => {\n      const d = seriesDataset[noiseIndex];\n      return {\n        type: InsightType.Outlier,\n        data: [d],\n        fieldId: [xField, yField[0]],\n        value: [d.dataItem[xField], d.dataItem[yField[0]]],\n        significant: 1,\n        seriesName: series\n      } as unknown as Insight;\n    });\n    result.push(...insights);\n  });\n  return result;\n};\n\nexport const DBSCANOutlier: InsightAlgorithm = {\n  name: 'dbscan',\n  chartType: [ChartType.ScatterPlot],\n  forceChartType: [ChartType.ScatterPlot],\n  insightType: InsightType.Outlier,\n  algorithmFunction: dbscanAlgo\n};\n"]}