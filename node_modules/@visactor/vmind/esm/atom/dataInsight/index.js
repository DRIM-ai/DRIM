import { AtomName } from "../../types/atom";

import { BaseAtom } from "../base";

import { merge } from "@visactor/vutils";

import { extractDataFromContext } from "./dataProcess";

import { AlgorithmType } from "./type";

import { getInsights } from "./algorithms";

import { getPolishPrompt } from "./prompt";

import { addPlainText } from "./algorithms/template";

import { Factory } from "../../core/factory";

export class DataInsightAtom extends BaseAtom {
    constructor(context, option) {
        super(context, option), this.name = AtomName.DATA_INSIGHT, this.isLLMAtom = !0;
    }
    buildDefaultContext(context) {
        return merge({}, {
            spec: {},
            insights: []
        }, context);
    }
    buildDefaultOptions() {
        return Object.assign(Object.assign({}, super.buildDefaultOptions()), {
            algorithms: [ AlgorithmType.OverallTrending, AlgorithmType.AbnormalTrend, AlgorithmType.PearsonCorrelation, AlgorithmType.SpearmanCorrelation, AlgorithmType.StatisticsAbnormal, AlgorithmType.LOFOutlier, AlgorithmType.DbscanOutlier, AlgorithmType.MajorityValue, AlgorithmType.PageHinkley, AlgorithmType.TurningPoint, AlgorithmType.StatisticsBase, AlgorithmType.Volatility ],
            isLimitedbyChartType: !0,
            language: "chinese",
            usePolish: !0
        });
    }
    shouldRunByContextUpdate(context) {
        return !0;
    }
    getLLMMessages(query) {
        var _a;
        const {insights: insights} = this.context, language = null === (_a = this.options) || void 0 === _a ? void 0 : _a.language, addtionContent = this.getHistoryLLMMessages(query);
        return [ {
            role: "system",
            content: getPolishPrompt(language)
        }, {
            role: "user",
            content: JSON.stringify({
                insights: insights.map((insight => {
                    var _a, _b;
                    return {
                        type: insight.type,
                        content: null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.content,
                        variables: (null === (_b = insight.textContent) || void 0 === _b ? void 0 : _b.variables) ? Object.keys(insight.textContent.variables).reduce(((acc, key) => {
                            var _a;
                            return Object.assign(Object.assign({}, acc), {
                                [key]: Object.assign(Object.assign({}, null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.variables[key]), {
                                    value: null,
                                    formatValue: null
                                })
                            });
                        }), {}) : {}
                    };
                }))
            })
        }, ...addtionContent ];
    }
    parseLLMContent(resJson) {
        const {results: results} = resJson;
        if (!results) return console.error("Insights polish error in LLM"), Object.assign(Object.assign({}, this.context), {
            error: "Insights polish error in LLM"
        });
        const newInsights = this.context.insights.map(((insight, index) => {
            var _a, _b;
            return Object.assign(Object.assign({}, insight), {
                textContent: addPlainText({
                    content: results[index] || (null === (_a = insight.textContent) || void 0 === _a ? void 0 : _a.content),
                    variables: null === (_b = insight.textContent) || void 0 === _b ? void 0 : _b.variables
                })
            });
        }));
        return Object.assign(Object.assign({}, this.context), {
            insights: newInsights
        });
    }
    runBeforeLLM() {
        var _a;
        this.isLLMAtom = !1 !== (null === (_a = this.options) || void 0 === _a ? void 0 : _a.usePolish);
        const dataInfo = extractDataFromContext(this.context), insights = getInsights(Object.assign(Object.assign({}, dataInfo), {
            spec: this.context.spec
        }), this.options), newContext = Object.assign(Object.assign({}, this.context), {
            chartType: dataInfo.chartType,
            fieldInfo: dataInfo.fieldInfo,
            insights: insights
        });
        return this.updateContext(newContext), 0 === insights.length && (this.isLLMAtom = !1), 
        this.context;
    }
}

export const registerDataInsightAtom = () => {
    Factory.registerAtom(AtomName.DATA_INSIGHT, DataInsightAtom);
};
//# sourceMappingURL=index.js.map