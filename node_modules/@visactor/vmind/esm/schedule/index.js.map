{"version":3,"sources":["../src/schedule/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { merge } from '@visactor/vutils';\nimport type { BaseContext, Usage, IBaseAtom, BaseOptions } from '../types/atom';\nimport { AtomName } from '../types/atom';\nimport type { CombineAll, MapAtomTypes, ScheduleOptions, TaskMapping } from '../types/schedule';\nimport { Factory } from '../core/factory';\n\nexport class Schedule<T extends AtomName[]> {\n  atomInstaces: IBaseAtom<BaseContext, BaseOptions>[];\n\n  atomList: AtomName[];\n\n  private context: any;\n\n  options: ScheduleOptions;\n\n  /** current query */\n  protected query: string;\n\n  /** @todo */\n  historySteps: any;\n\n  constructor(atomList: T, options?: ScheduleOptions, context?: CombineAll<MapAtomTypes<T>>) {\n    this.atomList = atomList;\n    this.options = options || {};\n    this.query = '';\n    this.atomInstaces = atomList.map(atomName => this.atomFactory(atomName));\n    this.setNewTask(context);\n  }\n\n  initContext() {\n    this.context = {} as T;\n    this.atomInstaces.forEach(atom => {\n      this.context = atom.buildDefaultContext(this.context);\n      atom.reset();\n    });\n  }\n\n  getAtomOptions(atomName: AtomName) {\n    return merge({}, this.options[AtomName.BASE], (this.options as any)[atomName]);\n  }\n\n  atomFactory(atomName: AtomName) {\n    const options = this.getAtomOptions(atomName);\n\n    return Factory.createAtom(atomName, this.context, options);\n  }\n\n  /** regonize user intention and parse as sub tasks to atom instances */\n  private parseSubTasks(query?: string): TaskMapping {\n    /** @todo */\n    let taskMapping: TaskMapping = {};\n    this.atomList.forEach(name => {\n      taskMapping = {\n        ...taskMapping,\n        [name]: {\n          shouldRun: true,\n          query\n        }\n      };\n    });\n    return taskMapping;\n  }\n\n  private addUsage(oldUsage: Usage, newUsage?: Usage): Usage {\n    const result: Usage = {} as Usage;\n    if (!newUsage) {\n      return oldUsage;\n    }\n    for (const key in oldUsage) {\n      if (Object.prototype.hasOwnProperty.call(oldUsage, key)) {\n        const curKey = key as keyof Usage;\n        result[curKey] = (oldUsage[curKey] || 0) + (newUsage?.[curKey] || 0);\n      }\n    }\n\n    return result;\n  }\n\n  async run(query?: string, shouldRunList?: Record<AtomName, boolean>): Promise<Awaited<CombineAll<MapAtomTypes<T>>>> {\n    this.query = query || '';\n    const subTasks = this.parseSubTasks(query);\n    let usage: Usage = {\n      prompt_tokens: 0,\n      completion_tokens: 0,\n      total_tokens: 0\n    };\n    for (const atom of this.atomInstaces) {\n      const { shouldRun, query: taskQuery } = (subTasks as any)?.[atom.name] || {};\n      if ((shouldRunList as any)?.[atom.name] !== false && (shouldRun || atom.shouldRunByContextUpdate(this.context))) {\n        this.context = await atom.run({ context: this.context, query: taskQuery });\n        usage = this.addUsage(usage, atom.getContext()?.usage);\n      }\n    }\n    this.context = {\n      ...this.context,\n      usage: usage\n    };\n    return this.context;\n  }\n\n  /** init new task ready to run new query */\n  setNewTask(context: any) {\n    this.initContext();\n    this.updateContext(context);\n    this.atomInstaces.forEach(atom => {\n      atom.reset(this.context);\n      atom.clearHistory();\n    });\n  }\n\n  updateOptions(options: ScheduleOptions) {\n    this.options = merge({}, this.options, options);\n    this.atomInstaces.forEach(atom => atom.updateOptions(this.getAtomOptions(atom.name as AtomName)));\n  }\n\n  updateContext(context: any, isReplace = false) {\n    this.context = isReplace ? context : merge({}, this.context, context);\n  }\n\n  /**\n   * get schedule context or specific context of atom\n   * @param atomName name of atom(optional)\n   * @returns context\n   */\n  getContext(atomName?: AtomName): CombineAll<MapAtomTypes<T>> {\n    if (atomName) {\n      const atomInstaces = this.atomInstaces.find(atom => atom.name === atomName);\n      if (!atomInstaces) {\n        console.error(`Doesn\\'t exist ${atomName}`);\n        return null as any;\n      }\n      return atomInstaces.getContext() as any;\n    }\n    return this.context;\n  }\n}\n"]}