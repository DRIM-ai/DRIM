import { FilterNodeType, FilterOperator, } from '../../types';
import { includes, } from '../../utils';
export const judgeFilterTree = (params) => {
    const { filterNode, item, getValue, } = params;
    switch (filterNode.type) {
        case (FilterNodeType.And): {
            const valid = filterNode.conditions.every(filterNode => judgeFilterTree({ filterNode, item, getValue }));
            return filterNode.not ? !valid : valid;
        }
        case (FilterNodeType.Or): {
            if (!filterNode.conditions.length)
                return true;
            const valid = filterNode.conditions.some(filterNode => judgeFilterTree({ filterNode, item, getValue }));
            return filterNode.not ? !valid : valid;
        }
        case (FilterNodeType.Condition): {
            const value = getValue({
                item,
                condition: filterNode,
            });
            const valid = judge({
                value,
                filter: filterNode,
            });
            return filterNode.not ? !valid : valid;
        }
    }
};
export const judge = ({ value, filter }) => {
    if (value === null) {
        if (filter.operator === FilterOperator.IsNull)
            return true;
        return false;
    }
    switch (filter.operator) {
        case FilterOperator.GreaterThan:
            return value > filter.value;
        case FilterOperator.GreaterOrEqual:
            return value >= filter.value;
        case FilterOperator.LessThan:
            return value < filter.value;
        case FilterOperator.LessOrEqual:
            return value <= filter.value;
        case FilterOperator.Equal:
            return value == filter.value;
        case FilterOperator.NotEqual:
            return value != filter.value;
        case FilterOperator.In:
            return includes(filter.value, value);
        case FilterOperator.NotIn:
            return !includes(filter.value, value);
        case FilterOperator.IsNull:
            return false;
        case FilterOperator.IsNotNull:
            return true;
        case FilterOperator.Between:
            return (filter.value[0] <= value) && (value <= filter.value[1]);
        case FilterOperator.NotBetween:
            return (value < filter.value[0]) || (value > filter.value[1]);
        case FilterOperator.Like: {
            const regex = getLikeRegex(filter.value);
            return regex.test(value);
        }
        case FilterOperator.NotLike: {
            const regex = getLikeRegex(filter.value);
            return !regex.test(value);
        }
    }
    return false;
};
const getLikeRegex = (like) => {
    if (!likePatternCache.has(like)) {
        const string = escapeRegExp(like);
        const regexString = `^${string.replace(/%/g, '.*?').replace(/_/g, '.')}$`;
        likePatternCache.set(like, new RegExp(regexString));
    }
    return likePatternCache.get(like);
};
const likePatternCache = new Map();
function escapeRegExp(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
