import { OrderedMap } from '../utils';
import { evaluateRowColumnValue, getColumnIdentityName, } from './select';
export const group = ({ groupBy, source }) => {
    return (tableData) => {
        if (!(groupBy === null || groupBy === void 0 ? void 0 : groupBy.length)) {
            return [{
                    by: {},
                    rows: tableData,
                }];
        }
        const groupMap = buildGroupsMap({
            tableData,
            groupBy,
            source,
        });
        const grouped = traverseToGrouped({
            groupMapOrRows: groupMap,
            groupBy,
        });
        return grouped;
    };
};
export const buildGroupsMap = ({ tableData, groupBy, source = tableData }) => {
    const groupMap = new OrderedMap();
    tableData.forEach(row => {
        let currentMap = groupMap;
        groupBy.forEach((column, index) => {
            const value = evaluateRowColumnValue({
                row,
                source,
                column: { column },
            });
            if (index === groupBy.length - 1) {
                if (!currentMap.has(value)) {
                    currentMap.set(value, []);
                }
                const rows = currentMap.get(value);
                rows.push(row);
            }
            else {
                if (!currentMap.has(value)) {
                    currentMap.set(value, new OrderedMap());
                }
                currentMap = currentMap.get(value);
            }
        });
    });
    return groupMap;
};
const traverseToGrouped = (params) => {
    const { groupMapOrRows, groupBy, grouped = [], depth = 0, by = {}, } = params;
    if (depth === groupBy.length) {
        const rows = groupMapOrRows;
        grouped.push({
            by,
            rows,
        });
        return grouped;
    }
    const column = groupBy[depth];
    const groupMap = groupMapOrRows;
    groupMap.forEach((mapOrList, value) => {
        const columnConfig = { column };
        by[getColumnIdentityName(columnConfig)] = value;
        traverseToGrouped({
            groupMapOrRows: mapOrList,
            groupBy,
            depth: depth + 1,
            by: { ...by },
            grouped,
        });
    });
    return grouped;
};
