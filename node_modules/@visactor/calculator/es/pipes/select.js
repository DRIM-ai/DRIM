import { match, P } from 'ts-pattern';
import { aggregateGroupColumn, getAggregationName } from './aggregate';
export const select = ({ select: { columns }, source }) => {
    return tableData => tableData.map(row => Object.fromEntries(columns.map(selectColumn => [
        getSelectColumnName(selectColumn),
        evaluateRowColumnValue({
            row,
            source,
            column: selectColumn
        })
    ])));
};
export const selectGroup = ({ select: { columns }, source }) => {
    return grouped => grouped.map(group => Object.fromEntries(columns.map((selectColumn) => [
        getSelectColumnName(selectColumn),
        evaluateGroupColumnValue({
            group,
            source,
            column: selectColumn
        })
    ])));
};
export const getSelectColumnName = (selectColumn) => {
    return match(selectColumn)
        .with({ alias: P.string }, ({ alias }) => alias)
        .with({ aggregate: P.optional(P.nullish) }, ({ column }) => column)
        .with({ aggregate: { distinct: P.optional(P.nullish) } }, ({ column, aggregate }) => `${getAggregationName(aggregate)}(${column})`)
        .with({ aggregate: P.not(P.nullish) }, ({ column, aggregate }) => `${getAggregationName(aggregate)}(distinct ${column})`)
        .exhaustive();
};
export const evaluateRowColumnValue = ({ column, row, source }) => {
    return match(column)
        .with({ column: P.string }, ({ column }) => row[column])
        .with({ column: P.instanceOf(Function) }, ({ column }) => column({ row, source }))
        .exhaustive();
};
export const evaluateGroupColumnValue = ({ column, group, source }) => {
    return match(column)
        .with({ column: P.string }, ({ column, aggregate }) => aggregateGroupColumn({ group, column, aggregate }))
        .with({ aggregate: P.instanceOf(Function) }, ({ aggregate }) => aggregate({ group, source }))
        .with({ column: P.instanceOf(Function) }, ({ column }) => column({ row: group.rows[0], source }))
        .exhaustive();
};
export const getColumnIdentity = (column) => match(column)
    .with({ column: P.any }, ({ column }) => column)
    .with({ aggregate: P.any }, ({ aggregate }) => aggregate)
    .exhaustive();
export const getColumnIdentityName = (column) => {
    const identity = getColumnIdentity(column);
    return match(identity)
        .with(P.string, name => name)
        .with(P.instanceOf(Function), evaluate => evaluate.name)
        .exhaustive();
};
