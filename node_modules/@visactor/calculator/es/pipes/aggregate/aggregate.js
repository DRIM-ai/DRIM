import { AggregateType, } from '../../types';
import { OrderedSet } from '../../utils';
import { count, sum, avg, max, min, } from './methods';
export const aggregateGroupColumn = (params) => {
    const { group, column, aggregate, } = params;
    if (!aggregate) {
        return group.rows[0][column];
    }
    return aggregateWithCache({
        group,
        column,
        aggregate,
    });
};
export const aggregateWithCache = (params) => {
    const { group, column, aggregate, } = params;
    const cacheMap = getAggregateCacheMap({
        column,
        aggregate,
        group,
    });
    const aggregation = getAggregationName(aggregate);
    if (!cacheMap.has(aggregation)) {
        const aggregateMethod = getAggregateMethod(aggregate);
        const columnValues = extractColumnValues({
            group,
            column,
            distinct: aggregate.distinct
        });
        cacheMap.set(aggregation, aggregateMethod({
            column,
            values: columnValues,
        }));
    }
    return cacheMap.get(aggregation);
};
export const getAggregateCacheMap = (params) => {
    const { column, aggregate, group, } = params;
    if (!group.aggregations) {
        group.aggregations = {};
    }
    if (!group.aggregations[column]) {
        group.aggregations[column] = {};
    }
    const aggregationMap = group.aggregations[column];
    if (!aggregationMap[whetherDistinct(aggregate)]) {
        aggregationMap[whetherDistinct(aggregate)] = new Map();
    }
    const cacheMap = aggregationMap[whetherDistinct(aggregate)];
    return cacheMap;
};
export const extractColumnValues = (params) => {
    const { column, group, distinct, } = params;
    if (!group.columns) {
        group.columns = {};
    }
    if (!group.columns[column]) {
        group.columns[column] = group.rows.map(row => row[column]);
    }
    const values = group.columns[column];
    if (!distinct) {
        return values;
    }
    if (!group.distinctColumns) {
        group.distinctColumns = {};
    }
    if (!group.distinctColumns[column]) {
        const set = new OrderedSet(values);
        group.distinctColumns[column] = [...set];
    }
    return group.distinctColumns[column];
};
export const whetherDistinct = (aggregate) => (aggregate.distinct ? 'distinct' : 'all');
export const getAggregationName = (aggregate) => {
    const { method } = aggregate;
    if (typeof method === 'function') {
        return method.name;
    }
    return method;
};
export const aggregateTypeMap = {
    [AggregateType.Count]: count,
    [AggregateType.Sum]: sum,
    [AggregateType.Avg]: avg,
    [AggregateType.Max]: max,
    [AggregateType.Min]: min,
};
export const getAggregateMethod = (aggregate) => {
    const { method } = aggregate;
    if (typeof method === 'function') {
        return method;
    }
    return aggregateTypeMap[method];
};
export const removeAggregateCache = (grouped) => grouped.map(group => ({
    by: group.by,
    rows: group.rows,
}));
