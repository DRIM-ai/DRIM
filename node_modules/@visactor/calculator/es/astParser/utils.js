import { isString } from '@visactor/vutils';
import { DataType, ROLE } from './type';
import { isInteger } from '../utils';
export const execPipeline = (src, pipes, context) => pipes.reduce((pre, pipe) => {
    const result = pipe(pre, context);
    return result;
}, src);
export const toFirstUpperCase = (name = '') => name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
export const checkIsColumnNode = (node, columns, fieldInfo) => {
    if (node.type === 'column_ref') {
        return true;
    }
    return false;
};
export const replaceString = (str, replaceMap) => {
    if (!isString(str)) {
        return str;
    }
    if (replaceMap.has(str)) {
        return replaceMap.get(str);
    }
    else {
        const replaceKeys = [...replaceMap.keys()];
        return replaceKeys.reduce((prev, cur) => {
            return replaceAll(prev, cur, replaceMap.get(cur));
        }, str);
    }
};
export const replaceAll = (originStr, replaceStr, newStr) => {
    return originStr.split(replaceStr).join(newStr);
};
function generateRandomString(len) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < len; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}
export const replaceNonASCIICharacters = (str) => {
    const nonAsciiCharMap = new Map();
    const newStr = str.replace(/([^\x00-\x7F]+)/g, m => {
        let replacement;
        if (nonAsciiCharMap.has(m)) {
            replacement = nonAsciiCharMap.get(m);
        }
        else {
            replacement = generateRandomString(10);
            nonAsciiCharMap.set(m, replacement);
        }
        return replacement;
    });
    const swappedMap = swapMap(nonAsciiCharMap);
    return { validStr: newStr, replaceMap: swappedMap };
};
const swapMap = (map) => {
    const swappedMap = new Map();
    map.forEach((value, key) => {
        swappedMap.set(value, key);
    });
    return swappedMap;
};
export const mergeMap = (map1, map2) => {
    map2.forEach((value, key) => {
        map1.set(key, value);
    });
    return map1;
};
export const preprocessSQL = (sql, fieldInfo) => {
    const noNewLine = sql.replace('\n', ' ');
    const reservedMap = {
        KEY: `_KEY_${generateRandomString(10)}_`
    };
    let validSQL = noNewLine;
    const reservedReplaceMap = new Map();
    fieldInfo.forEach(field => {
        const { fieldName } = field;
        let validFieldName = fieldName;
        Object.keys(reservedMap).forEach(reserveWord => {
            if (validFieldName.toUpperCase().includes(reserveWord)) {
                const validWord = reservedMap[reserveWord];
                validFieldName = validFieldName.toUpperCase().replace(new RegExp(reserveWord, 'g'), validWord);
            }
        });
        validSQL = validSQL.replace(new RegExp(fieldName, 'g'), validFieldName);
        if (fieldName !== validFieldName) {
            reservedReplaceMap.set(validFieldName, fieldName);
        }
    });
    const { validStr, replaceMap } = replaceNonASCIICharacters(validSQL);
    const mergedMap = mergeMap(replaceMap, reservedReplaceMap);
    return { validStr, replaceMap: mergedMap };
};
function validateDate(date) {
    return false;
}
export const detectFieldType = (dataset, column) => {
    let fieldType = undefined;
    dataset.every(data => {
        const value = data[column];
        const numberValue = Number(value);
        if (!fieldType) {
            if (!isNaN(numberValue)) {
                if (isInteger(numberValue)) {
                    fieldType = DataType.INT;
                }
                else {
                    fieldType = DataType.FLOAT;
                }
            }
            else if (validateDate(value)) {
                fieldType = DataType.DATE;
            }
            else {
                fieldType = DataType.STRING;
            }
            return true;
        }
        else {
            if (fieldType == DataType.DATE && !validateDate(value)) {
                fieldType = DataType.STRING;
                return false;
            }
            if (fieldType == DataType.INT) {
                if (isNaN(numberValue)) {
                    fieldType = DataType.STRING;
                    return false;
                }
                else if (!isInteger(numberValue)) {
                    fieldType = DataType.FLOAT;
                    return true;
                }
                return true;
            }
            if (fieldType == DataType.FLOAT) {
                if (isNaN(numberValue)) {
                    fieldType = DataType.STRING;
                    return false;
                }
                return true;
            }
            if (fieldType == DataType.STRING) {
                return false;
            }
            return true;
        }
    });
    return {
        fieldName: column,
        type: fieldType,
        role: [DataType.STRING, DataType.DATE].includes(fieldType) ? ROLE.DIMENSION : ROLE.MEASURE
    };
};
export const getOriginalString = (str, replaceMap) => {
    if (!isString(str)) {
        return str;
    }
    if (replaceMap.has(str)) {
        return replaceMap.get(str);
    }
    else {
        const replaceKeys = [...replaceMap.keys()];
        return replaceKeys.reduce((prev, cur) => {
            return prev.replace(new RegExp(cur, 'g'), replaceMap.get(cur));
        }, str);
    }
};
export const parseRespondField = (responseFieldInfo, dataset, replaceMap) => responseFieldInfo.map(field => ({
    ...field,
    ...detectFieldType(dataset, field.fieldName),
    fieldName: getOriginalString(field.fieldName, replaceMap)
}));
