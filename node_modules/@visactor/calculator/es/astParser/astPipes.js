import { isArray } from '@visactor/vutils';
import { checkIsColumnNode, replaceString, toFirstUpperCase } from './utils';
import { FilterNodeType, FilterOperator, OrderType } from '../types';
export const from = (query, context) => {
    const { dataSource, fieldInfo } = context;
    return { ...query, from: dataSource };
};
const parseAggrFunc = (aggrFunc, columns, fieldInfo, replaceMap) => {
    var _a;
    const { name, args } = aggrFunc;
    const { distinct, expr } = args !== null && args !== void 0 ? args : {};
    const result = {
        type: FilterNodeType.Condition
    };
    if (expr && expr.type === 'aggr_func') {
        console.error('unsupported aggr func!');
    }
    else if (expr && checkIsColumnNode(expr, columns, fieldInfo)) {
        const columnName = (_a = expr.column) !== null && _a !== void 0 ? _a : expr.value;
        result.column = replaceString(columnName, replaceMap);
    }
    result.aggregate = {
        distinct: Boolean(distinct),
        method: toFirstUpperCase(name)
    };
    return result;
};
const parseSQLExpr = (astWhere, columns, fieldInfo, replaceMap, isNot) => {
    var _a;
    if (!astWhere) {
        return {};
    }
    const result = {
        not: Boolean(isNot)
    };
    const { type } = astWhere;
    if (type === 'binary_expr') {
        const { left, right, operator } = astWhere;
        if (['AND', 'OR'].includes(operator)) {
            result.type = operator === 'AND' ? FilterNodeType.And : FilterNodeType.Or;
            result.conditions = [
                parseSQLExpr(left, columns, fieldInfo, replaceMap),
                parseSQLExpr(right, columns, fieldInfo, replaceMap)
            ];
        }
        else if (Object.values(FilterOperator)
            .map(v => v.toUpperCase())
            .includes(operator)) {
            result.type = FilterNodeType.Condition;
            const columnNode = [left, right].find(n => checkIsColumnNode(n, columns, fieldInfo));
            if (columnNode) {
                const columnName = (_a = columnNode.column) !== null && _a !== void 0 ? _a : columnNode.value;
                result.column = replaceString(columnName, replaceMap);
            }
            const valueNode = [left, right].find(n => !checkIsColumnNode(n, columns, fieldInfo) && n.type !== 'aggr_func');
            if (valueNode) {
                const valueName = valueNode.value;
                if (!isArray(valueName)) {
                    result.value = replaceString(valueName, replaceMap);
                }
                else {
                    result.value = valueName.map(v => replaceString(v.value, replaceMap));
                }
            }
            const aggrNode = [left, right].find(n => n.type === 'aggr_func');
            if (aggrNode) {
                const aggrFuncConfig = parseAggrFunc(aggrNode, columns, fieldInfo, replaceMap);
                result.column = aggrFuncConfig.column;
                result.aggregate = aggrFuncConfig.aggregate;
            }
            result.operator = operator.toLowerCase();
        }
        else {
            console.error('unsupported operator in expr!');
        }
    }
    else if (type === 'unary_expr') {
        const { expr, operator } = astWhere;
        return parseSQLExpr(expr, columns, fieldInfo, replaceMap, operator === 'NOT');
    }
    else {
        console.error('unsupported type in expr!');
    }
    return result;
};
export const where = (query, context) => {
    const { ast, fieldInfo, replaceMap } = context;
    const { where } = ast;
    if (!where) {
        return query;
    }
    const whereList = parseSQLExpr(where, query.select.columns, fieldInfo, replaceMap);
    return {
        ...query,
        where: whereList.conditions ? whereList : { not: false, type: FilterNodeType.And, conditions: [whereList] }
    };
};
export const groupBy = (query, context) => {
    const { ast, replaceMap } = context;
    const { groupby } = ast;
    if (!groupby) {
        return query;
    }
    return {
        ...query,
        groupBy: (groupby !== null && groupby !== void 0 ? groupby : []).map((group) => { var _a; return replaceString((_a = group.column) !== null && _a !== void 0 ? _a : group.value, replaceMap); })
    };
};
export const select = (query, context) => {
    const { ast, fieldInfo, replaceMap } = context;
    const { columns, distinct } = ast;
    if (!columns) {
        return query;
    }
    const columnAlias = columns.map(c => ({
        alias: c.as
    }));
    return {
        ...query,
        select: {
            columns: (columns !== null && columns !== void 0 ? columns : [])
                .map(column => {
                var _a;
                const result = {};
                const { as, expr } = column;
                if (checkIsColumnNode(expr, columnAlias, fieldInfo)) {
                    result.column = replaceString((_a = expr.column) !== null && _a !== void 0 ? _a : expr.value, replaceMap);
                }
                else if (expr.type === 'aggr_func') {
                    const aggrFuncConf = parseAggrFunc(expr, columnAlias, fieldInfo, replaceMap);
                    result.column = aggrFuncConf.column;
                    result.aggregate = aggrFuncConf.aggregate;
                }
                if (as) {
                    result.alias = replaceString(as, replaceMap);
                }
                return result;
            })
                .filter(c => c.column),
            distinct: Boolean(distinct)
        }
    };
};
export const having = (query, context) => {
    const { ast, fieldInfo, replaceMap } = context;
    const { having } = ast;
    if (!having) {
        return query;
    }
    const havingList = parseSQLExpr(having, query.select.columns, fieldInfo, replaceMap);
    return {
        ...query,
        having: havingList.conditions ? havingList : { not: false, type: FilterNodeType.And, conditions: [havingList] }
    };
};
export const orderBy = (query, context) => {
    const { ast, fieldInfo, replaceMap } = context;
    const { orderby } = ast;
    if (!orderby) {
        return query;
    }
    return {
        ...query,
        orderBy: (orderby !== null && orderby !== void 0 ? orderby : []).map(orderInfo => {
            var _a, _b;
            const result = {};
            const { type, expr } = orderInfo;
            if (checkIsColumnNode(expr, query.select.columns, fieldInfo)) {
                const columnName = (_a = expr.column) !== null && _a !== void 0 ? _a : expr.value;
                result.column = replaceString(columnName, replaceMap);
            }
            else {
                const orderConfig = parseAggrFunc(expr, query.select.columns, fieldInfo, replaceMap);
                result.column = orderConfig.column;
                result.aggregate = orderConfig.aggregate;
            }
            if (!result.aggregate && !fieldInfo.find(field => field.fieldName === result.column)) {
                const originalColumn = query.select.columns.find(column => column.alias === result.column || column.column === result.column);
                if (originalColumn) {
                    result.column = (_b = originalColumn.column) !== null && _b !== void 0 ? _b : originalColumn.alias;
                    result.aggregate = originalColumn.aggregate;
                }
            }
            return {
                type: type ? toFirstUpperCase(type) : OrderType.Asc,
                ...result
            };
        })
    };
};
export const limit = (query, context) => {
    const { ast } = context;
    const { limit } = ast;
    if (!limit) {
        return query;
    }
    return {
        ...query,
        limit: limit.value[0].value
    };
};
