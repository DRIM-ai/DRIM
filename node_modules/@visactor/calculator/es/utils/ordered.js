export class OrderedMap extends Map {
    constructor(entries) {
        super();
        this._keys = [];
        this._indexMap = new Map();
        entries === null || entries === void 0 ? void 0 : entries.forEach(([key, value]) => {
            this.set(key, value);
        });
    }
    clear() {
        super.clear();
        this._keys = [];
        this._indexMap.clear();
    }
    delete(key) {
        if (!this.has(key))
            return false;
        super.delete(key);
        const index = this._indexMap.get(key);
        this._indexMap.delete(key);
        this._keys.splice(index, 1);
        return true;
    }
    set(key, value) {
        if (this.has(key))
            return this;
        super.set(key, value);
        const index = this._keys.length;
        this._keys.push(key);
        this._indexMap.set(key, index);
        return this;
    }
    keys() {
        return this._keys[Symbol.iterator]();
    }
    *values() {
        for (const key of this.keys()) {
            yield this.get(key);
        }
    }
    *entries() {
        for (const key of this.keys()) {
            yield [key, this.get(key)];
        }
    }
    forEach(callbackfn) {
        for (const key of this.keys()) {
            callbackfn(this.get(key), key, this);
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
}
export class OrderedSet extends Set {
    constructor(values) {
        super();
        this._orderedMap = new OrderedMap();
        values === null || values === void 0 ? void 0 : values.forEach(value => {
            this.add(value);
        });
    }
    get size() {
        return this._orderedMap.size;
    }
    clear() {
        this._orderedMap.clear();
    }
    delete(value) {
        if (!this.has(value))
            return false;
        this._orderedMap.delete(value);
        return true;
    }
    add(value) {
        if (this.has(value))
            return this;
        this._orderedMap.set(value);
        return this;
    }
    has(value) {
        return this._orderedMap.has(value);
    }
    keys() {
        return this._orderedMap.keys();
    }
    values() {
        return this._orderedMap.keys();
    }
    *entries() {
        for (const value of this.values()) {
            yield [value, value];
        }
    }
    forEach(callbackfn, thisArg) {
        for (const value of this.values()) {
            callbackfn(value, value, this);
        }
    }
    [Symbol.iterator]() {
        return this.values();
    }
}
